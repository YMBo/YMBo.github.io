{"meta":{"title":"DHYANA","subtitle":null,"description":"YMBo的博客，blog，YMBo","author":"YMBo","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-08-13T13:51:41.000Z","updated":"2017-08-13T13:51:41.306Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-14T08:24:32.000Z","updated":"2017-08-14T08:25:18.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"http-proxy-middleware配合gulp使用时的一些坑","slug":"http-proxy-middleware配合gulp使用时的一些坑","date":"2018-01-09T01:23:58.000Z","updated":"2018-01-09T02:57:47.406Z","comments":true,"path":"2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","link":"","permalink":"http://yoursite.com/2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","excerpt":"","text":"一、介绍在我们用gulp、webpack等方式开发项目的时候，由于会启动个本地服务器，所以如果访问后台提供的接口就是跨域了，这种情况该怎么办呢？这就涉及到了 代理服务 的配置，react项目的webpack的代理服务配置我之前已经写过了，传送门~~。因为使用 http-proxy-middleware 也遇到了多多少少的问题，网上关于遇到的问题解决办法很少或是没有提及（难道问题太弱智？），所以写下这篇文章记录一下（干货满满呦），如果错误烦请指出~~~ 二、环境先说明我的环境：gulp + 静态html 。gulp主要是处理 less 文件和启动服务器方便程序调试 三、目的本地的服务器为：lcoalhost:8080，想要请求的地址为：https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0 （请求地址是我从QQ音乐找的，正因为这样我又遇到了另外一个 ajax的坑，最后一节有说明，所以这个地址也具有一定的教学意义） 四、配置1.gulpfile.js1234567891011121314151617181920212223var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware'), path = require('path'),gulp.task('connect', function() &#123; connect.server(&#123; /*根路径*/ root: './dist', /*开启浏览器自动刷新*/ livereload: true, /*端口号*/ port: 8080, /*使用代理服务*/ middleware: function(connect, opt) &#123; return [ proxy('/api/', &#123; target: 'https://c.y.qq.com/', changeOrigin:true, &#125;) ] &#125; &#125;);&#125;); 说明 proxy配置项： 其中return 返回是一个数组，所以通过配置多个proxy返回值可以实现多重代理 changeOrigin 这个意思是，如果我们代理的目标地址是一个虚拟托管站点，比如 http://www.baidu.com 这种域名的形式的target项，则需要配置此项。如果target项为ip值，比如http://10.10.16.5/ 则不用配置此项 2.index.html12345678910$.ajax(&#123; type: 'GET', url: \"/api/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 3.结果可以看到，请求失败 /(ㄒoㄒ)/~~ 4.解决办法就是在这个问题上我卡了一下午，为了能游刃有余的使用这个东西，有些基本的参数还是要非常明白的123pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;, 很多的技术文章的配置都有写这个东西，但是很少有介绍这个参数的意思。 下面我们来看看不配置此项真正请求的地址： 不配置这个参数请求代理的地址：https://c.y.qq.com/ api /soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0看我标记粉色的地方，再回过头对比我们要请求的地址，是不是多个了 /api/ ? 所以 pathRewrite 这个配置项的意思是，当有 /api/ 字段请求的时候，指定 重写 /api/ 这个字符串，这里为空。 比如：目标地址：http://www.baidu.com/aaa/bbb proxy配置：12345proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, &#125;) 本地服务器：http://localhost:8888 ajax：12345678910$.ajax(&#123; type: 'GET', url: \"/api/aaa/bbb\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 但是实际上请求的是 http://www.baidu.com/api/aaa/bbb 这个地址 ！！！！！。 所以第一种解决办法是配置重写路径1234567proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;,&#125;) 第二种解决办法就是利用已有路径 1234proxy('/aaa/', &#123; target: 'http://www.baidu.com/', changeOrigin:true,&#125;) 关于 http-proxy-middleware 我遇到的问题，已经说完了。下面来说 ajax的一个坑 五、ajax用jq的 ajax请求一个地址，如果返回的数据格式与ajax里预期格式的配置不一样，那么就会在 error 函数里面返回后台提供的数据 ，具体例子就不写了，很简单，可以试一试","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"webpack热更新(HMR)","slug":"webpack热更新-HMR","date":"2018-01-02T07:40:44.000Z","updated":"2018-01-08T01:33:52.500Z","comments":true,"path":"2018/01/02/webpack热更新-HMR/","link":"","permalink":"http://yoursite.com/2018/01/02/webpack热更新-HMR/","excerpt":"","text":"一、HMR介绍在我们开发react应用的时候，在配置了webpack-dev-server的前提下每一次的组件内容修改都需要手动的刷新浏览器，为了解决这个问题，所以有了热更新这个概念，网上的文章弄得我一头雾水，在我配置成功后，自己来记录一下热更新的配置 二、配置1.从零开始–项目初始化首先创建一个基本的react的项目，然后命令行运行 npm init 生成 package.json 文件。 新建 build,client 文件夹，分别用来存放 webpack 配置（webpack.config.js文件）和 react 组件。当前目录结构： 目录结构 2.基本的webpack配置为了自动产出html文件，安装 html-webpack-plugin 为了解析 react 组件和对es6的解析，安装 babel-loader babel-core babel-preset-es2015 babel-preset-es2015-loose babel-preset-react 模块，并在根目录新建文件 .babelrc 文件 babel 的配置文件 .babelrc 此时 package.json 文件的包 package.json 添加 webpack-devserver 配置，此时 webpack-config.js 配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');module.exports=&#123; entry: &#123; app:path.join(__dirname,'../client/app.js') &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin() ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; 此时启动webpack-dev-server后，运行成功 package.json 友情提示：： 如果在执行命令的过程中报错 ‘cannot find …’ 这类的错误，首先检查是否少装了包，如果没有少装，则删除 node_module文件夹，重新安装下。 如果运行 webpack-dev-server 启动服务器的时候，网页的 js 文件显示404，首先检查是否本地已经有了一个编译好的 dist 文件夹，因为webpack-dev-server会优先读取本地文件，配置的时候我们添加了 /pubilc/ 所以是读取不道德，这时，删除本地 dist文件夹即可。（这个相当相当的坑） 在入口文件中，我这样写 document.body 是不可取的，正确的做法是 获取Id的形式。 知识点！( 敲黑板 )：path.join 和 path.resolve 区别 path.join：拼接地址（会正确使用当前系统的路径分隔符，Unix系统是/，Windows系统是\\）比如：path.join（‘m’,’/b’） 或者 path.join（‘m’,’b’） 返回m/b这个路径path.resolve：将参数转换为绝对路径比如 path.resolve(‘m’) ;如果当前命令窗口是在c盘打开的，那么返回C:\\m(总是返回一个绝对路径)对比：两种方法都可以获得当前目录的绝对路径（通过__dirname），因为path.join可以适应unix和windows，所以join可能好一些 三、重头戏-配置HMR这里说是简单，但我觉得对于初次使用还是比较繁琐，整理一下，分为下面几个步骤(与顺序无关) 安装 react-hot-loader 配置 babelrc 文件 配置 入口文件app.js 配置 webpack.config.js 2.配置 .babelrc 文件 .babelrc 3. 配置 入口文件app.js 4. 配置 webpack.config.js改动部分标记为 //add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');const webpack=require('webpack'); //addmodule.exports=&#123; entry: &#123; app:[ 'react-hot-loader/patch', //add path.join(__dirname,'../client/app.js') ] &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(), new webpack.HotModuleReplacementPlugin() //add ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*热加载*/ //add hot:true, //add /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; react-hot-loader参考 好了，该做的做完了，打开浏览器测试，发现更改App.jsx文件后浏览器竟然特么没有变化,这就很气人，我也按照你官网上写的做了，现在出不来？好吧，看下面的解决办法 四、解决上面的问题app.js这个入口文件中，更改为： 更改为 如果有了更改，那么 重新用 require 的方式获取一下这个组件，然后进行渲染 成功啦！ 是不是有了疑问，为啥用 require 的方式引入呢？因为这种形式的文件引入import的方式引入不了 五、总结本来一个挺好的功能，分别写在了 webpack官网和 react-hot-loader 官网，这还不算啥，最后还运行不了，多坑，好了就记录到这里了,如果有问题或者补充欢迎回复","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"HMR","slug":"HMR","permalink":"http://yoursite.com/tags/HMR/"}]},{"title":"react服务端渲染","slug":"react服务端渲染","date":"2017-12-26T09:02:19.000Z","updated":"2017-12-26T09:03:16.002Z","comments":true,"path":"2017/12/26/react服务端渲染/","link":"","permalink":"http://yoursite.com/2017/12/26/react服务端渲染/","excerpt":"","text":"看了react服务端渲染，有点蒙圈，先挖坑准备","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"select禁止更改值","slug":"select禁止更改值","date":"2017-11-30T02:31:59.000Z","updated":"2017-11-30T02:44:25.605Z","comments":true,"path":"2017/11/30/select禁止更改值/","link":"","permalink":"http://yoursite.com/2017/11/30/select禁止更改值/","excerpt":"","text":"一、效果介绍select框选中了一个值后禁止更改select 二、方法1.css利用disabled=&quot;true&quot;来禁止选中缺点：这种方法虽然简单，但是它禁止了select框获得焦点，不能看到select的内容优点：简单 2.js123456&lt;select name=\"selectname\" id=\"selectid\" onfocus=\"this.defaultIndex=this.selectedIndex;\" onchange=\"this.selectedIndex=this.defaultIndex;\"&gt; &lt;option value=\"1\"&gt;dd&lt;/option&gt; &lt;option value=\"2\"&gt;mm&lt;/option&gt; &lt;option value=\"3\" selected=\"selected\"&gt;cc&lt;/option&gt; &lt;option value=\"4\"&gt;ff&lt;/option&gt;&lt;/select&gt; 1.获取焦点时，将当前的值 selectedIndex 赋值给一个自定义的属性 defaultIndex2.change时，将当前的值设置为 defaultIndex 优点：select框依然可以选择，被下拉","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"滑动窗口算法解决指定字符串最长子串长度问题","slug":"滑动窗口算法解决指定字符串最长子串长度问题","date":"2017-11-16T07:52:51.000Z","updated":"2017-11-16T07:52:51.498Z","comments":true,"path":"2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","link":"","permalink":"http://yoursite.com/2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"for循环的灵活运用","slug":"for循环的灵活运用","date":"2017-11-13T08:11:30.000Z","updated":"2017-11-13T09:29:14.245Z","comments":true,"path":"2017/11/13/for循环的灵活运用/","link":"","permalink":"http://yoursite.com/2017/11/13/for循环的灵活运用/","excerpt":"","text":"一、介绍for循环是平时在写代码过程中最常用的代码了，一般写的时候都是中规中矩，比如这样：1234for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125;//打印出四次i的值 个人觉得，要想用好一个东西就要明白它的工作原理，那么for循环的工作原理是什么呢？ 二、工作原理其实对于for循环的工作原理之前也是有多次了解的，可是长时间不去回忆一个知识点，知识点就会变得模糊，这里再次记录一下它的工作流程123for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125; 1.声明一个变量i=02.判断i是否小于43.如果满足判断条件，执行console.log(i)（函数体）4.i++5.循环步骤1-4 图 三、延伸上面的写法都是中规中矩的，for循环有三个对应的参数，以；分隔，那么我可不可以省略其中某个参数呢？ 省略之前要注意，；是一定要加的1.全都省略123for(;;)&#123; console.log(1)&#125; 结果：这样写相当于无限循环了，根本停不下来 2.省略第一参数12345var i=0;for(;i&lt;2;)&#123; console.log(i)&#125;// 在外面声明了一个 i ，如果不声明这个东西，那判断条件该判断啥？所以这就相当于没有省略第一个参数，当然正常情况下我还没见到省略第一个参数的情况，一般情况第一个参数都是有的 结果：这样也会无限循环，因为i的值一直为0，所以它会无限的循环下去延伸：既然第三个参数省略了，我们可以再函数体里面定义它的累加规则啊，比如这样1234567for(var i=0;i&lt;20;)&#123; // 6的倍数 i=i+6; if(i%6===0&amp;&amp;i&lt;20)&#123; console.log(i) &#125;&#125; 好处：循环的次数大大降低，性能提升了，在这里正常情况下需要循环20次进行判断，现在的写法仅需要循环4次（第四次没有打印但是执行了函数体） 仔细观察后发现，其实这种方式就是仅仅省略了第三个参数 3.看看省略第三个参数还能干嘛问题：给定一个很大的数组，数组里面有许多证书，用JavaScript实现一个函数，要求：将数组中之和为10的每一对数配对并找出，返回这些数配对后的数组。例如：[11,3,8,9,7,-1,1,2,4…]得到：[[11,-1],[3,7],[8,2],[9,1]…] 思路：其实一般的写法是两个for循环进行潜逃的那种，这里就不展示了，这里写的是优化后的写法123456789101112131415161718192021let list = [1,2,3,-5,9,45,6];function map(list)&#123; let ret=[]; list=list.sort((a,b)=&gt;a-b); /*省略的第三个参数*/ for(let i=0,j=list.length-1;i&lt;j;)&#123; let a=list[i],b=list[j]; if(a+b===10)&#123; ret.push([a,b]); i++; j--; &#125;else if(a+b&lt;10)&#123; i++; &#125;else&#123; j--; &#125; &#125; return ret;&#125;console.log(JSON.stringify(map(list)))//结果：[[1,9]] 思路：这里影响性能的主要是太多次的for循环，数据量小还好，如果特别多怎么办？所以要减少for循环次数，先将数组从小到大排序，然后进行从两边到中间的计算，符合条件就 push一次 四、总结简简单单的一个for循环可以有不同的写法，所以说写代码简单，写出有质量的代码难","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"斐波那契数列的实现","slug":"斐波那契数列的实现","date":"2017-10-25T09:10:02.000Z","updated":"2017-10-25T10:59:23.307Z","comments":true,"path":"2017/10/25/斐波那契数列的实现/","link":"","permalink":"http://yoursite.com/2017/10/25/斐波那契数列的实现/","excerpt":"","text":"一、扫盲斐波那契数列也叫黄金分割数列，也叫兔子数列原理：假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？ 月份 兔子情况 总数 第0个月 a（小兔子） 1 第1个月 a（具备繁殖能力） 1 第2个月 b（生啦生啦）+ a（他父母） 2 第3个月 b（2月份出生的具备繁殖能力，正跃跃欲试） + b2（他父母又生二胎了） +a（他父母） 3 第4个月 c（2月份的兔子b喜当爹）+b（二月份出生的兔子） + b2（二胎具备繁殖能力，准备生娃） +a（他父母）+d(a生三胎) 5 … … … 1、1 、2、3、5、8、13、21、34、55、89……所以规律就是 fn(n)=fn(n-1)+fn(n-2) 二、代码实现1.第一种这种是最常见的实现：迭代12345678910111213/**i 月份*/function fn(i)&#123; var a=[]; /*0个月什么都不存在*/ a[0]=0; a[1]=1; for(var o=2;o&lt;=i;o++)&#123; a[o]=a[o-1]+a[o-2]; &#125; return a[i]&#125; 2.第二种递归1234567/** i 月份*/function fn(i)&#123; if(i&lt;2)&#123;return i===0?0:1;&#125; return fn(i-1)+fn(i-2)&#125; 是不是感觉很简洁 三、缺陷针对这个例子来说，这里的递归会进行太多次的调用（比迭代多），所以简洁的背后牺牲的是性能","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"css中的attr()","slug":"css中的attr","date":"2017-10-11T03:43:15.000Z","updated":"2017-10-11T05:20:29.499Z","comments":true,"path":"2017/10/11/css中的attr/","link":"","permalink":"http://yoursite.com/2017/10/11/css中的attr/","excerpt":"","text":"1.介绍attr() 用来获取一个html元素的属性值，可以用于伪元素，可以用于任何css属性 2.用法这个使用起来非常方便且简单1content:attr(属性值); attr()可以传三个值，分别是属性值、类型限制、默认值（必须符合类型限制），不过我试了半天也没调试成功，而且一般写一个参数就行，三个参数的情况基本用不到，所以就跳过了 3.例子12345678910111213141516171819&lt;hear&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 400px; height: 400px; border:1px solid #ccc; &#125; .box:after&#123; content:attr(data-foo); background-color: #ff461d; color: #fff; border-radius: .32rem; padding: .053333rem .133333rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\" data-foo=\"hello\"&gt;&lt;/div&gt;&lt;/body&gt; 此时，在div中将会出现一个红色背景的hello 4.实例那么这个东西在什么情况下能用到呢？ 购物车","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"attr()","slug":"attr","permalink":"http://yoursite.com/tags/attr/"}]},{"title":"react中的this.props.children","slug":"React.Children","date":"2017-09-28T09:34:55.000Z","updated":"2017-09-28T09:52:35.938Z","comments":true,"path":"2017/09/28/React.Children/","link":"","permalink":"http://yoursite.com/2017/09/28/React.Children/","excerpt":"","text":"一、介绍React.Children 是顶层API之一，为处理 this.props.children 提供了几个方法this.props.children 表示组件所有子节点 二、所有方法1.React.Children.map12345678//必须有返回值React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;)//没有返回值React.Children.map(this.props.children,function(child)&#123; /*这里进行处理*/&#125;) 这里的 child 表示组件的每一个子元素，也可以用箭头函数来写，这样方便this的传递 2.this.props.children这个是获取当前组件的所有子节点注意 ：1.如果没有子节点，返回 undefined2.如果一个子节点，返回 object3.如果多个子节点，返回 array但是用 React.Children.map 来遍历的话不会有问题 3.React.Children.count返回组件的所有子元素个数 4.React.Children.only12console.log(React.Children.only(this.props.children[0])); //输出对象this.props.children[0] 单独 this.props.children[0] 输出不出来 5.child.key在用 React.Children.map 的时候可能想获取传过来的属性值，例如123456789101112&lt;Tabs_li data=&#123;data&#125;&gt; &lt;div key=&#123;0&#125;&gt;1&lt;/div&gt; &lt;div key=&#123;1&#125;&gt;2&lt;/div&gt; &lt;div key=&#123;2&#125;&gt;3&lt;/div&gt;&lt;/Tabs_li&gt;/*Tabs组件*/&#123;React.Children.map(this.props.children,(child)=&gt;&#123; console.log(child.key) // 分别打印 0 ， 1 ，2 return ...&#125;)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react中跨域请求数据","slug":"react中跨域请求数据","date":"2017-09-27T06:03:37.000Z","updated":"2018-01-09T03:00:49.518Z","comments":true,"path":"2017/09/27/react中跨域请求数据/","link":"","permalink":"http://yoursite.com/2017/09/27/react中跨域请求数据/","excerpt":"","text":"一、介绍在我写 react ele 项目的时候，里面的所有数据都要从ele获取，所以我之前的想法是先用死的数据模拟，然后用 node 写几个接口请求ele数据并返回给我的react。知道今天早上，我在纳闷 react开发过程中是用 webpack 起服务器的，那跟后台就是跨域了啊，这样ajax是没有办法请求的，所以吃完一个鸡蛋后查找了一番，果然让我找到了，看下面 传送门 – gulp里服务端代理配置 二、配置webpack中 proxy 是设置代理的1234567proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", secure: false, changeOrigin : true &#125;&#125;, 现在比如说我 /api/users 这么请求，现在将代理请求http://localhost:3000/api/users 注意 ：这里的 secure 参数表示能请求 https 的服务器changeOrigin 表示是否支持跨域请求，默认 false 实例好了 现在我来试验一下12345\"/base\": &#123; target: \"http://c.y.qq.com/\", secure: false, changeOrigin : true&#125; 这个是我从qq音乐找了一个借口，在react中通过 fetch 请求12var result = fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; credentials: 'include', headers: &#123; 'Accept': 'application/json, text/plain, */*' &#125; &#125;)result.then(res =&gt;&#123;return res.text();&#125;).then(text =&gt; &#123; console.log(text) &#125;) 看看返回结果 控制台输出 是不是很方便~","categories":[],"tags":[{"name":"webpack proxy","slug":"webpack-proxy","permalink":"http://yoursite.com/tags/webpack-proxy/"},{"name":"react跨域请求","slug":"react跨域请求","permalink":"http://yoursite.com/tags/react跨域请求/"}]},{"title":"认识pushstate、popstate,无刷新改变URL","slug":"认识pushstate、popstate-无刷新改变URL","date":"2017-09-22T06:39:04.000Z","updated":"2017-09-25T06:02:47.107Z","comments":true,"path":"2017/09/22/认识pushstate、popstate-无刷新改变URL/","link":"","permalink":"http://yoursite.com/2017/09/22/认识pushstate、popstate-无刷新改变URL/","excerpt":"","text":"一、回顾 window.historyhistory对象包含用户（在浏览器窗口中）访问过的url12345678910//回退history.back();//前进history.forward();//跳转history.go();//历史记录条数（当前网页的，不是浏览器的）history.length//状态history.state 二、认识新特性HTML5扩展了history,使历史记录更加灵活，可以在历史记录中存储指定记录点、替换当前历史记录点，监听历史记录点 2.1.存储历史记录点123456window.history.pushState('新添加的','','?page=3');// 第一个参数：设置state// 第二个参数：页面标题，但是所有浏览器都忽略了，传空字符串就行// 第三个删除：想要添加的链接//`注意，这个api会改变当前的网址，会添加一条历史记录，不是push到后面，这样会添加一条历史` 执行后，页面的URL为当前url？page=3 执行前 执行后 此时的history.length也会+1，新增了历史记录点 2.2.替换历史记录点123window.history.replaceState('新添加的','','?page=3');//`注意，这个api会改变当前的网址，不会添加一条历史记录，注意与上面pushState区别` 区别：1.history.length不会变2.替换了当前页的历史记录点 2.3.监听历史记录点1window.onpopstate=function()&#123;&#125; 浏览器前进后退都会触发这个事件比如可以这样：123window.onpopstate=function(event)&#123; console.log(event.state)&#125; 后退操作时，就会打印出后退到的历史记录点的state信息。 四、用途在我写react饿了么的项目时，点击首页的定位信息，会从右滑动出一个新的页面，此时再通过浏览器的前进后退按钮也可以实现页面的滑动 浏览器控制动画 具体制作过程看我的github：ele项目 五、补充在用 document.referrer 做返回按钮的时候，是只有 a标签 才能添加一条来源的。比如我通过点击页面的一个 链接 调到了对应的页面，那么此时 document.referrer 是有值的，通过 history.pushState 添加的历史记录跳转的页面,不会添加一条 document.referrer 来源","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"position的sticky属性","slug":"position的sticky属性","date":"2017-09-13T02:25:03.000Z","updated":"2017-09-13T07:35:45.556Z","comments":true,"path":"2017/09/13/position的sticky属性/","link":"","permalink":"http://yoursite.com/2017/09/13/position的sticky属性/","excerpt":"","text":"表头跟随 图中展示的效果使我们在日常开发中常见的效果。以前我都是用js判断是否滚动一定距离然后给这个元素设置position:fixed这种方式来做的，今天就来记录一下用css怎么做 一、介绍css 中的 position 属性的值常用的主要有下面几种：1.absolute2.relative3.fixed现在用到的值为 sticky：设置了sticky的元素，不脱离文档流，在屏幕范围时（viewport），该元素位置不受到定位影响（top、left等值无效），当该元素的视图将要离开偏移范围时，定位会变成 fixed 的效果，并且根据设置的top 、left值进行定位 二、用法上面的gif图里，我将搜索框的元素设置为123postion:sticky;top:0;left:0 所以当移出屏幕时就会触发fixed定位 三、兼容性刚刚把它用在实际项目中去了，结果安卓自带的浏览器不支持，所以附加上解决办法：12345678910111213141516171819202122232425262728//判断是否支持if (CSS.supports(\"position\", \"sticky\") || CSS.supports(\"position\", \"-webkit-sticky\")) &#123; // 支持 sticky,顶部吸附 this.setState(&#123; support:true &#125;)&#125;else&#123; document.addEventListener('scroll',this._scrollTop)&#125;//不支持的主要处理_scrollTop()&#123; let offsetY=this.searchDOM.offsetTop; let css=null; if(window.scrollY&gt;offsetY)&#123; css=&#123; position:'fixed', top:0, zIndex:999 &#125; &#125;else&#123; css=&#123; position:'static', &#125; &#125; this.setState(&#123; css &#125;)&#125; 四、总结 该元素不脱离文档流，仍保留元素原本在文档流中的位置 当元素在容器中被滚动超过指定偏移值时，元素在容器内固定在指定位置。比如你设置了 top:50px 那么sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动 元素固定的相对偏移是相对于它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于 viewport 来计算元素的偏移量","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"create-react-app配置webpack","slug":"create-react-app配置webpack","date":"2017-09-06T08:42:15.000Z","updated":"2017-09-07T03:46:41.507Z","comments":true,"path":"2017/09/06/create-react-app配置webpack/","link":"","permalink":"http://yoursite.com/2017/09/06/create-react-app配置webpack/","excerpt":"","text":"在学习react过程中，每次都要配置webpack，非常的麻烦，我是要写react的，不是配置这东西哒！！好在有了’create-react-app’，通过npm安装后，创建项目变得非常简单但是它里面没有做less等你实际项目需要的loader或者plugins，所以这里记录的是怎么定制create-react-app创建的项目的webpack 一、先配置less1.创建一个项目我创建的叫test test测试项目 创建完毕后，进入创建的项目，运行npm start启动此项目 启动 2.找到webpack.config.dev.js和webpack.config.prod.js运行npm run eject安装less-loader和less进入config文件夹，这里会有两个文件webpack.config.dev.js和webpack.config.prod.js应该一个是开发环境一个生产环境的配置文件，两个文件都要修改打开webpack.config.dev.js找到module rules部分，也就是配置loader的部分，找到配置css文件的test（/\\.(css)$/）修改为test:/\\.(css|less)$/,添加一个loader：{ loader: require.resolve(&#39;less-loader&#39;) },放在最下面1234567891011121314151617181920212223242526&#123; test: /\\.css$/, use: [require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () = &gt;[require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: ['&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') &#125;, ],&#125;, 3.测试现在我们做一下测试可以随便在css文件中加入less语法我在App.css中设置了整体的背景颜色：1234567@base: pink;.App-header &#123; background-color: @base; height: 150px; padding: 20px; color: white;&#125; 因为我们修改了webpack的配置项，所以需要重新启动服务器： 添加成功 可以看到，配置已经成功 二、配置px2rem1.解释px2rem是做移动端页面开发的时候，自动将px单位转换为rem，非常的方便这里要用支持webpack的对应loader，我用的是postcss-px2rem配置这个功能相对来说有些复杂 2.安装npm install postcss-px2rem postcss-loader --save执行这个命令安装 3.配置还是webpack.config.dev.js，引入1const px2rem = require('postcss-px2rem') 添加在的autoprefixer下面添加，好像loaders里只能有一个postcss，多个的话不会报错，对应的功能会不管用12345678910111213141516171819202122&#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), //这个位置 px2rem(&#123;remUnit: 75&#125;) ], &#125;,&#125;, 这里面的数值就是1rem对应的px 4.测试现在启动服务器，因为原有的都是以px为单位，所以现在页面上应该全部转换为了rem 添加成功 不要忘了配置webpack.config.prod.js这个文件，最后只需要在你的页面上对html的font-size做变换就可以了，这里略过 5.总结webpack的文档和有些npm的文档写的走点心好么，搞得本来挺简单的东西查了好久！","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"px2rem","slug":"px2rem","permalink":"http://yoursite.com/tags/px2rem/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"箭头函数的this指向","slug":"箭头函数的this指向","date":"2017-08-25T07:14:31.000Z","updated":"2017-08-25T08:21:55.255Z","comments":true,"path":"2017/08/25/箭头函数的this指向/","link":"","permalink":"http://yoursite.com/2017/08/25/箭头函数的this指向/","excerpt":"","text":"前言 es6的箭头函数非常简洁，而且还可以解决很多问题1.解决以前通过var that=this方式传值的问题1234567document.body.addEventListener('click',function()&#123; setTimeout(function()&#123; console.log(this) /*window*/ /*对body节点操作代码...*/ &#125;)&#125;) 比如点击body，过一段时间对body这个元素进行对应的js操作，如上代码，很明显是不对的，因为setTimeout里的this是全局window所以是不能通过它操作body元素， 一般这种情况以前都是通过在外层通过一个变量将this传递进来，但是有了箭头函数就不用这么做了 es6:1234567document.body.addEventListener('click',function()&#123; setTimeout(()=&gt;&#123; console.log(this) /*body(当前节点)*/ /*对body节点操作代码...*/ &#125;)&#125;) 这类的问题还有很多，但是为什么箭头函数能轻易地解决这些问题呢？所以要清楚能这么写的原因就要清楚箭头函数中this的指向 一、写箭头函数的小提示1.当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。1234/*错误*/()=&gt;&#123;&#125;/*正确*/()=&gt;(&#123;&#125;) 因为JavaScript引擎会将{x}理解成一个代码块，空对象和块在这里都是{}这样表示，所以如果返回的是一个对象，需要加一个小括号 箭头函数的this箭头函数没有自己的this!!!!!!!!!,它内部的this值集成自外围作用域123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 t1、t2、t3都输出1因为箭头函数没有自己的this所以this.id会顺着作用域链查找一直找到foo()函数 箭头函数的的特点它没有arguments变量12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 如果有了新发现，会回来补充","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"react中的context","slug":"react中的context","date":"2017-08-21T03:29:02.000Z","updated":"2017-08-21T06:01:30.976Z","comments":true,"path":"2017/08/21/react中的context/","link":"","permalink":"http://yoursite.com/2017/08/21/react中的context/","excerpt":"","text":"一、为什么用context？现在我们有一颗组件树： 组件树 假如这个组件树代表的应用是用户可以自定义主题的，每个子组件都会根据主题的不同来调整自己的样式，所以‘主题色’这个东西就应该是组件之间共享的一个状态，所以应该放到Index组件中。但是在此之前能想到的办法只能是this.props.主题色 主题色的传递 这种形式，这种形式实在是麻烦，如果组件嵌套过深，就不得不一层层传递到最底层，所以就出现了简单的办法——通过context传递context这种方法是全局都能共享的状态，我们需要的时候就去取这个状态，不需要手动传递 context共享状态 二、实践，看看代码怎么写先创建一个整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;Title /&gt; &lt;/div&gt; ) &#125;&#125;class Main extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is main&lt;/h2&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;class Title extends Component &#123; render () &#123; return ( &lt;h1&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;React.js 小书内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 修改Index组件修改Index组件，让他往自己的context中放一个themeColor：1234567891011121314151617181920212223class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: 'red' &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 代码说明1.state初始化一个themeColor状态，方便以后的修改2.getChildContext方法设置context，返回一个的对象就是context，所有子组件动能访问到，且用this.state.themeColor来设置context里面的themeColor3.注意，还需要加上一段参数的验证 childContextTypes,需要使用prop-types这个包，验证的是getChildContext返回的对象以上这些都是必须的,这里要提及一下为啥要验证context，这么多步骤多麻烦，据说context是一个危险的属性(context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料),所以按照react.js团队的想法就是，把危险的事情搞复杂一些，提高使用门栏人们就不去用了 子组件的设置class Title extends Component { static contextTypes = { themeColor: PropTypes.string } render () { return ( &lt;h1 style={{ color: this.context.themeColor }}&gt;React.js 小书标题&lt;/h1&gt; ) } } 1.利用contextTypes进行验证，必写的，不写就无法获取context的状态，2.使用的话是通过this.context.themeColor来获取值的 修改context在Index里面，我们已经初始化一个state状态了，叫：this.state.themeColor,所以使用setState就可以了 四、我的例子: 点击变色按钮前 点击变色按钮后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript时间处理小技巧","slug":"js时间","date":"2017-08-18T07:41:37.000Z","updated":"2017-08-18T08:08:32.412Z","comments":true,"path":"2017/08/18/js时间/","link":"","permalink":"http://yoursite.com/2017/08/18/js时间/","excerpt":"","text":"获取当前时间1new Date() 获取当前时间的毫秒数12345678new Date().getTime()/*返回1970年1月1日至今的毫秒数*//*下面是作用相同，写法不同*/Date.now()/*这个也返回值相同*/+new Date() +”操作符123456789/*将元素转换成number类型*/+'123'/*返回123*/+'www'/*返回NaN*//*同理*/+Date.now() toLocaleDateString() 和 toLocaleTimeString() 区别123456789new Date().toLocaleDateString()/*2017/8/18 获取的年月日*/new Date().toLocaleDateString()/*下午3:56:16 获取的时分秒*//*注意必须要用时间对象调用才行 比如 Date.now().toLocaleDateString()会报错，因为Date.now()返回的是毫秒数*/ 时间格式处理技巧如果想格式处理 当前时间与之前某个特定时间的时差 可以用这样的方式123456789/*duration为差值*/duration&gt;60 ?`$&#123;Math.round(duration/60)&#125;分钟前` : `$&#123;Math.round(Math.max(duration , 1))&#125;秒前`/*1.利用了ES6的模板字符串，结构更清晰2.利用三目运算符(三元运算符)进行判断，避免各种if3.Math.max 如果差值小于1s，则按1s计算，避免又一次的if判断*/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"gitment评论插件的配置","slug":"Hexo博客下gitment评论功能","date":"2017-08-14T09:03:00.132Z","updated":"2017-08-14T08:03:42.300Z","comments":true,"path":"2017/08/14/Hexo博客下gitment评论功能/","link":"","permalink":"http://yoursite.com/2017/08/14/Hexo博客下gitment评论功能/","excerpt":"","text":"今天我在第N次搭建博客的时候想加一个评论功能，我用的主题是indigo，在根目录_config.yml文件里经过测试发现最简洁好用的就是gitment，所以这里记录我gitment配置过程： 第一步先注册一个 oAuth Application注册成功会得到一个client id和 client secret两个参数，它们将被用于后面的用户登录 oAuth Application _config.yml 其中githubID需要https://api.github.com/users/github账户名 访问这个链接来获取 第二步如果你想要此功能的页面存在这一部分： gitment页面配置 这是一个ejs页面，里面是模板，通过使用主题的_config.yml文件配置那么你可以跳过这一步，否则需要在使用评论功能的页面添加这写代码：1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', // 可以是你的GitHub用户名，也可以是github id repo: '存储评论的 github repo', oauth: &#123; client_id: '你的 client id', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 第三步到这里已经默认你添加了上面的代码，现在注意了，我用的主题本身就带上面的代码的，只不过需要在 主题的 _comfig.yml文件中配置对应项，我在配置文件中配置好后，启动本地服务器，发现回复模块报错，控制台中发现他会请求一个链接，链接上带有刚刚配置好的参数，这里参数全部为空，我以为我配置文件有问题，折腾了好久，仍然不行，后来发现我要添加这个功能的页面里的模板并没有获取到我在_config.yml配置，最后通过修改要添加回复功能页面的模板文件才成功： 修改为 直接赋值，而不是使用模板，不知道为啥用模板获取不到值，现在已经配置成功如果配置失败，那么一定是上面的参数写错了，或者像我这种情况模板页面获取不到值，只需要直接赋值即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}