{"meta":{"title":"DHYANA","subtitle":null,"description":"YMBo的博客，blog，YMBo","author":"YMBo","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-08-13T13:51:41.000Z","updated":"2017-08-13T13:51:41.306Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-14T08:24:32.000Z","updated":"2017-08-14T08:25:18.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"for循环的灵活运用","slug":"for循环的灵活运用","date":"2017-11-13T08:11:30.000Z","updated":"2017-11-13T09:29:14.245Z","comments":true,"path":"2017/11/13/for循环的灵活运用/","link":"","permalink":"http://yoursite.com/2017/11/13/for循环的灵活运用/","excerpt":"","text":"一、介绍for循环是平时在写代码过程中最常用的代码了，一般写的时候都是中规中矩，比如这样：1234for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125;//打印出四次i的值 个人觉得，要想用好一个东西就要明白它的工作原理，那么for循环的工作原理是什么呢？ 二、工作原理其实对于for循环的工作原理之前也是有多次了解的，可是长时间不去回忆一个知识点，知识点就会变得模糊，这里再次记录一下它的工作流程123for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125; 1.声明一个变量i=02.判断i是否小于43.如果满足判断条件，执行console.log(i)（函数体）4.i++5.循环步骤1-4 图 三、延伸上面的写法都是中规中矩的，for循环有三个对应的参数，以；分隔，那么我可不可以省略其中某个参数呢？ 省略之前要注意，；是一定要加的1.全都省略123for(;;)&#123; console.log(1)&#125; 结果：这样写相当于无限循环了，根本停不下来 2.省略第一参数12345var i=0;for(;i&lt;2;)&#123; console.log(i)&#125;// 在外面声明了一个 i ，如果不声明这个东西，那判断条件该判断啥？所以这就相当于没有省略第一个参数，当然正常情况下我还没见到省略第一个参数的情况，一般情况第一个参数都是有的 结果：这样也会无限循环，因为i的值一直为0，所以它会无限的循环下去延伸：既然第三个参数省略了，我们可以再函数体里面定义它的累加规则啊，比如这样1234567for(var i=0;i&lt;20;)&#123; // 6的倍数 i=i+6; if(i%6===0&amp;&amp;i&lt;20)&#123; console.log(i) &#125;&#125; 好处：循环的次数大大降低，性能提升了，在这里正常情况下需要循环20次进行判断，现在的写法仅需要循环4次（第四次没有打印但是执行了函数体） 仔细观察后发现，其实这种方式就是仅仅省略了第三个参数 3.看看省略第三个参数还能干嘛问题：给定一个很大的数组，数组里面有许多证书，用JavaScript实现一个函数，要求：将数组中之和为10的每一对数配对并找出，返回这些数配对后的数组。例如：[11,3,8,9,7,-1,1,2,4…]得到：[[11,-1],[3,7],[8,2],[9,1]…] 思路：其实一般的写法是两个for循环进行潜逃的那种，这里就不展示了，这里写的是优化后的写法123456789101112131415161718192021let list = [1,2,3,-5,9,45,6];function map(list)&#123; let ret=[]; list=list.sort((a,b)=&gt;a-b); /*省略的第三个参数*/ for(let i=0,j=list.length-1;i&lt;j;)&#123; let a=list[i],b=list[j]; if(a+b===10)&#123; ret.push([a,b]); i++; j--; &#125;else if(a+b&lt;10)&#123; i++; &#125;else&#123; j--; &#125; &#125; return ret;&#125;console.log(JSON.stringify(map(list)))//结果：[[1,9]] 思路：这里影响性能的主要是太多次的for循环，数据量小还好，如果特别多怎么办？所以要减少for循环次数，先将数组从小到大排序，然后进行从两边到中间的计算，符合条件就 push一次 四、总结简简单单的一个for循环可以有不同的写法，所以说写代码简单，写出有质量的代码难","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"斐波那契数列的实现","slug":"斐波那契数列的实现","date":"2017-10-25T09:10:02.000Z","updated":"2017-10-25T10:59:23.307Z","comments":true,"path":"2017/10/25/斐波那契数列的实现/","link":"","permalink":"http://yoursite.com/2017/10/25/斐波那契数列的实现/","excerpt":"","text":"一、扫盲斐波那契数列也叫黄金分割数列，也叫兔子数列原理：假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？ 月份 兔子情况 总数 第0个月 a（小兔子） 1 第1个月 a（具备繁殖能力） 1 第2个月 b（生啦生啦）+ a（他父母） 2 第3个月 b（2月份出生的具备繁殖能力，正跃跃欲试） + b2（他父母又生二胎了） +a（他父母） 3 第4个月 c（2月份的兔子b喜当爹）+b（二月份出生的兔子） + b2（二胎具备繁殖能力，准备生娃） +a（他父母）+d(a生三胎) 5 … … … 1、1 、2、3、5、8、13、21、34、55、89……所以规律就是 fn(n)=fn(n-1)+fn(n-2) 二、代码实现1.第一种这种是最常见的实现：迭代12345678910111213/**i 月份*/function fn(i)&#123; var a=[]; /*0个月什么都不存在*/ a[0]=0; a[1]=1; for(var o=2;o&lt;=i;o++)&#123; a[o]=a[o-1]+a[o-2]; &#125; return a[i]&#125; 2.第二种递归1234567/** i 月份*/function fn(i)&#123; if(i&lt;2)&#123;return i===0?0:1;&#125; return fn(i-1)+fn(i-2)&#125; 是不是感觉很简洁 三、缺陷针对这个例子来说，这里的递归会进行太多次的调用（比迭代多），所以简洁的背后牺牲的是性能","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"css中的attr()","slug":"css中的attr","date":"2017-10-11T03:43:15.000Z","updated":"2017-10-11T05:20:29.499Z","comments":true,"path":"2017/10/11/css中的attr/","link":"","permalink":"http://yoursite.com/2017/10/11/css中的attr/","excerpt":"","text":"1.介绍attr() 用来获取一个html元素的属性值，可以用于伪元素，可以用于任何css属性 2.用法这个使用起来非常方便且简单1content:attr(属性值); attr()可以传三个值，分别是属性值、类型限制、默认值（必须符合类型限制），不过我试了半天也没调试成功，而且一般写一个参数就行，三个参数的情况基本用不到，所以就跳过了 3.例子12345678910111213141516171819&lt;hear&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 400px; height: 400px; border:1px solid #ccc; &#125; .box:after&#123; content:attr(data-foo); background-color: #ff461d; color: #fff; border-radius: .32rem; padding: .053333rem .133333rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\" data-foo=\"hello\"&gt;&lt;/div&gt;&lt;/body&gt; 此时，在div中将会出现一个红色背景的hello 4.实例那么这个东西在什么情况下能用到呢？ 购物车","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"attr()","slug":"attr","permalink":"http://yoursite.com/tags/attr/"}]},{"title":"react中的this.props.children","slug":"React.Children","date":"2017-09-28T09:34:55.000Z","updated":"2017-09-28T09:52:35.938Z","comments":true,"path":"2017/09/28/React.Children/","link":"","permalink":"http://yoursite.com/2017/09/28/React.Children/","excerpt":"","text":"一、介绍React.Children 是顶层API之一，为处理 this.props.children 提供了几个方法this.props.children 表示组件所有子节点 二、所有方法1.React.Children.map12345678//必须有返回值React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;)//没有返回值React.Children.map(this.props.children,function(child)&#123; /*这里进行处理*/&#125;) 这里的 child 表示组件的每一个子元素，也可以用箭头函数来写，这样方便this的传递 2.this.props.children这个是获取当前组件的所有子节点注意 ：1.如果没有子节点，返回 undefined2.如果一个子节点，返回 object3.如果多个子节点，返回 array但是用 React.Children.map 来遍历的话不会有问题 3.React.Children.count返回组件的所有子元素个数 4.React.Children.only12console.log(React.Children.only(this.props.children[0])); //输出对象this.props.children[0] 单独 this.props.children[0] 输出不出来 5.child.key在用 React.Children.map 的时候可能想获取传过来的属性值，例如123456789101112&lt;Tabs_li data=&#123;data&#125;&gt; &lt;div key=&#123;0&#125;&gt;1&lt;/div&gt; &lt;div key=&#123;1&#125;&gt;2&lt;/div&gt; &lt;div key=&#123;2&#125;&gt;3&lt;/div&gt;&lt;/Tabs_li&gt;/*Tabs组件*/&#123;React.Children.map(this.props.children,(child)=&gt;&#123; console.log(child.key) // 分别打印 0 ， 1 ，2 return ...&#125;)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react中跨域请求数据","slug":"react中跨域请求数据","date":"2017-09-27T06:03:37.000Z","updated":"2017-09-27T06:40:51.087Z","comments":true,"path":"2017/09/27/react中跨域请求数据/","link":"","permalink":"http://yoursite.com/2017/09/27/react中跨域请求数据/","excerpt":"","text":"一、介绍在我写 react ele 项目的时候，里面的所有数据都要从ele获取，所以我之前的想法是先用死的数据模拟，然后用 node 写几个接口请求ele数据并返回给我的react。知道今天早上，我在纳闷 react开发过程中是用 webpack 起服务器的，那跟后台就是跨域了啊，这样ajax是没有办法请求的，所以吃完一个鸡蛋后查找了一番，果然让我找到了，看下面 二、配置webpack中 proxy 是设置代理的1234567proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", secure: false, changeOrigin : true &#125;&#125;, 现在比如说我 /api/users 这么请求，现在将代理请求http://localhost:3000/api/users 注意 ：这里的 secure 参数表示能请求 https 的服务器changeOrigin 表示是否支持跨域请求，默认 false 实例好了 现在我来试验一下12345\"/base\": &#123; target: \"http://c.y.qq.com/\", secure: false, changeOrigin : true&#125; 这个是我从qq音乐找了一个借口，在react中通过 fetch 请求12var result = fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; credentials: 'include', headers: &#123; 'Accept': 'application/json, text/plain, */*' &#125; &#125;)result.then(res =&gt;&#123;return res.text();&#125;).then(text =&gt; &#123; console.log(text) &#125;) 看看返回结果 控制台输出 是不是很方便~","categories":[],"tags":[{"name":"webpack proxy","slug":"webpack-proxy","permalink":"http://yoursite.com/tags/webpack-proxy/"},{"name":"react跨域请求","slug":"react跨域请求","permalink":"http://yoursite.com/tags/react跨域请求/"}]},{"title":"认识pushstate、popstate,无刷新改变URL","slug":"认识pushstate、popstate-无刷新改变URL","date":"2017-09-22T06:39:04.000Z","updated":"2017-09-25T06:02:47.107Z","comments":true,"path":"2017/09/22/认识pushstate、popstate-无刷新改变URL/","link":"","permalink":"http://yoursite.com/2017/09/22/认识pushstate、popstate-无刷新改变URL/","excerpt":"","text":"一、回顾 window.historyhistory对象包含用户（在浏览器窗口中）访问过的url12345678910//回退history.back();//前进history.forward();//跳转history.go();//历史记录条数（当前网页的，不是浏览器的）history.length//状态history.state 二、认识新特性HTML5扩展了history,使历史记录更加灵活，可以在历史记录中存储指定记录点、替换当前历史记录点，监听历史记录点 2.1.存储历史记录点123456window.history.pushState('新添加的','','?page=3');// 第一个参数：设置state// 第二个参数：页面标题，但是所有浏览器都忽略了，传空字符串就行// 第三个删除：想要添加的链接//`注意，这个api会改变当前的网址，会添加一条历史记录，不是push到后面，这样会添加一条历史` 执行后，页面的URL为当前url？page=3 执行前 执行后 此时的history.length也会+1，新增了历史记录点 2.2.替换历史记录点123window.history.replaceState('新添加的','','?page=3');//`注意，这个api会改变当前的网址，不会添加一条历史记录，注意与上面pushState区别` 区别：1.history.length不会变2.替换了当前页的历史记录点 2.3.监听历史记录点1window.onpopstate=function()&#123;&#125; 浏览器前进后退都会触发这个事件比如可以这样：123window.onpopstate=function(event)&#123; console.log(event.state)&#125; 后退操作时，就会打印出后退到的历史记录点的state信息。 四、用途在我写react饿了么的项目时，点击首页的定位信息，会从右滑动出一个新的页面，此时再通过浏览器的前进后退按钮也可以实现页面的滑动 浏览器控制动画 具体制作过程看我的github：ele项目 五、补充在用 document.referrer 做返回按钮的时候，是只有 a标签 才能添加一条来源的。比如我通过点击页面的一个 链接 调到了对应的页面，那么此时 document.referrer 是有值的，通过 history.pushState 添加的历史记录跳转的页面,不会添加一条 document.referrer 来源","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"position的sticky属性","slug":"position的sticky属性","date":"2017-09-13T02:25:03.000Z","updated":"2017-09-13T07:35:45.556Z","comments":true,"path":"2017/09/13/position的sticky属性/","link":"","permalink":"http://yoursite.com/2017/09/13/position的sticky属性/","excerpt":"","text":"表头跟随 图中展示的效果使我们在日常开发中常见的效果。以前我都是用js判断是否滚动一定距离然后给这个元素设置position:fixed这种方式来做的，今天就来记录一下用css怎么做 一、介绍css 中的 position 属性的值常用的主要有下面几种：1.absolute2.relative3.fixed现在用到的值为 sticky：设置了sticky的元素，不脱离文档流，在屏幕范围时（viewport），该元素位置不受到定位影响（top、left等值无效），当该元素的视图将要离开偏移范围时，定位会变成 fixed 的效果，并且根据设置的top 、left值进行定位 二、用法上面的gif图里，我将搜索框的元素设置为123postion:sticky;top:0;left:0 所以当移出屏幕时就会触发fixed定位 三、兼容性刚刚把它用在实际项目中去了，结果安卓自带的浏览器不支持，所以附加上解决办法：12345678910111213141516171819202122232425262728//判断是否支持if (CSS.supports(\"position\", \"sticky\") || CSS.supports(\"position\", \"-webkit-sticky\")) &#123; // 支持 sticky,顶部吸附 this.setState(&#123; support:true &#125;)&#125;else&#123; document.addEventListener('scroll',this._scrollTop)&#125;//不支持的主要处理_scrollTop()&#123; let offsetY=this.searchDOM.offsetTop; let css=null; if(window.scrollY&gt;offsetY)&#123; css=&#123; position:'fixed', top:0, zIndex:999 &#125; &#125;else&#123; css=&#123; position:'static', &#125; &#125; this.setState(&#123; css &#125;)&#125; 四、总结 该元素不脱离文档流，仍保留元素原本在文档流中的位置 当元素在容器中被滚动超过指定偏移值时，元素在容器内固定在指定位置。比如你设置了 top:50px 那么sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动 元素固定的相对偏移是相对于它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于 viewport 来计算元素的偏移量","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"create-react-app配置webpack","slug":"create-react-app配置webpack","date":"2017-09-06T08:42:15.000Z","updated":"2017-09-07T03:46:41.507Z","comments":true,"path":"2017/09/06/create-react-app配置webpack/","link":"","permalink":"http://yoursite.com/2017/09/06/create-react-app配置webpack/","excerpt":"","text":"在学习react过程中，每次都要配置webpack，非常的麻烦，我是要写react的，不是配置这东西哒！！好在有了’create-react-app’，通过npm安装后，创建项目变得非常简单但是它里面没有做less等你实际项目需要的loader或者plugins，所以这里记录的是怎么定制create-react-app创建的项目的webpack 一、先配置less1.创建一个项目我创建的叫test test测试项目 创建完毕后，进入创建的项目，运行npm start启动此项目 启动 2.找到webpack.config.dev.js和webpack.config.prod.js运行npm run eject安装less-loader和less进入config文件夹，这里会有两个文件webpack.config.dev.js和webpack.config.prod.js应该一个是开发环境一个生产环境的配置文件，两个文件都要修改打开webpack.config.dev.js找到module rules部分，也就是配置loader的部分，找到配置css文件的test（/\\.(css)$/）修改为test:/\\.(css|less)$/,添加一个loader：{ loader: require.resolve(&#39;less-loader&#39;) },放在最下面1234567891011121314151617181920212223242526&#123; test: /\\.css$/, use: [require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () = &gt;[require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: ['&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') &#125;, ],&#125;, 3.测试现在我们做一下测试可以随便在css文件中加入less语法我在App.css中设置了整体的背景颜色：1234567@base: pink;.App-header &#123; background-color: @base; height: 150px; padding: 20px; color: white;&#125; 因为我们修改了webpack的配置项，所以需要重新启动服务器： 添加成功 可以看到，配置已经成功 二、配置px2rem1.解释px2rem是做移动端页面开发的时候，自动将px单位转换为rem，非常的方便这里要用支持webpack的对应loader，我用的是postcss-px2rem配置这个功能相对来说有些复杂 2.安装npm install postcss-px2rem postcss-loader --save执行这个命令安装 3.配置还是webpack.config.dev.js，引入1const px2rem = require('postcss-px2rem') 添加在的autoprefixer下面添加，好像loaders里只能有一个postcss，多个的话不会报错，对应的功能会不管用12345678910111213141516171819202122&#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), //这个位置 px2rem(&#123;remUnit: 75&#125;) ], &#125;,&#125;, 这里面的数值就是1rem对应的px 4.测试现在启动服务器，因为原有的都是以px为单位，所以现在页面上应该全部转换为了rem 添加成功 不要忘了配置webpack.config.prod.js这个文件，最后只需要在你的页面上对html的font-size做变换就可以了，这里略过 5.总结webpack的文档和有些npm的文档写的走点心好么，搞得本来挺简单的东西查了好久！","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"px2rem","slug":"px2rem","permalink":"http://yoursite.com/tags/px2rem/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"箭头函数的this指向","slug":"箭头函数的this指向","date":"2017-08-25T07:14:31.000Z","updated":"2017-08-25T08:21:55.255Z","comments":true,"path":"2017/08/25/箭头函数的this指向/","link":"","permalink":"http://yoursite.com/2017/08/25/箭头函数的this指向/","excerpt":"","text":"前言 es6的箭头函数非常简洁，而且还可以解决很多问题1.解决以前通过var that=this方式传值的问题1234567document.body.addEventListener('click',function()&#123; setTimeout(function()&#123; console.log(this) /*window*/ /*对body节点操作代码...*/ &#125;)&#125;) 比如点击body，过一段时间对body这个元素进行对应的js操作，如上代码，很明显是不对的，因为setTimeout里的this是全局window所以是不能通过它操作body元素， 一般这种情况以前都是通过在外层通过一个变量将this传递进来，但是有了箭头函数就不用这么做了 es6:1234567document.body.addEventListener('click',function()&#123; setTimeout(()=&gt;&#123; console.log(this) /*body(当前节点)*/ /*对body节点操作代码...*/ &#125;)&#125;) 这类的问题还有很多，但是为什么箭头函数能轻易地解决这些问题呢？所以要清楚能这么写的原因就要清楚箭头函数中this的指向 一、写箭头函数的小提示1.当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。1234/*错误*/()=&gt;&#123;&#125;/*正确*/()=&gt;(&#123;&#125;) 因为JavaScript引擎会将{x}理解成一个代码块，空对象和块在这里都是{}这样表示，所以如果返回的是一个对象，需要加一个小括号 箭头函数的this箭头函数没有自己的this!!!!!!!!!,它内部的this值集成自外围作用域123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 t1、t2、t3都输出1因为箭头函数没有自己的this所以this.id会顺着作用域链查找一直找到foo()函数 箭头函数的的特点它没有arguments变量12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 如果有了新发现，会回来补充","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"react中的context","slug":"react中的context","date":"2017-08-21T03:29:02.000Z","updated":"2017-08-21T06:01:30.976Z","comments":true,"path":"2017/08/21/react中的context/","link":"","permalink":"http://yoursite.com/2017/08/21/react中的context/","excerpt":"","text":"一、为什么用context？现在我们有一颗组件树： 组件树 假如这个组件树代表的应用是用户可以自定义主题的，每个子组件都会根据主题的不同来调整自己的样式，所以‘主题色’这个东西就应该是组件之间共享的一个状态，所以应该放到Index组件中。但是在此之前能想到的办法只能是this.props.主题色 主题色的传递 这种形式，这种形式实在是麻烦，如果组件嵌套过深，就不得不一层层传递到最底层，所以就出现了简单的办法——通过context传递context这种方法是全局都能共享的状态，我们需要的时候就去取这个状态，不需要手动传递 context共享状态 二、实践，看看代码怎么写先创建一个整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;Title /&gt; &lt;/div&gt; ) &#125;&#125;class Main extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is main&lt;/h2&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;class Title extends Component &#123; render () &#123; return ( &lt;h1&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;React.js 小书内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 修改Index组件修改Index组件，让他往自己的context中放一个themeColor：1234567891011121314151617181920212223class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: 'red' &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 代码说明1.state初始化一个themeColor状态，方便以后的修改2.getChildContext方法设置context，返回一个的对象就是context，所有子组件动能访问到，且用this.state.themeColor来设置context里面的themeColor3.注意，还需要加上一段参数的验证 childContextTypes,需要使用prop-types这个包，验证的是getChildContext返回的对象以上这些都是必须的,这里要提及一下为啥要验证context，这么多步骤多麻烦，据说context是一个危险的属性(context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料),所以按照react.js团队的想法就是，把危险的事情搞复杂一些，提高使用门栏人们就不去用了 子组件的设置class Title extends Component { static contextTypes = { themeColor: PropTypes.string } render () { return ( &lt;h1 style={{ color: this.context.themeColor }}&gt;React.js 小书标题&lt;/h1&gt; ) } } 1.利用contextTypes进行验证，必写的，不写就无法获取context的状态，2.使用的话是通过this.context.themeColor来获取值的 修改context在Index里面，我们已经初始化一个state状态了，叫：this.state.themeColor,所以使用setState就可以了 四、我的例子: 点击变色按钮前 点击变色按钮后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript时间处理小技巧","slug":"js时间","date":"2017-08-18T07:41:37.000Z","updated":"2017-08-18T08:08:32.412Z","comments":true,"path":"2017/08/18/js时间/","link":"","permalink":"http://yoursite.com/2017/08/18/js时间/","excerpt":"","text":"获取当前时间1new Date() 获取当前时间的毫秒数12345678new Date().getTime()/*返回1970年1月1日至今的毫秒数*//*下面是作用相同，写法不同*/Date.now()/*这个也返回值相同*/+new Date() +”操作符123456789/*将元素转换成number类型*/+'123'/*返回123*/+'www'/*返回NaN*//*同理*/+Date.now() toLocaleDateString() 和 toLocaleTimeString() 区别123456789new Date().toLocaleDateString()/*2017/8/18 获取的年月日*/new Date().toLocaleDateString()/*下午3:56:16 获取的时分秒*//*注意必须要用时间对象调用才行 比如 Date.now().toLocaleDateString()会报错，因为Date.now()返回的是毫秒数*/ 时间格式处理技巧如果想格式处理 当前时间与之前某个特定时间的时差 可以用这样的方式123456789/*duration为差值*/duration&gt;60 ?`$&#123;Math.round(duration/60)&#125;分钟前` : `$&#123;Math.round(Math.max(duration , 1))&#125;秒前`/*1.利用了ES6的模板字符串，结构更清晰2.利用三目运算符(三元运算符)进行判断，避免各种if3.Math.max 如果差值小于1s，则按1s计算，避免又一次的if判断*/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"gitment评论插件的配置","slug":"Hexo博客下gitment评论功能","date":"2017-08-14T09:03:00.132Z","updated":"2017-08-14T08:03:42.300Z","comments":true,"path":"2017/08/14/Hexo博客下gitment评论功能/","link":"","permalink":"http://yoursite.com/2017/08/14/Hexo博客下gitment评论功能/","excerpt":"","text":"今天我在第N次搭建博客的时候想加一个评论功能，我用的主题是indigo，在根目录_config.yml文件里经过测试发现最简洁好用的就是gitment，所以这里记录我gitment配置过程： 第一步先注册一个 oAuth Application注册成功会得到一个client id和 client secret两个参数，它们将被用于后面的用户登录 oAuth Application _config.yml 其中githubID需要https://api.github.com/users/github账户名 访问这个链接来获取 第二步如果你想要此功能的页面存在这一部分： gitment页面配置 这是一个ejs页面，里面是模板，通过使用主题的_config.yml文件配置那么你可以跳过这一步，否则需要在使用评论功能的页面添加这写代码：1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', // 可以是你的GitHub用户名，也可以是github id repo: '存储评论的 github repo', oauth: &#123; client_id: '你的 client id', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 第三步到这里已经默认你添加了上面的代码，现在注意了，我用的主题本身就带上面的代码的，只不过需要在 主题的 _comfig.yml文件中配置对应项，我在配置文件中配置好后，启动本地服务器，发现回复模块报错，控制台中发现他会请求一个链接，链接上带有刚刚配置好的参数，这里参数全部为空，我以为我配置文件有问题，折腾了好久，仍然不行，后来发现我要添加这个功能的页面里的模板并没有获取到我在_config.yml配置，最后通过修改要添加回复功能页面的模板文件才成功： 修改为 直接赋值，而不是使用模板，不知道为啥用模板获取不到值，现在已经配置成功如果配置失败，那么一定是上面的参数写错了，或者像我这种情况模板页面获取不到值，只需要直接赋值即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}