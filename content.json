{"meta":{"title":"DHYANA","subtitle":null,"description":"YMBo的博客，blog，YMBo","author":"YMBo","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-08-14T08:24:32.000Z","updated":"2017-08-14T08:25:18.204Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-13T13:51:41.000Z","updated":"2017-08-13T13:51:41.306Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack4.0中的mode和.babelrc的env.development配置项目","slug":"webpack4-0中的mode和-babelrc的env-development配置项目","date":"2018-04-12T06:29:57.000Z","updated":"2018-04-12T07:24:51.834Z","comments":true,"path":"2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","link":"","permalink":"http://yoursite.com/2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","excerpt":"","text":"一、前言之前写过怎么在webpack中使用react-hot-loader做热更新功能，不得不说是真的非常麻烦，今天发现了更好用的办法来记录一下 1.这篇文章讲的什么？1.更简单的配置 热更新的方法2.webpack4.0的mode配置项有啥用？3.babelrc中的env.development是干啥的？ 二、热更新注意，本部分着重讲解的是热更新，至于上面提到的2和3放在下个部分webpack.config.js的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const webpack=require('webpack')const opn=require('opn')const merge=require('webpack-merge')const path=require('path')const baseWebpackConfig=require('./webpack.base.config')const webpackFile=require('./webpack.file.config')const htmlWebpackPlugin=require('html-webpack-plugin')let config=merge(baseWebpackConfig,&#123; mode:'development', output:&#123; path:path.join(webpackFile.devDirectory), filename:'js[name].[hash].js', publicPath:'' &#125;, plugins:[ /*热更新*/ new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin(&#123; template:path.join(__dirname,'../template/index.html') &#125;) ], module:&#123; rules:[ &#123; test:/\\.(js|jsx)$/, use:'babel-loader', include:[ path.join(__dirname,'../client') ], exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, devServer:&#123; host:'0.0.0.0', port:'8888', hot:true, overlay:&#123; errors:true &#125;, contentBase:path.join(__dirname,webpackFile.devDirectory), historyApiFallback: true, proxy:[ &#123; context:['/api'], target:'localhost:8888', secure: false &#125; ], /*打开浏览器*/ after()&#123; opn('http://localhost:'+this.port) &#125; &#125;&#125;)module.exports=config; .babelrc 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; package.json文件的启动命令1\"dev\": \"webpack-dev-server --config build/webpack.dev.config.js\" 现在配置热替换仅需三个步骤 webpack中devServer.hot=true webpack中plugins添加new webpack.HotModuleReplacementPlugin() ‘.babelrc’文件中使用 react-hmre （npm i babel-presets-react-hmre）预设 配置完成是不是很简单？看看执行结果 hmr 三、webpack4.0的mode配置项有啥用？mode配置项会告诉webpack使用相应的内置优化 webpack运行时还会根据mode设置一个全局变量process.env.NODE_ENV,这里的process.env.NODE_ENV不是node中的环境变量,而是webpack.DefinePlugin中定义的全局变量,允许你根据不同的环境执行不同的代码. 参数： 选项 描述 development Provides process.env.NODE_ENV with value development. Enables NamedChunksPlugin and NamedModulesPlugin. production Provides process.env.NODE_ENV with value production. Enables FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin and UglifyJsPlugin. 从网上找到了更详细的优化说明列出了针对这两种情况做的对应优化development1234567891011121314151617181920//调试devtool:eval//缓存模块, 避免在未更改时重建它们。cache:true//缓存已解决的依赖项, 避免重新解析它们。module.unsafeCache:true//在 bundle 中引入「所包含模块信息」的相关注释output.pathinfo:true//在可能的情况下确定每个模块的导出,被用于其他优化或代码生成。optimization.providedExports:true//找到chunk中共享的模块,取出来生成单独的chunkoptimization.splitChunks:true//为 webpack 运行时代码创建单独的chunkoptimization.runtimeChunk:true//编译错误时不写入到输出optimization.noEmitOnErrors:true//给模块有意义的名称代替idsoptimization.namedModules:true//给模chunk有意义的名称代替idsoptimization.namedChunks:true production1234567891011121314//性能相关配置performance:&#123;hints:\"error\"....&#125;//某些chunk的子chunk已一种方式被确定和标记,这些子chunks在加载更大的块时不必加载optimization.flagIncludedChunks:true//给经常使用的ids更短的值optimization.occurrenceOrder:true//确定每个模块下被使用的导出optimization.usedExports:true//识别package.json or rules sideEffects 标志optimization.sideEffects:true//尝试查找模块图中可以安全连接到单个模块中的段。- -optimization.concatenateModules:true//使用uglify-js压缩代码optimization.minimize:true 例如: 12345if(process.env.NODE_ENV === 'development')&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 最终将编译成 12345if(true)&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 生产环境下,uglify打包代码时会自动删除不可达代码,也就是说生产环境压缩后最终的代码为:1//生产环境 do something 四、babelrc中的env.development是干啥的？env选项可以针对特定环境进行设置。此env值会从process.env.BABEL_ENV中获取；如果该值不存在，会使用process.env.NODE_ENV；二者都不存在，使用默认值”development”。 启动命令设置process.env.BABEL_ENV1\"dev\": \"cross-env BABEL_ENV=development webpack-dev-server --config build/webpack.dev.config.js\" 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; 这样就会执行”development”下配置的内容","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react生命周期详解","slug":"react生命周期详解","date":"2018-03-27T09:11:54.000Z","updated":"2018-03-27T10:31:29.588Z","comments":true,"path":"2018/03/27/react生命周期详解/","link":"","permalink":"http://yoursite.com/2018/03/27/react生命周期详解/","excerpt":"","text":"一、react生命周期 componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentUnmount每个生命周期概念不是本文讲解重点，重点是生命周期在组件渲染时候容易造成的混淆 二、componentWillReceiveProps 和 componentWillUpdate ？？componentWillReceiveProps ： 组件接收到一个新的props会被调用，在初始化render时不会调用componentWillUpdate : 组件接收到系的props或state时被调用，初始化不会被调用 看起来好像一样啊，有什么区别呢？于是百度一番，妈的写的什么tm狗屎！还是自己实际试试吧 1.来做测试先定义两个组件，App和Son，我们的目的就是看看上面提到的两个生命周期的不同，所以这一部分暂不讨论每个生命周期执行顺序，留在下一节讨论。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;App点我&lt;/button&gt; &lt;Son word=&#123;this.state.word&#125; /&gt; &lt;/div&gt; ) &#125;&#125;class Son extends Component&#123; constructor()&#123; super() this.state=&#123; word:'' &#125; &#125; componentWillMount()&#123; console.log('儿子生命周期：componentWillMount') this.setState(&#123; word:this.props.word &#125;) &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 逻辑很简单，父组件和子组件都可以通过各自的按钮改变子组件文字的内容 先点击 儿子按钮 按钮，也就是子组件Son里的按钮 执行结果 可以看到 componentWillReceiveProps 没有执行 然后点击 APP点我 按钮：点之前： 点之前 点之后： 点之后 可以看到子组件的文字并没有发生变化，执行了上图中的这些生命周期方法。 所以可以得到结论：componentWillReceiveProps触发条件是props更新，而componentWillUpdate触发条件是props或者states更新，上面说的时候也着重标记了 为了让父组件的按钮能更改子组件的内容，我需要在componentWillReceiveProps或componentWillUpdate里写上123this.setState(&#123; word:nextprops.word&#125;) 官网上说不能写在componentWillUpdate里，建议写在componentWillReceiveProps，我就不明白了，我非得写在componentWillUpdate里，看看执行结果 报错 看 死循环了，因为上面提到componentWillUpdate触发条件是 states 变化 和 props变化，写在了这里就不停的setState states的值，所以就不停的触发componentWillUpdate，因此像这种父组件更改子组件的内容应该写在 componentWillReceiveProps 里，来试试： ojbk 好，一切正常！ 总结： 名称 componentWillReceiveProps componentWillUpdate 触发条件 props变化 props或states变化 注意事项 setState的更新要写在componentWillReceiveProps里 三、生命周期执行顺序还是上面的例子 1.初始化时父子组件的声明周期执行顺序 结果 2.点击父组件的按钮时生命周期执行顺序 结果 3.点击子组件执行顺序 结果 4.还有一种情况，点击子组件触发父组件内容的更改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Son extends Component&#123; ponentWillMount()&#123; console.log('儿子生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; var word=this.props.word === '儿子' ? '孙子':'儿子' this.props.click(word) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:word &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;Son word=&#123;this.state.word&#125; click=&#123;this.handleClick.bind(this)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 结果 上述的几种执行结果也很简单，看一看就会执行顺序就会变得清晰了","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"body-parser使用注意","slug":"body-parser使用注意","date":"2018-03-08T07:53:13.000Z","updated":"2018-03-08T09:07:44.091Z","comments":true,"path":"2018/03/08/body-parser使用注意/","link":"","permalink":"http://yoursite.com/2018/03/08/body-parser使用注意/","excerpt":"","text":"一、前言这几天在学习服务端渲染的时候用到了这个包 body-parser ,很方便的一个包，这个模块提供了四种解析器 JSON body parser Raw body parser Text body parser URL-encoded form body parser 每一项详细的配置都能在网上找到，这篇记下的是我在使用中遇到的问题 bodyParser.json(option)和bodyParser.urlencoded(option)的不同，在网上搜这个问题，得到的答案还是让我一头雾水，终于试了几次并结合资料弄清楚两者的使用场景 二、区别看官方的解释：bodyParser.json(options)：中间件只会解析 json ，允许请求任意Unicode编码,支持 gzip 和 deflate 编码。 bodyParser.urlencoded(option)：中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。(tip:一般这一项是接收表单提交form) 三、例子看到这里我明白了一个接受form请求，一个接受json请求，好，我写了下面的例子：12345678910111213141516171819202122232425262728293031323334//server端关键代码var jsonParser =bodyParser.json();app.post('/login',jsonParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;)//客户端请求&lt;form method=\"post\" action=\"/login\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputTitle\" class=\"col-sm-3 control-label\"&gt;电影名称&lt;/label&gt; &lt;input id=\"inputTitle\" type=\"text\" name=\"title\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputLanguage\" class=\"col-sm-3 control-label\"&gt;海报&lt;/label&gt; &lt;input id=\"inputLanguage\" type=\"text\" name=\"poster\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt;&lt;button type=\"submit\" class=\"btn btn-default\"&gt;确定&lt;/button&gt;&lt;/form&gt;setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 客户端有一个用于测试的表单和一个1s后发送post请求的ajax 先看一下表单请求的结果： 表单请求 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到bodyParser.json()并没有解析到ajax和form表单请求，现在来换bodyParser.urlencoded(option)的解析方式12345var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);app.post('/login',urlencodedParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;) 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到这种解析方式成功将请求解析到了body里。到了这里，我又有疑问了，知道了bodyParser.urlencoded期望的数据形式，那bodyParser.json适用于什么情况呢？ 看下面例子，既然api说bodyParser.json适用于json的数据类型，所以我将ajax的content-Type设置为json 123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 请求结果： 返回结果 请求失败，那么疑问来了，我设置了json格式的请求，为什么bodyParser.json解析不了 关键： jq的ajax 默认的ContentType的值为:application/x-www-form-urlencoded; charset=UTF-8此格式为表单提交格式，数据为 key1=value1&amp;key2=value2的格式 虽然ajax的data属性值格式为:{key1:value1,key2:value2},但最后会转为key1=value1&amp;key2=value2的格式提交到后台 如果想传json格式数据，content-type设置好后，ajax必须将date属性值转为json字符串，不能为json对象（js对象，会自动转为key=value形式）,这样传输的时候才是json格式 我们来试一下：123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:JSON.stringify(&#123; url:'login', name:'123', password:123456 &#125;), success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 返回结果 现在就可以请求成功啦","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"mobx基本用法","slug":"mobx基本用法","date":"2018-03-06T01:59:46.000Z","updated":"2018-03-15T02:35:51.577Z","comments":true,"path":"2018/03/06/mobx基本用法/","link":"","permalink":"http://yoursite.com/2018/03/06/mobx基本用法/","excerpt":"","text":"一、前言本文是我初学mobx时对mobx一些基本的认识，如果新发现会继续更新 二、redux和mobx相同点：都是用来管理JavaScript应用的状态，他们不一定要跟react结合使用，还可以与别的框架结合 不同点： redux学习成本相对于mobx成本要高很多，有reducer、action、dispatch等概念，规则多，比如更新数据必须要用 dispatch，更新的逻辑必须要用 action，刚学的时候可能有点懵。mobx比较自由，可以用obj.key 的方式更新 redux更新数据的时候，要将更新数据的整个对象替换为一个新的对象才可以触发更新(这点接触过redux的会有感受)，而mobx自始至终是一份引用，所以redux每次会触发很多的组件的重新渲染，为了优化会配合immutable。mobx则是更新哪个属性，仅仅这个属性所在的位置会重新渲染（不是组件的重新渲染，不触发componentWillMount等方法，会触发componentWillUpdata） 以上为自己理解，如有错误烦请指出 三、mobx基本概念 tip:以下提到的 @ 是ES7里的修饰器，可以到网上找资源学习 es7的修饰器 1. @observable 将属性转为可观察的，一旦发生变化，则变量所处的位置会立即发生变化 2. @computed这是一个有点不好理解的API，而且官网描述的也不是很清楚，下面是我的理解，如果有误，请指出讲这个API之前先看一下下面的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************mobx********************************/import &#123; observable ,computed,autorun,action &#125; from 'mobx'class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125;&#125;const appState = new AppState;setInterval(()=&gt;&#123; appState.add()&#125;,2000)export default appState;/************************************index.jsx********************************/import React,&#123; Component &#125; from 'react'import &#123;observer,inject&#125; from 'mobx-react'import PropTypes from 'prop-types'@inject('appState')@observerexport default class TopicList extends Component&#123; constructor()&#123; super() this.changeName=this.changeName.bind(this) &#125; componentWillUpdate()&#123; console.log('更新！') &#125; changeName(event)&#123; this.props.appState.changeName(event.target.value) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.changeName&#125;/&gt; &lt;span&gt;&#123;this.props.appState.msg&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;TopicList.propTypes=&#123; appState:PropTypes.object&#125; 逻辑是有两个变量 count和max，在msg的getter里判断max&gt;count的情况,其中max为固定值，count每秒+1。 在第二节的redux和mobx异同之处提出了mobx数据变化的时候组件只会触发 componentWillUpdata （没什么来源，自己试的），下面来看看上面代码 (mobx里msg部分加了 @computed) 运行情况： 可以看到只有当 msg 值发生变化的时候，才会触发 componentWillUpdata ，也就是前5s msg的结果一直为 true时，组件里是没有接收到新的 {this.props.appState.msg} 的（因为接受新的props值会触发 componentWillUpdata） 下面再来看看 mobx里msg部分不加 @computed 运行情况1234get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;`&#125; 不加 @computed 可以看到每一次的count值变化都会触发组件的componentWillUpdata 看明白了上面的例子和运行时的不同，再看看下面的总结就会好理解了 总结：如果使用了@computed （@computed msg getter()），那么msg的值将会被缓存，如果count的变化没有触发msg值的变话，那么msg的getter()值就不会改变，index.jsx组件也不会收到通知(componentWillUpdata)。（第一种情况） 如果不使用@computed属性，直接msg getter()的话，那么一旦count改变，所有用到msg getter()的地方都将重新计算(第二种情况)。 @computed的意义在于它能够由MobX进行更智能的优化 3. autorun 定义的 @observable 变量如果发生变化，autorun会自动执行相应的方法,例如将上面的mobx修改，index.jsx不变 1234567891011121314151617181920212223242526 import &#123; observable ,computed,autorun,action &#125; from 'mobx' class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125; &#125; const appState = new AppState;// 添加了 autorun autorun(()=&gt;&#123; console.log(`$&#123;appState.count&#125; 运行运行~`) &#125;) setInterval(()=&gt;&#123; appState.add() &#125;,1000) export default appState; 因为autorun里的函数依赖了 count ，所以每一次setInterval的时候，都会执行autorun里的函数 4. @action 如果要更新store里的内容，就要在相应的函数前加上 @action 例如上面的例子，标记为@action 。 作用：在mobx-react高级渲染性能优化小节中，我们知道，使用transaction可以将多个应用状态(Observable)的更新视为一次操作，并只触发一次监听者(Reactions)的动作(UI更新、网络请求等)，从而更大程度地提升应用的性能，避免多余的UI渲染和网络请求。action中封装了transaction，对函数使用action修饰符后，无论函数中对@observable变量（应用状态）有多少次修改，都只会在函数执行完成后，触发一次对应的监听者。如下代码，reset函数只会触发一次UI更新。 123456789101112class TodoItemModel &#123; id; @observable title; @observable completed; //使用action后，reset函数执行完成后，才会触发一次其监听者 @action reset() &#123; this.completed = false; this.title= ''; &#125;&#125; 5. @oberver observer 函数/装饰器可以用来将 React 组件转变成响应式组件 oberver是用来连接mobx与组件的一个API（告诉mobx本组件依赖于mobx的状态），由一个单独的包 mobx-react 提供，例子看上面的 index.jsx组件。使用了 observer 的react组件中用到的变量发生变化，组件才会更新 四、运行环境的配置@(修饰器)是ES7的一个提案，Babel 转码器已经支持 Decorator需要安装 babel-preset-stage-1 （stage-0也可以）和babel-plugin-transform-decorators，babel-plugin-transform-decorators一定要放在别的plugins前 .babelrc配置 6. useStaticRendering我们知道可以通过使用@observer，将react组件转换成一个监听者(Reactions)，这样在被监听的应用状态变量(Observable)有更新时，react组件就会重新渲染。而对于服务端的React组件，我们只需要它被渲染一次，而不需要组件监听模型的状态。事实上，如果服务端React组件像客户端组件一样监听模型的状态变化，就会造成严重的内存泄漏问题。官方提供了useStaticRendering方法，用于避免mobx服务端渲染的内存泄漏问题; 该方法只需要在server启动时设置一次。 useStaticRendering(true);","categories":[],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://yoursite.com/tags/mobx/"}]},{"title":"javascript的数据属性和访问器属性","slug":"javascript的数据属性和访问器属性","date":"2018-02-28T03:25:55.000Z","updated":"2018-03-22T08:40:26.828Z","comments":true,"path":"2018/02/28/javascript的数据属性和访问器属性/","link":"","permalink":"http://yoursite.com/2018/02/28/javascript的数据属性和访问器属性/","excerpt":"","text":"一、数据属性1.基本认识1.1概念数据属性包含一个数据值的位置，在这个位置可以读取和写入值 数据属性有4个描述其行为的特性 [[Configurable]] : 表示能否通过 delte 删除属性从而重新定义属性，能肉修改属性的特性，或者能把属性修改为访问器属性。默认true [[Enumerable]] : 表示能否通过 for-in 循环返回属性。 默认 true [[Writable]] : 表示能否修改属性的值 。 默认 true [[Value]] : 包含这个属性的数据值。 默认 undefined tip：为了表示特性是内部值，该规范把他们放在了两对括号中 2.对数据属性的操作必须使用 ECMAScript 5 的 Object.defineProperty() 方法三个参数 属性所在的对象 属性的名字 描述符对象 栗子12345678910111213var person = &#123; name:'y'&#125;//禁止修改属性值Object.defineProperty(person,\"name\",&#123; writable:false&#125;)console.log(person.name) // y//尝试修改属性person.name='b';console.log(person.name) //y//可以看到禁止修改属性的值后，修改属性值无效 2.1注意！！！这四个数据属性中，configurable 是比较特殊的，一旦把属性定义为不可配置的，就不能再把它变回可配置了，此时再调用 Object.defineProperty 方法修改 除writable之外的特性 都会导致失败。1234567891011121314151617181920212223242526272829303132333435var b=&#123; age:0&#125;//定义为不可配置Object.defineProperty(b,'age',&#123; configurable:false&#125;)//尝试删除配置delete b.ageconsole.log(b.age)// 成功打印0//尝试修改enumerableObject.defineProperty(b,\"age\",&#123; enumerable:false&#125;)/* 报错：Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:3:8 *///尝试修改writableObject.defineProperty(b,\"age\",&#123; writable:false&#125;)/*修改成功，不会报错*///尝试修改valueObject.defineProperty(b,\"age\",&#123; value:1&#125;)/*报错：VM17512:1 Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:8*/ tip:上面的操作只针对于 b对象的age 属性，所以此时我再添加一个属性也是成功的，比如123b.name='m';console.log(b)// 输出 &#123;age: 0, name: \"m\"&#125; tip2:ES5有三个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 二、访问器属性1.基本认识概念访问器属性不包含数据值。它包含一对getter和setter函数。当读取访问器属性时，会调用getter函数并返回有效值；当写入访问器属性时，会调用setter函数并传入新值，setter函数负责处理数据。 访问器属性的四个特性 [[Configurable]]：默认为true。表示能否通过delete删除属性从而重新定义属性，能否修改属性特性，或者能否把属性修改为访问器属性； [[Enumerable]]：默认为true。表示能否通过for-in循环返回属性； [[Get]]：读取属性时调用的函数，默认为undefined； [[Set]]：写入属性时调用的函数，默认为undefined； 2.对访问器属性的操作 tip :1.当使用了getter或setter方法，不允许使用 writable 和 value 这两个属性。2.get和set 函数不是必须的3.先看这种写法： 特别要注意这种写法，容易写错！ 可以看到 堆栈溢出 了，` 原因是因为如果在get里return this.year ，这样如果我们在外面 book .year时，就会运行get函数，而get函数里面执行到this.year时又会运行get函数，造成死循环。正常写法是利用一个中间值来设置某一个属性，看下面代码 正确写法 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。一般上面上面代码目的是 设置一个属性的值会导致其他属性发生变化，就不用把属性单拿出来计算了，很方便 三、总结1.到底怎么判断是数据属性还是访问器属性可以通过 Object.getOwnPropertyName()方法获取到所有实例中的属性，包括不可枚举的属性。然后，使用Object.getOwnPropertyDescriptor(）方法获取到每一个属性的描述符，如果描述符中有get/set方法，说明它是访问器方法，否则它就是数据属性。其实由于两种属性各自的4种特征都是都不一样的，如果一个对象的属性描述符里含有一个单独的特征就可以判断是什么类型的属性，比如1234var book=&#123;&#125;;Object.defineProperty(book,'age',&#123; value:5&#125;) 描述符里我单独定义了value属性，而value属性仅仅输入数据属性，所以可以判断出 age属于数据属性 2.定义多个属性Object.defineProperty()这种写法每次只能定义一个属性，那么可以通过 Object.defineProperties 来定义多个属性定义多个属性：请注意下面图片内代码是有问题的，这是《js高级程序设计》 里的例子 定义多个属性 这个方法定义多个属性没问题，但是也可以从上面的图看出来，定义的访问器属性year的set方法里面并没有生效，这俩属于数据属性，原因是因为 定义的_year属性和edition属性不能往里面写值了。 自己解决历程：我自己猜想原因可能是这样，因为_year和edition写不进去值了，所以设置 enumerable 为true。我尝试修改了一下，如下 给两个数据属性添加了writable(可读写 )特征 这样运行成功。为了验证猜想，做了如下例子： 所有特性 ； 可以看到只要是用 Object.defineProperties() 定义的对象的属性，那么定义过的每个属性描述符的4个默认属性（除了set和get外）都默认都是 false 总结：使用 Object.defineProperties() 方法来定义多个属性的时候，每个属性的描述符里的属性都是默认的false(除了set和get外)，set或者get没定义的话默认 undefined 四、实际应用介绍了这个东西后，在实际中我该在什么情况用呢？ 数据双向绑定 （Module&lt;==&gt;View）数据双向绑定就是通过 Object.defineProperty 实现的，我们来手写一个数据绑定 &lt;input class=\"inputText\" type=\"text\" /&gt; &lt;p class=\"text\"&gt;&lt;/p&gt; var inputText=document.querySelector('.inputText'); var text=document.querySelector('.text'); //module var obj={_txt:null}; Object.defineProperty(obj,'txt',{ get:function(){ return this._txt; }, set:function(value){ this._txt=value; text.innerHTML=value; inputText.value=value } }) //view inputText.addEventListener('input',function(e){ const text=e.target.value; obj.txt=text; },false) 此时在input输入值的时候p的内容和obj.txt内容会变，在浏览器console中更改obj.txt的值，input和p也会变","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"受控组件和非受控组件","slug":"受控组件和非受控组件","date":"2018-02-07T02:48:32.000Z","updated":"2018-02-08T01:31:14.634Z","comments":true,"path":"2018/02/07/受控组件和非受控组件/","link":"","permalink":"http://yoursite.com/2018/02/07/受控组件和非受控组件/","excerpt":"","text":"一、前言在HTML中，表单元素例如 input , textarea , select 通常是根据用户的输入来维护它们自己的状态。在React中，可变状态通常保存在 state 中，只能用 setState() 来进行更新操作 二、定义解释正如上面所说，表单元素的数据可以由自身DOM元素来管理，也可以由React组件来管理 1.controlled_Component ( 受控组件 )将表单状态保存在React组件中（state），呈现表单的React组件也会控制用户输入后所发生的情况。表单元素数据托管到React组件中的这种方式叫做 受控组件 React能控制 2.uncontrolled_Component ( 非受控组件 )与受控组件相反，表单数据由dom元素自身管理的组件叫 非受控组件 React不能控制 三、栗子1.controlled_Component ( 受控组件 )12345678910111213141516171819202122232425262728class App extends Component &#123; constructor()&#123; super() this.state=&#123; name:'姓名', text:'请输入' &#125; &#125; handleName(e)&#123; this.setState(&#123; name:e.target.value &#125;) &#125; handleText(e)&#123; this.setState(&#123; text:e.target.value &#125;) &#125; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' value=&#123;this.state.name&#125; onChange=&#123;this.handleName.bind(this)&#125;/&gt; &lt;textarea name=\"text\" value=&#123;this.state.text&#125; onChange=&#123;this.handleText.bind(this)&#125;&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都交给了React组件来管理。 注意 :这种情况下每个表单元素必须要有 onChange 事件，这样用户每次操作对应的元素，对应元素数据才能得到改变 2.uncontrolled_Component ( 非受控组件 )123456789101112/*uncontrolled Component*/class App extends Component &#123; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' defaultValue='姓名'/&gt; &lt;textarea name=\"text\" defaultValue='想法'&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都是由自身DOM元素来管理的。 注意 :非受控组件这功中，通常你需要指定表单元素的初始值，但不控制后续的更新，这种情况需要指定 defaultValue 属性，而不是 value属性如果你不想让他有初始值，也可以不用写 defaultValue 三、两者优缺点？ name 优点 缺点 非受控组件 简练、操作数据的方式更简洁 表单验证 、选择性开启或者关闭按钮 等功能不能处理 受控组件 相比之下略显繁琐 表单验证 、选择性开启或者关闭按钮 等功能能轻松处理 所以通常情况下受控组件更能满足我们需求","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"sublime中使用EditorConfig","slug":"sublime中使用editconfig","date":"2018-01-19T02:22:50.000Z","updated":"2018-01-19T07:31:00.075Z","comments":true,"path":"2018/01/19/sublime中使用editconfig/","link":"","permalink":"http://yoursite.com/2018/01/19/sublime中使用editconfig/","excerpt":"","text":"一、作用EditorConfig是统一代码格式的解决方案，它可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格，比如多人合作的时候统一代码风格，避免一些潜在的问题，增加代码可读性 二、使用方法1.编辑器插件有些编辑器已经集成了这个插件，所以不用再安装，而有些编辑器没有集成这个插件，需要安装 下面这些编辑器不需要安装： 已经集成的编辑器 这些编辑器需要安装： 需要单独安装插件的编辑器 sublime里直接搜索 EditorConfig 安装即可 安装 2.配置文件说明在需要的地方配置 .editorconfig文件 注意1： 当打开一个文件时，EditorConfig插件会在打开文件的目录和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=true。什么意思呢？比如我的文件结构是这样的： 文件目录 在 b.js 里的代码，会先从同级目录 ——&gt; 父级目录 这个路径进行查找（冒泡 ），如果遇到了 .editorconfig 里 root=true 则停止，因为 b.js 同级目录的 .editorconfig 里 root=true 所以 b.js 用的就是b.js上面这个文件配置的规则 注意2：EditorConfig配置文件从上往下读取，并且路径最近的文件最后被读取。匹配的配置属性按照属性应用在代码上，所以最接近代码文件的属性优先级最高。什么意思呢？ .editconfig 意思就是 我的 js文件会读取 注释2 (第十行)下面的配置，而python文件会读取上面 (注释1)的配置 3.文件格式详情EditorConfig文件使用INI格式，斜杠(/)作为路径分隔符，#或者;作为注释。注释应该单独占一行。 4.支持的属性注意：不是每种插件都支持所有的属性，具体可见Wiki。 indent_style：tab为hard-tabs，space为soft-tabs。indent_size：设置整数表示规定每级缩进的列数和soft-tabs的宽度（译注：空格数）。如果设定为tab，则会使用tab_width的值（如果已指定）。tab_width：设置整数用于指定替代tab的列数。默认值就是indent_size的值，一般无需指定。end_of_line：定义换行符，支持lf、cr和crlf。charset：编码格式，支持latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用uft-8-bom。trim_trailing_whitespace：设为true表示会除去换行行首的任意空白字符，false反之。insert_final_newline：设为true表明使文件以一个空白行结尾，false反之。root：表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件。 三、我遇到的问题看我的配置文件： .editconfig 我设置了缩进方式为 tab,每级缩进 8 列，但是我设置好后，打开a.js文件后每级的缩进并没有变化，为此我还找了好久~╮(╯▽╰)╭，最后我发现，只要把a.js关闭，再打开就生效了~ 四、总结EditorConfig 可以说很好用了，很适合多人合作情景，但这个只是编辑器级别的格式统一，我会在后面说到代码级别的检测—ESLint，它可以通过我们配置很详细的配置文件，来规范我们的代码风格。","categories":[],"tags":[{"name":"EditorConfig","slug":"EditorConfig","permalink":"http://yoursite.com/tags/EditorConfig/"}]},{"title":"http-proxy-middleware配合gulp使用时的一些坑","slug":"http-proxy-middleware配合gulp使用时的一些坑","date":"2018-01-09T01:23:58.000Z","updated":"2018-01-09T02:57:47.406Z","comments":true,"path":"2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","link":"","permalink":"http://yoursite.com/2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","excerpt":"","text":"一、介绍在我们用gulp、webpack等方式开发项目的时候，由于会启动个本地服务器，所以如果访问后台提供的接口就是跨域了，这种情况该怎么办呢？这就涉及到了 代理服务 的配置，react项目的webpack的代理服务配置我之前已经写过了，传送门~~。因为使用 http-proxy-middleware 也遇到了多多少少的问题，网上关于遇到的问题解决办法很少或是没有提及（难道问题太弱智？），所以写下这篇文章记录一下（干货满满呦），如果错误烦请指出~~~ 二、环境先说明我的环境：gulp + 静态html 。gulp主要是处理 less 文件和启动服务器方便程序调试 三、目的本地的服务器为：lcoalhost:8080，想要请求的地址为：https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0 （请求地址是我从QQ音乐找的，正因为这样我又遇到了另外一个 ajax的坑，最后一节有说明，所以这个地址也具有一定的教学意义） 四、配置1.gulpfile.js1234567891011121314151617181920212223var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware'), path = require('path'),gulp.task('connect', function() &#123; connect.server(&#123; /*根路径*/ root: './dist', /*开启浏览器自动刷新*/ livereload: true, /*端口号*/ port: 8080, /*使用代理服务*/ middleware: function(connect, opt) &#123; return [ proxy('/api/', &#123; target: 'https://c.y.qq.com/', changeOrigin:true, &#125;) ] &#125; &#125;);&#125;); 说明 proxy配置项： 其中return 返回是一个数组，所以通过配置多个proxy返回值可以实现多重代理 changeOrigin 这个意思是，如果我们代理的目标地址是一个虚拟托管站点，比如 http://www.baidu.com 这种域名的形式的target项，则需要配置此项。如果target项为ip值，比如http://10.10.16.5/ 则不用配置此项 2.index.html12345678910$.ajax(&#123; type: 'GET', url: \"/api/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 3.结果可以看到，请求失败 /(ㄒoㄒ)/~~ 4.解决办法就是在这个问题上我卡了一下午，为了能游刃有余的使用这个东西，有些基本的参数还是要非常明白的123pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;, 很多的技术文章的配置都有写这个东西，但是很少有介绍这个参数的意思。 下面我们来看看不配置此项真正请求的地址： 不配置这个参数请求代理的地址：https://c.y.qq.com/ api /soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0看我标记粉色的地方，再回过头对比我们要请求的地址，是不是多个了 /api/ ? 所以 pathRewrite 这个配置项的意思是，当有 /api/ 字段请求的时候，指定 重写 /api/ 这个字符串，这里为空。 比如：目标地址：http://www.baidu.com/aaa/bbb proxy配置：12345proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, &#125;) 本地服务器：http://localhost:8888 ajax：12345678910$.ajax(&#123; type: 'GET', url: \"/api/aaa/bbb\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 但是实际上请求的是 http://www.baidu.com/api/aaa/bbb 这个地址 ！！！！！。 所以第一种解决办法是配置重写路径1234567proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;,&#125;) 第二种解决办法就是利用已有路径 1234proxy('/aaa/', &#123; target: 'http://www.baidu.com/', changeOrigin:true,&#125;) 关于 http-proxy-middleware 我遇到的问题，已经说完了。下面来说 ajax的一个坑 五、ajax用jq的 ajax请求一个地址，如果返回的数据格式与ajax里预期格式的配置不一样，那么就会在 error 函数里面返回后台提供的数据 ，具体例子就不写了，很简单，可以试一试","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"webpack热更新(HMR)","slug":"webpack热更新-HMR","date":"2018-01-02T07:40:44.000Z","updated":"2018-04-12T07:37:13.150Z","comments":true,"path":"2018/01/02/webpack热更新-HMR/","link":"","permalink":"http://yoursite.com/2018/01/02/webpack热更新-HMR/","excerpt":"","text":"一、HMR介绍在我们开发react应用的时候，在配置了webpack-dev-server的前提下每一次的组件内容修改都需要手动的刷新浏览器，为了解决这个问题，所以有了热更新这个概念，网上的文章弄得我一头雾水，在我配置成功后，自己来记录一下热更新的配置 时隔三个月今天发现了配置更简单的热替换的方法，点我查看 二、配置1.从零开始–项目初始化首先创建一个基本的react的项目，然后命令行运行 npm init 生成 package.json 文件。 新建 build,client 文件夹，分别用来存放 webpack 配置（webpack.config.js文件）和 react 组件。当前目录结构： 目录结构 2.基本的webpack配置为了自动产出html文件，安装 html-webpack-plugin 为了解析 react 组件和对es6的解析，安装 babel-loader babel-core babel-preset-es2015 babel-preset-es2015-loose babel-preset-react 模块，并在根目录新建文件 .babelrc 文件 babel 的配置文件 .babelrc 此时 package.json 文件的包 package.json 添加 webpack-devserver 配置，此时 webpack-config.js 配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');module.exports=&#123; entry: &#123; app:path.join(__dirname,'../client/app.js') &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin() ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; 此时启动webpack-dev-server后，运行成功 package.json 友情提示：： 如果在执行命令的过程中报错 ‘cannot find …’ 这类的错误，首先检查是否少装了包，如果没有少装，则删除 node_module文件夹，重新安装下。 如果运行 webpack-dev-server 启动服务器的时候，网页的 js 文件显示404，首先检查是否本地已经有了一个编译好的 dist 文件夹，因为webpack-dev-server会优先读取本地文件，配置的时候我们添加了 /pubilc/ 所以是读取不道德，这时，删除本地 dist文件夹即可。（这个相当相当的坑） 在入口文件中，我这样写 document.body 是不可取的，正确的做法是 获取Id的形式。 知识点！( 敲黑板 )：path.join 和 path.resolve 区别 path.join：拼接地址（会正确使用当前系统的路径分隔符，Unix系统是/，Windows系统是\\）比如：path.join（‘m’,’/b’） 或者 path.join（‘m’,’b’） 返回m/b这个路径path.resolve：将参数转换为绝对路径比如 path.resolve(‘m’) ;如果当前命令窗口是在c盘打开的，那么返回C:\\m(总是返回一个绝对路径)对比：两种方法都可以获得当前目录的绝对路径（通过__dirname），因为path.join可以适应unix和windows，所以join可能好一些 三、重头戏-配置HMR这里说是简单，但我觉得对于初次使用还是比较繁琐，整理一下，分为下面几个步骤(与顺序无关) 安装 react-hot-loader 配置 babelrc 文件 配置 入口文件app.js 配置 webpack.config.js 2.配置 .babelrc 文件 .babelrc 3. 配置 入口文件app.js 4. 配置 webpack.config.js改动部分标记为 //add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');const webpack=require('webpack'); //addmodule.exports=&#123; entry: &#123; app:[ 'react-hot-loader/patch', //add path.join(__dirname,'../client/app.js') ] &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(), new webpack.HotModuleReplacementPlugin() //add ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*热加载*/ //add hot:true, //add /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; react-hot-loader参考 好了，该做的做完了，打开浏览器测试，发现更改App.jsx文件后浏览器竟然特么没有变化,这就很气人，我也按照你官网上写的做了，现在出不来？好吧，看下面的解决办法 四、解决上面的问题app.js这个入口文件中，更改为： 更改为 如果有了更改，那么 重新用 require 的方式获取一下这个组件，然后进行渲染 成功啦！ 是不是有了疑问，为啥用 require 的方式引入呢？因为这种形式的文件引入import的方式引入不了 五、总结本来一个挺好的功能，分别写在了 webpack官网和 react-hot-loader 官网，这还不算啥，最后还运行不了，多坑，好了就记录到这里了,如果有问题或者补充欢迎回复","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"HMR","slug":"HMR","permalink":"http://yoursite.com/tags/HMR/"}]},{"title":"react服务端渲染","slug":"react服务端渲染","date":"2017-12-26T09:02:19.000Z","updated":"2017-12-26T09:03:16.002Z","comments":true,"path":"2017/12/26/react服务端渲染/","link":"","permalink":"http://yoursite.com/2017/12/26/react服务端渲染/","excerpt":"","text":"看了react服务端渲染，有点蒙圈，先挖坑准备","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"select禁止更改值","slug":"select禁止更改值","date":"2017-11-30T02:31:59.000Z","updated":"2017-11-30T02:44:25.605Z","comments":true,"path":"2017/11/30/select禁止更改值/","link":"","permalink":"http://yoursite.com/2017/11/30/select禁止更改值/","excerpt":"","text":"一、效果介绍select框选中了一个值后禁止更改select 二、方法1.css利用disabled=&quot;true&quot;来禁止选中缺点：这种方法虽然简单，但是它禁止了select框获得焦点，不能看到select的内容优点：简单 2.js123456&lt;select name=\"selectname\" id=\"selectid\" onfocus=\"this.defaultIndex=this.selectedIndex;\" onchange=\"this.selectedIndex=this.defaultIndex;\"&gt; &lt;option value=\"1\"&gt;dd&lt;/option&gt; &lt;option value=\"2\"&gt;mm&lt;/option&gt; &lt;option value=\"3\" selected=\"selected\"&gt;cc&lt;/option&gt; &lt;option value=\"4\"&gt;ff&lt;/option&gt;&lt;/select&gt; 1.获取焦点时，将当前的值 selectedIndex 赋值给一个自定义的属性 defaultIndex2.change时，将当前的值设置为 defaultIndex 优点：select框依然可以选择，被下拉","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"滑动窗口算法解决指定字符串最长子串长度问题","slug":"滑动窗口算法解决指定字符串最长子串长度问题","date":"2017-11-16T07:52:51.000Z","updated":"2017-11-16T07:52:51.498Z","comments":true,"path":"2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","link":"","permalink":"http://yoursite.com/2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"for循环的灵活运用","slug":"for循环的灵活运用","date":"2017-11-13T08:11:30.000Z","updated":"2017-11-13T09:29:14.245Z","comments":true,"path":"2017/11/13/for循环的灵活运用/","link":"","permalink":"http://yoursite.com/2017/11/13/for循环的灵活运用/","excerpt":"","text":"一、介绍for循环是平时在写代码过程中最常用的代码了，一般写的时候都是中规中矩，比如这样：1234for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125;//打印出四次i的值 个人觉得，要想用好一个东西就要明白它的工作原理，那么for循环的工作原理是什么呢？ 二、工作原理其实对于for循环的工作原理之前也是有多次了解的，可是长时间不去回忆一个知识点，知识点就会变得模糊，这里再次记录一下它的工作流程123for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125; 1.声明一个变量i=02.判断i是否小于43.如果满足判断条件，执行console.log(i)（函数体）4.i++5.循环步骤1-4 图 三、延伸上面的写法都是中规中矩的，for循环有三个对应的参数，以；分隔，那么我可不可以省略其中某个参数呢？ 省略之前要注意，；是一定要加的1.全都省略123for(;;)&#123; console.log(1)&#125; 结果：这样写相当于无限循环了，根本停不下来 2.省略第一参数12345var i=0;for(;i&lt;2;)&#123; console.log(i)&#125;// 在外面声明了一个 i ，如果不声明这个东西，那判断条件该判断啥？所以这就相当于没有省略第一个参数，当然正常情况下我还没见到省略第一个参数的情况，一般情况第一个参数都是有的 结果：这样也会无限循环，因为i的值一直为0，所以它会无限的循环下去延伸：既然第三个参数省略了，我们可以再函数体里面定义它的累加规则啊，比如这样1234567for(var i=0;i&lt;20;)&#123; // 6的倍数 i=i+6; if(i%6===0&amp;&amp;i&lt;20)&#123; console.log(i) &#125;&#125; 好处：循环的次数大大降低，性能提升了，在这里正常情况下需要循环20次进行判断，现在的写法仅需要循环4次（第四次没有打印但是执行了函数体） 仔细观察后发现，其实这种方式就是仅仅省略了第三个参数 3.看看省略第三个参数还能干嘛问题：给定一个很大的数组，数组里面有许多证书，用JavaScript实现一个函数，要求：将数组中之和为10的每一对数配对并找出，返回这些数配对后的数组。例如：[11,3,8,9,7,-1,1,2,4…]得到：[[11,-1],[3,7],[8,2],[9,1]…] 思路：其实一般的写法是两个for循环进行潜逃的那种，这里就不展示了，这里写的是优化后的写法123456789101112131415161718192021let list = [1,2,3,-5,9,45,6];function map(list)&#123; let ret=[]; list=list.sort((a,b)=&gt;a-b); /*省略的第三个参数*/ for(let i=0,j=list.length-1;i&lt;j;)&#123; let a=list[i],b=list[j]; if(a+b===10)&#123; ret.push([a,b]); i++; j--; &#125;else if(a+b&lt;10)&#123; i++; &#125;else&#123; j--; &#125; &#125; return ret;&#125;console.log(JSON.stringify(map(list)))//结果：[[1,9]] 思路：这里影响性能的主要是太多次的for循环，数据量小还好，如果特别多怎么办？所以要减少for循环次数，先将数组从小到大排序，然后进行从两边到中间的计算，符合条件就 push一次 四、总结简简单单的一个for循环可以有不同的写法，所以说写代码简单，写出有质量的代码难","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"斐波那契数列的实现","slug":"斐波那契数列的实现","date":"2017-10-25T09:10:02.000Z","updated":"2017-10-25T10:59:23.307Z","comments":true,"path":"2017/10/25/斐波那契数列的实现/","link":"","permalink":"http://yoursite.com/2017/10/25/斐波那契数列的实现/","excerpt":"","text":"一、扫盲斐波那契数列也叫黄金分割数列，也叫兔子数列原理：假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？ 月份 兔子情况 总数 第0个月 a（小兔子） 1 第1个月 a（具备繁殖能力） 1 第2个月 b（生啦生啦）+ a（他父母） 2 第3个月 b（2月份出生的具备繁殖能力，正跃跃欲试） + b2（他父母又生二胎了） +a（他父母） 3 第4个月 c（2月份的兔子b喜当爹）+b（二月份出生的兔子） + b2（二胎具备繁殖能力，准备生娃） +a（他父母）+d(a生三胎) 5 … … … 1、1 、2、3、5、8、13、21、34、55、89……所以规律就是 fn(n)=fn(n-1)+fn(n-2) 二、代码实现1.第一种这种是最常见的实现：迭代12345678910111213/**i 月份*/function fn(i)&#123; var a=[]; /*0个月什么都不存在*/ a[0]=0; a[1]=1; for(var o=2;o&lt;=i;o++)&#123; a[o]=a[o-1]+a[o-2]; &#125; return a[i]&#125; 2.第二种递归1234567/** i 月份*/function fn(i)&#123; if(i&lt;2)&#123;return i===0?0:1;&#125; return fn(i-1)+fn(i-2)&#125; 是不是感觉很简洁 三、缺陷针对这个例子来说，这里的递归会进行太多次的调用（比迭代多），所以简洁的背后牺牲的是性能","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"css中的attr()","slug":"css中的attr","date":"2017-10-11T03:43:15.000Z","updated":"2017-10-11T05:20:29.499Z","comments":true,"path":"2017/10/11/css中的attr/","link":"","permalink":"http://yoursite.com/2017/10/11/css中的attr/","excerpt":"","text":"1.介绍attr() 用来获取一个html元素的属性值，可以用于伪元素，可以用于任何css属性 2.用法这个使用起来非常方便且简单1content:attr(属性值); attr()可以传三个值，分别是属性值、类型限制、默认值（必须符合类型限制），不过我试了半天也没调试成功，而且一般写一个参数就行，三个参数的情况基本用不到，所以就跳过了 3.例子12345678910111213141516171819&lt;hear&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 400px; height: 400px; border:1px solid #ccc; &#125; .box:after&#123; content:attr(data-foo); background-color: #ff461d; color: #fff; border-radius: .32rem; padding: .053333rem .133333rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\" data-foo=\"hello\"&gt;&lt;/div&gt;&lt;/body&gt; 此时，在div中将会出现一个红色背景的hello 4.实例那么这个东西在什么情况下能用到呢？ 购物车","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"attr()","slug":"attr","permalink":"http://yoursite.com/tags/attr/"}]},{"title":"react中的this.props.children","slug":"React.Children","date":"2017-09-28T09:34:55.000Z","updated":"2017-09-28T09:52:35.938Z","comments":true,"path":"2017/09/28/React.Children/","link":"","permalink":"http://yoursite.com/2017/09/28/React.Children/","excerpt":"","text":"一、介绍React.Children 是顶层API之一，为处理 this.props.children 提供了几个方法this.props.children 表示组件所有子节点 二、所有方法1.React.Children.map12345678//必须有返回值React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;)//没有返回值React.Children.map(this.props.children,function(child)&#123; /*这里进行处理*/&#125;) 这里的 child 表示组件的每一个子元素，也可以用箭头函数来写，这样方便this的传递 2.this.props.children这个是获取当前组件的所有子节点注意 ：1.如果没有子节点，返回 undefined2.如果一个子节点，返回 object3.如果多个子节点，返回 array但是用 React.Children.map 来遍历的话不会有问题 3.React.Children.count返回组件的所有子元素个数 4.React.Children.only12console.log(React.Children.only(this.props.children[0])); //输出对象this.props.children[0] 单独 this.props.children[0] 输出不出来 5.child.key在用 React.Children.map 的时候可能想获取传过来的属性值，例如123456789101112&lt;Tabs_li data=&#123;data&#125;&gt; &lt;div key=&#123;0&#125;&gt;1&lt;/div&gt; &lt;div key=&#123;1&#125;&gt;2&lt;/div&gt; &lt;div key=&#123;2&#125;&gt;3&lt;/div&gt;&lt;/Tabs_li&gt;/*Tabs组件*/&#123;React.Children.map(this.props.children,(child)=&gt;&#123; console.log(child.key) // 分别打印 0 ， 1 ，2 return ...&#125;)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react中跨域请求数据","slug":"react中跨域请求数据","date":"2017-09-27T06:03:37.000Z","updated":"2018-01-09T03:00:49.518Z","comments":true,"path":"2017/09/27/react中跨域请求数据/","link":"","permalink":"http://yoursite.com/2017/09/27/react中跨域请求数据/","excerpt":"","text":"一、介绍在我写 react ele 项目的时候，里面的所有数据都要从ele获取，所以我之前的想法是先用死的数据模拟，然后用 node 写几个接口请求ele数据并返回给我的react。知道今天早上，我在纳闷 react开发过程中是用 webpack 起服务器的，那跟后台就是跨域了啊，这样ajax是没有办法请求的，所以吃完一个鸡蛋后查找了一番，果然让我找到了，看下面 传送门 – gulp里服务端代理配置 二、配置webpack中 proxy 是设置代理的1234567proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", secure: false, changeOrigin : true &#125;&#125;, 现在比如说我 /api/users 这么请求，现在将代理请求http://localhost:3000/api/users 注意 ：这里的 secure 参数表示能请求 https 的服务器changeOrigin 表示是否支持跨域请求，默认 false 实例好了 现在我来试验一下12345\"/base\": &#123; target: \"http://c.y.qq.com/\", secure: false, changeOrigin : true&#125; 这个是我从qq音乐找了一个借口，在react中通过 fetch 请求12var result = fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; credentials: 'include', headers: &#123; 'Accept': 'application/json, text/plain, */*' &#125; &#125;)result.then(res =&gt;&#123;return res.text();&#125;).then(text =&gt; &#123; console.log(text) &#125;) 看看返回结果 控制台输出 是不是很方便~","categories":[],"tags":[{"name":"webpack proxy","slug":"webpack-proxy","permalink":"http://yoursite.com/tags/webpack-proxy/"},{"name":"react跨域请求","slug":"react跨域请求","permalink":"http://yoursite.com/tags/react跨域请求/"}]},{"title":"认识pushstate、popstate,无刷新改变URL","slug":"认识pushstate、popstate-无刷新改变URL","date":"2017-09-22T06:39:04.000Z","updated":"2018-04-12T07:27:23.499Z","comments":true,"path":"2017/09/22/认识pushstate、popstate-无刷新改变URL/","link":"","permalink":"http://yoursite.com/2017/09/22/认识pushstate、popstate-无刷新改变URL/","excerpt":"","text":"一、回顾 window.historyhistory对象包含用户（在浏览器窗口中）访问过的url12345678910//回退history.back();//前进history.forward();//跳转history.go();//历史记录条数（当前网页的，不是浏览器的）history.length//状态history.state 二、认识新特性HTML5扩展了history,使历史记录更加灵活，可以在历史记录中存储指定记录点、替换当前历史记录点，监听历史记录点 2.1.存储历史记录点123456window.history.pushState('新添加的','','?page=3');// 第一个参数：设置state// 第二个参数：页面标题，但是所有浏览器都忽略了，传空字符串就行// 第三个删除：想要添加的链接//`注意，这个api会改变当前的网址，会添加一条历史记录，不是push到后面，这样会添加一条历史` 执行后，页面的URL为当前url？page=3 执行前 执行后 此时的history.length也会+1，新增了历史记录点 2.2.替换历史记录点12345window.history.replaceState('新添加的','','?page=3');//`注意，这个api会改变当前的网址(不跳转)，不会添加一条历史记录，注意与上面pushState区别`&gt; 补充：location.replace()也是替换当前网址，但是页面会跳转，而且不会添加历史记录 区别：1.history.length不会变2.替换了当前页的历史记录点 2.3.监听历史记录点1window.onpopstate=function()&#123;&#125; 浏览器前进后退都会触发这个事件比如可以这样：123window.onpopstate=function(event)&#123; console.log(event.state)&#125; 后退操作时，就会打印出后退到的历史记录点的state信息。 四、用途在我写react饿了么的项目时，点击首页的定位信息，会从右滑动出一个新的页面，此时再通过浏览器的前进后退按钮也可以实现页面的滑动 浏览器控制动画 具体制作过程看我的github：ele项目 五、补充在用 document.referrer 做返回按钮的时候，是只有 a标签 才能添加一条来源的。比如我通过点击页面的一个 链接 调到了对应的页面，那么此时 document.referrer 是有值的，通过 history.pushState 添加的历史记录跳转的页面,不会添加一条 document.referrer 来源","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"position的sticky属性","slug":"position的sticky属性","date":"2017-09-13T02:25:03.000Z","updated":"2017-09-13T07:35:45.556Z","comments":true,"path":"2017/09/13/position的sticky属性/","link":"","permalink":"http://yoursite.com/2017/09/13/position的sticky属性/","excerpt":"","text":"表头跟随 图中展示的效果使我们在日常开发中常见的效果。以前我都是用js判断是否滚动一定距离然后给这个元素设置position:fixed这种方式来做的，今天就来记录一下用css怎么做 一、介绍css 中的 position 属性的值常用的主要有下面几种：1.absolute2.relative3.fixed现在用到的值为 sticky：设置了sticky的元素，不脱离文档流，在屏幕范围时（viewport），该元素位置不受到定位影响（top、left等值无效），当该元素的视图将要离开偏移范围时，定位会变成 fixed 的效果，并且根据设置的top 、left值进行定位 二、用法上面的gif图里，我将搜索框的元素设置为123postion:sticky;top:0;left:0 所以当移出屏幕时就会触发fixed定位 三、兼容性刚刚把它用在实际项目中去了，结果安卓自带的浏览器不支持，所以附加上解决办法：12345678910111213141516171819202122232425262728//判断是否支持if (CSS.supports(\"position\", \"sticky\") || CSS.supports(\"position\", \"-webkit-sticky\")) &#123; // 支持 sticky,顶部吸附 this.setState(&#123; support:true &#125;)&#125;else&#123; document.addEventListener('scroll',this._scrollTop)&#125;//不支持的主要处理_scrollTop()&#123; let offsetY=this.searchDOM.offsetTop; let css=null; if(window.scrollY&gt;offsetY)&#123; css=&#123; position:'fixed', top:0, zIndex:999 &#125; &#125;else&#123; css=&#123; position:'static', &#125; &#125; this.setState(&#123; css &#125;)&#125; 四、总结 该元素不脱离文档流，仍保留元素原本在文档流中的位置 当元素在容器中被滚动超过指定偏移值时，元素在容器内固定在指定位置。比如你设置了 top:50px 那么sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动 元素固定的相对偏移是相对于它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于 viewport 来计算元素的偏移量","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"create-react-app配置webpack","slug":"create-react-app配置webpack","date":"2017-09-06T08:42:15.000Z","updated":"2017-09-07T03:46:41.507Z","comments":true,"path":"2017/09/06/create-react-app配置webpack/","link":"","permalink":"http://yoursite.com/2017/09/06/create-react-app配置webpack/","excerpt":"","text":"在学习react过程中，每次都要配置webpack，非常的麻烦，我是要写react的，不是配置这东西哒！！好在有了’create-react-app’，通过npm安装后，创建项目变得非常简单但是它里面没有做less等你实际项目需要的loader或者plugins，所以这里记录的是怎么定制create-react-app创建的项目的webpack 一、先配置less1.创建一个项目我创建的叫test test测试项目 创建完毕后，进入创建的项目，运行npm start启动此项目 启动 2.找到webpack.config.dev.js和webpack.config.prod.js运行npm run eject安装less-loader和less进入config文件夹，这里会有两个文件webpack.config.dev.js和webpack.config.prod.js应该一个是开发环境一个生产环境的配置文件，两个文件都要修改打开webpack.config.dev.js找到module rules部分，也就是配置loader的部分，找到配置css文件的test（/\\.(css)$/）修改为test:/\\.(css|less)$/,添加一个loader：{ loader: require.resolve(&#39;less-loader&#39;) },放在最下面1234567891011121314151617181920212223242526&#123; test: /\\.css$/, use: [require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () = &gt;[require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: ['&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') &#125;, ],&#125;, 3.测试现在我们做一下测试可以随便在css文件中加入less语法我在App.css中设置了整体的背景颜色：1234567@base: pink;.App-header &#123; background-color: @base; height: 150px; padding: 20px; color: white;&#125; 因为我们修改了webpack的配置项，所以需要重新启动服务器： 添加成功 可以看到，配置已经成功 二、配置px2rem1.解释px2rem是做移动端页面开发的时候，自动将px单位转换为rem，非常的方便这里要用支持webpack的对应loader，我用的是postcss-px2rem配置这个功能相对来说有些复杂 2.安装npm install postcss-px2rem postcss-loader --save执行这个命令安装 3.配置还是webpack.config.dev.js，引入1const px2rem = require('postcss-px2rem') 添加在的autoprefixer下面添加，好像loaders里只能有一个postcss，多个的话不会报错，对应的功能会不管用12345678910111213141516171819202122&#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), //这个位置 px2rem(&#123;remUnit: 75&#125;) ], &#125;,&#125;, 这里面的数值就是1rem对应的px 4.测试现在启动服务器，因为原有的都是以px为单位，所以现在页面上应该全部转换为了rem 添加成功 不要忘了配置webpack.config.prod.js这个文件，最后只需要在你的页面上对html的font-size做变换就可以了，这里略过 5.总结webpack的文档和有些npm的文档写的走点心好么，搞得本来挺简单的东西查了好久！","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"px2rem","slug":"px2rem","permalink":"http://yoursite.com/tags/px2rem/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"箭头函数的this指向","slug":"箭头函数的this指向","date":"2017-08-25T07:14:31.000Z","updated":"2017-08-25T08:21:55.255Z","comments":true,"path":"2017/08/25/箭头函数的this指向/","link":"","permalink":"http://yoursite.com/2017/08/25/箭头函数的this指向/","excerpt":"","text":"前言 es6的箭头函数非常简洁，而且还可以解决很多问题1.解决以前通过var that=this方式传值的问题1234567document.body.addEventListener('click',function()&#123; setTimeout(function()&#123; console.log(this) /*window*/ /*对body节点操作代码...*/ &#125;)&#125;) 比如点击body，过一段时间对body这个元素进行对应的js操作，如上代码，很明显是不对的，因为setTimeout里的this是全局window所以是不能通过它操作body元素， 一般这种情况以前都是通过在外层通过一个变量将this传递进来，但是有了箭头函数就不用这么做了 es6:1234567document.body.addEventListener('click',function()&#123; setTimeout(()=&gt;&#123; console.log(this) /*body(当前节点)*/ /*对body节点操作代码...*/ &#125;)&#125;) 这类的问题还有很多，但是为什么箭头函数能轻易地解决这些问题呢？所以要清楚能这么写的原因就要清楚箭头函数中this的指向 一、写箭头函数的小提示1.当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。1234/*错误*/()=&gt;&#123;&#125;/*正确*/()=&gt;(&#123;&#125;) 因为JavaScript引擎会将{x}理解成一个代码块，空对象和块在这里都是{}这样表示，所以如果返回的是一个对象，需要加一个小括号 箭头函数的this箭头函数没有自己的this!!!!!!!!!,它内部的this值集成自外围作用域123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 t1、t2、t3都输出1因为箭头函数没有自己的this所以this.id会顺着作用域链查找一直找到foo()函数 箭头函数的的特点它没有arguments变量12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 如果有了新发现，会回来补充","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"react中的context","slug":"react中的context","date":"2017-08-21T03:29:02.000Z","updated":"2017-08-21T06:01:30.976Z","comments":true,"path":"2017/08/21/react中的context/","link":"","permalink":"http://yoursite.com/2017/08/21/react中的context/","excerpt":"","text":"一、为什么用context？现在我们有一颗组件树： 组件树 假如这个组件树代表的应用是用户可以自定义主题的，每个子组件都会根据主题的不同来调整自己的样式，所以‘主题色’这个东西就应该是组件之间共享的一个状态，所以应该放到Index组件中。但是在此之前能想到的办法只能是this.props.主题色 主题色的传递 这种形式，这种形式实在是麻烦，如果组件嵌套过深，就不得不一层层传递到最底层，所以就出现了简单的办法——通过context传递context这种方法是全局都能共享的状态，我们需要的时候就去取这个状态，不需要手动传递 context共享状态 二、实践，看看代码怎么写先创建一个整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;Title /&gt; &lt;/div&gt; ) &#125;&#125;class Main extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is main&lt;/h2&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;class Title extends Component &#123; render () &#123; return ( &lt;h1&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;React.js 小书内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 修改Index组件修改Index组件，让他往自己的context中放一个themeColor：1234567891011121314151617181920212223class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: 'red' &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 代码说明1.state初始化一个themeColor状态，方便以后的修改2.getChildContext方法设置context，返回一个的对象就是context，所有子组件动能访问到，且用this.state.themeColor来设置context里面的themeColor3.注意，还需要加上一段参数的验证 childContextTypes,需要使用prop-types这个包，验证的是getChildContext返回的对象以上这些都是必须的,这里要提及一下为啥要验证context，这么多步骤多麻烦，据说context是一个危险的属性(context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料),所以按照react.js团队的想法就是，把危险的事情搞复杂一些，提高使用门栏人们就不去用了 子组件的设置class Title extends Component { static contextTypes = { themeColor: PropTypes.string } render () { return ( &lt;h1 style={{ color: this.context.themeColor }}&gt;React.js 小书标题&lt;/h1&gt; ) } } 1.利用contextTypes进行验证，必写的，不写就无法获取context的状态，2.使用的话是通过this.context.themeColor来获取值的 修改context在Index里面，我们已经初始化一个state状态了，叫：this.state.themeColor,所以使用setState就可以了 四、我的例子: 点击变色按钮前 点击变色按钮后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript时间处理小技巧","slug":"js时间","date":"2017-08-18T07:41:37.000Z","updated":"2018-04-16T07:44:32.147Z","comments":true,"path":"2017/08/18/js时间/","link":"","permalink":"http://yoursite.com/2017/08/18/js时间/","excerpt":"","text":"获取当前时间1new Date() 获取当前时间的毫秒数12345678new Date().getTime()/*返回1970年1月1日至今的毫秒数*//*下面是作用相同，写法不同*/Date.now()/*这个也返回值相同*/+new Date() +”操作符123456789/*将元素转换成number类型*/+'123'/*返回123*/+'www'/*返回NaN*//*同理*/+Date.now() toLocaleDateString() 和 toLocaleTimeString() 区别123456789new Date().toLocaleDateString()/*2017/8/18 获取的年月日*/new Date().toLocaleTimeString()/*下午3:56:16 获取的时分秒*//*注意必须要用时间对象调用才行 比如 Date.now().toLocaleDateString()会报错，因为Date.now()返回的是毫秒数*/ 时间格式处理技巧如果想格式处理 当前时间与之前某个特定时间的时差 可以用这样的方式123456789/*duration为差值*/duration&gt;60 ?`$&#123;Math.round(duration/60)&#125;分钟前` : `$&#123;Math.round(Math.max(duration , 1))&#125;秒前`/*1.利用了ES6的模板字符串，结构更清晰2.利用三目运算符(三元运算符)进行判断，避免各种if3.Math.max 如果差值小于1s，则按1s计算，避免又一次的if判断*/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"gitment评论插件的配置","slug":"Hexo博客下gitment评论功能","date":"2017-08-14T09:03:00.132Z","updated":"2017-08-14T08:03:42.300Z","comments":true,"path":"2017/08/14/Hexo博客下gitment评论功能/","link":"","permalink":"http://yoursite.com/2017/08/14/Hexo博客下gitment评论功能/","excerpt":"","text":"今天我在第N次搭建博客的时候想加一个评论功能，我用的主题是indigo，在根目录_config.yml文件里经过测试发现最简洁好用的就是gitment，所以这里记录我gitment配置过程： 第一步先注册一个 oAuth Application注册成功会得到一个client id和 client secret两个参数，它们将被用于后面的用户登录 oAuth Application _config.yml 其中githubID需要https://api.github.com/users/github账户名 访问这个链接来获取 第二步如果你想要此功能的页面存在这一部分： gitment页面配置 这是一个ejs页面，里面是模板，通过使用主题的_config.yml文件配置那么你可以跳过这一步，否则需要在使用评论功能的页面添加这写代码：1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', // 可以是你的GitHub用户名，也可以是github id repo: '存储评论的 github repo', oauth: &#123; client_id: '你的 client id', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 第三步到这里已经默认你添加了上面的代码，现在注意了，我用的主题本身就带上面的代码的，只不过需要在 主题的 _comfig.yml文件中配置对应项，我在配置文件中配置好后，启动本地服务器，发现回复模块报错，控制台中发现他会请求一个链接，链接上带有刚刚配置好的参数，这里参数全部为空，我以为我配置文件有问题，折腾了好久，仍然不行，后来发现我要添加这个功能的页面里的模板并没有获取到我在_config.yml配置，最后通过修改要添加回复功能页面的模板文件才成功： 修改为 直接赋值，而不是使用模板，不知道为啥用模板获取不到值，现在已经配置成功如果配置失败，那么一定是上面的参数写错了，或者像我这种情况模板页面获取不到值，只需要直接赋值即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}