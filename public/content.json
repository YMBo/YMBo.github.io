{"meta":{"title":"DHYANA","subtitle":null,"description":"YMBo的博客，blog，YMBo","author":"YMBo","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-08-13T13:51:41.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-14T08:24:32.000Z","updated":"2021-01-25T10:48:26.563Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"tsconfig配置","slug":"tsconfig配置","date":"2021-01-25T10:55:54.000Z","updated":"2021-02-03T09:45:13.803Z","comments":true,"path":"2021/01/25/tsconfig配置/","link":"","permalink":"http://yoursite.com/2021/01/25/tsconfig配置/","excerpt":"","text":"一、前言不知不觉好久没有写博客和提交 github 了，20 年年初换了工作后，每天都非常忙，工作繁忙的同时自己也有一些收获和成长，也有一些新的收获想和想法想记录下来，但之前因为工作的原因这事一只拖着拖着最后就忘了，终于历经近一年终于产出了这篇文章 🤦‍♀ 二、背景因为对 tsconfig.json 的配置项不太了解，所以这篇文章以配置项解释+demo 的形式分析各个配置项的作用 三、tsconfig现在以 demo 的 tsconfig.json 每个配置项为例，详细说明其作用新建 tsconfig.json 空文件 经过测试在tsconfig include 字段包含的范围内编写 .d.ts/.ts，都将被自动识别 1、target target指的是编译后目标版本的语法是啥 demo 新建一个 a.ts 文件，用 tsc 命令编译后看结果 添加 &quot;target&quot;: &quot;ESNext&quot; 配置（ESNext：以当前 js 版本的下个版本提案为标准编译，总是最新语法） 12345678910const greeter = (person) =&gt; &#123; return 'Hello, ' + person;&#125;;export interface c &#123; age: string;&#125;const user: string = 'Jane User';async function age() &#123; await greeter(user);&#125; 编译后： 12345678const greeter = (person) =&gt; &#123; return 'Hello, ' + person;&#125;;const user = 'Jane User';async function age() &#123; await greeter(user);&#125;export &#123;&#125;; 可以看到语法结构基本没啥变化，因为编译目标是最新语法 &quot;target&quot;: &quot;ts3&quot;编译后：可以看编译后是 es3 的语法 1234567891011121314151617var greeter = function (person) &#123; return 'Hello, ' + person;&#125;;var user = 'Jane User';function age() &#123; return tslib_1.__awaiter(this, void 0, void 0, function () &#123; return tslib_1.__generator(this, function (_a) &#123; switch (_a.label) &#123; case 0: return [4 /*yield*/, greeter(user)]; case 1: _a.sent(); return [2 /*return*/]; &#125; &#125;); &#125;);&#125; &quot;target&quot;: &quot;ts6&quot;编译后：可以看编译后是 es6 的语法，因为箭头函数被保留了,装饰器不是 es6 的语法所以被转换了 123456789const greeter = (person) =&gt; &#123; return 'Hello, ' + person;&#125;;const user = 'Jane User';function age() &#123; return __awaiter(this, void 0, void 0, function* () &#123; yield greeter(user); &#125;);&#125; target 其他参数同理 2、outDir outDir指的是编译后的文件存放目录 在 tsconfig 中添加 &quot;outDir&quot;: &quot;lib&quot;,运行 tsc可以发现出现了个 lib 目录，lib 目录里面是 a.js,目录结构 lib└── a.js├a.ts├tsconfig.json 3、allowJs allowJs是否允许编译 js 在 tsconfig 中添加allowJs：false添加m.js文件，内容为 12345678910const greeter2 = (person) =&gt; &#123; return 'Hello, ' + person;&#125;;const user2 = 'Jane User';async function age2() &#123; await greeter2(user2);&#125;let name = 'm.js';export &#123; name, age2 &#125;; 运行下 tsc，发现如果 allowJs：false,那么 m.js（.js 文件）不会被编译，ture 的时候回被正常编译到 lib 文件夹下 4、strict 这个选项规定了是否启用所有严格类型检查选项。启用 –strict 相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict， –strictNullChecks 和 –strictFunctionTypes 和–strictPropertyInitialization 相当于更严格的模式，以noImplicitAny为例，说明下，看 5 5、noImplicitAny 在表达式和声明上有隐含的 any 类型时报错 在 tsconfig 中添加noImplicitAny:true,开启 any 类型检查 运行 tsc，编译 a.ts，可以看到如下报错 1234567a.ts:31:18 - error TS7006: Parameter &apos;person&apos; implicitly has an &apos;any&apos; type.31 const greeter = (person) =&gt; &#123; ~~~~~~Found 1 error. 上面 noImplicitThis 之类的同理 6、strictFunctionTypes 这个查了许多资料，这个说的最好：strictFunctionTypes 严格函数类型检查。这个说的比较抽象，举个例子父=子 错误 ， 子=父 正确 在 tsconfig.json 添加strictFunctionTypes:true，开启检查在 a.ts 添加一下代码： 123456function getCurrentYear(callback: (date: string | number) =&gt; void) &#123; callback(Math.random() &gt; 0.5 ? '2020' : 2020);&#125;getCurrentYear((date: string) =&gt; &#123; console.log(date.charAt(0));&#125;); 编译报错： 1234567a.ts:38:16 - error TS2345: Argument of type '(date: string) =&gt; void' is not assignable to parameter of type '(date: string | number) =&gt; void'. Types of parameters 'date' and 'date' are incompatible. Type 'string | number' is not assignable to type 'string'. Type 'number' is not assignable to type 'string'.38 getCurrentYear((date: string) =&gt; &#123; ~~~~~~~~~~~~~~~~~~~ 如果 strictFunctionTypes:false关闭检查则不会报错 7、jsx jsx 的编译规则 模式 输入 输出 输出文件扩展名 preserve ““ .jsx react React.createElement(“div”) .js react-native .js 在 tsconfig.json 添加&quot;jsx&quot;: &quot;preserve创建文件t.jsx内容为: 1&lt;div&gt;&lt;/div&gt; 编译后： 1&lt;div&gt;&lt;/div&gt; 在 tsconfig.json 修改&quot;jsx&quot;: &quot;react编译后的文件后缀变成了.js: 1React.createElement('div', null); 8、experimentalDecorators 允许是用装饰器 如果不开启这个选项，是不能用装饰器的，在 a.ts 中添加： 123456function decoraters(target) &#123; target.age = 10;&#125;@decoratersclass m &#123;&#125; 可以看到编译报错 9、importHelpers/moduleResolution importHelpers:从 tslib 导入辅助工具函数（比如 extends， rest 等），而不是生成代码到文件里moduleResolution:决定如何处理模块。或者是”Node”对于 Node.js/io.js，或者是”Classic”（默认） 这个选项依赖tslib这个库，安装这个库在 tsconfig.json 添加&quot;importHelpers&quot;: true，这时候 a.ts 就报红了： 红红红 说是找不到 tiblib 这个库，明明已经安装了呀，在 node_modules 目录下，其实是 ts 不知道去哪找这个库，所以我们要告诉 ts 去哪找这个库，添加配置：moduleResolution:node 多说一嘴，moduleResolution 有两个配置项 node 和 classic（默认），这俩逻辑也很简单node、classic ，所以这里是设置node tips:其实这个不配置 moduleResolution 也有另外的解决方案，就是在 tsconfig 加上这个配置，告诉如果用 classic 方案的话，去哪找这个包 1234567&gt; \"baseUrl\": \".\",&gt; \"paths\": &#123;&gt; \"tslib\": [&gt; \"./node_modules/tslib/tslib.d.ts\"&gt; ]&gt; &#125;,&gt; 运行 tsc 编译，结果：可以看到装饰器的辅助方法已经通过 import 引入了 1234567import &#123; __decorate &#125; from 'tslib';function decoraters(target) &#123; target.age = 10;&#125;let m = class m &#123;&#125;;m = __decorate([decoraters], m);export default decoraters; 修改tsconfig.json试试importHelpers：false，编译结果：辅助方法打到了文件里了 12345678910111213141516171819202122232425var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) &#123; var c = arguments.length, r = c &lt; 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc, d; if (typeof Reflect === 'object' &amp;&amp; typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if ((d = decorators[i])) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; &#125;;function decoraters(target) &#123; target.age = 10;&#125;let m = class m &#123;&#125;;m = __decorate([decoraters], m);export default decoraters; 10、noEmitHelpers 这个跟上面那个参数做的事情差不多，就是 不生成帮助函数 来试试看 在 tsconfig.json 添加&quot;noEmitHelpers&quot;: true，不生成辅助方法：编辑结果： 123456function decoraters(target) &#123; target.age = 10;&#125;let m = class m &#123;&#125;;m = __decorate([decoraters], m);export default decoraters; 11、typeRoots 这个用于指定类型声明文件的查找路径。默认值为 node_modules/@types，即在 node_modules 下的@types 里面查找。需要注意的是这里仅仅是 d.ts 文件的查找路径。同样，这个也是相当于在引入非相对模块的时候拓宽了类型声明文件的查找范围，其实就是配置类型声明文件的查找目录 注意这个只是类型的查找 本地试了试，没发现有啥用，这个参数好像没啥实际应用场景啊？ 12、declaration 生成相应的 .d.ts 文件。这个注意，只有代码里 export 的变量或方法 才会被生成.d.ts 文件，如果有个变量没有 export，那就在对应的.d.ts 文件里不会包含此变量的类型 在 tsconfig.json 添加&quot;declaration&quot;: true，生成类型文件 a.ts 中添加一个没有 export 的方法 age： 12345678910111213function decoraters(target) &#123; target.age = 10;&#125;@decoratersclass m &#123;&#125;function age() &#123; console.log('m');&#125;age();export default decoraters; 看到输出的a.d.ts结果： 12declare function decoraters(target: any): void;export default decoraters; 不包含age方法 13、declarationDir 生成.d.ts 文件的存放目录 14、allowSyntheticDefaultImports 当导入的模块是以 commonJs 语法导出时，不能用 import M from ‘./m’ 这种语法，会报错，因为 ts 会检测导入模块是否有 default 字段，没有的话导出要用 import * as M from ‘./m，加这个配置 可以正常导入 import M from ‘./‘ 新建 commonJs.js 文件,用 commonJs 语法导出： 12345678let CommonJS = 1;function getCom() &#123; return CommonJS;&#125;module.exports = function (x) &#123; console.log(x);&#125;; 修改 a.ts: 12345import getCom from './commonJS';console.log(getCom);function decoraters(target) &#123; target.age = 10;&#125; 编译： 12345678910111213141516a.ts:14:8 - error TS1259: Module '\"/Users/mbyang/Desktop/test/commonJS\"' can only be default-imported using the 'allowSyntheticDefaultImports' flag14 import getCom from './commonJS'; ~~~~~~ commonJS.js:6:1 6 module.exports = function (x) &#123; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 7 console.log(x); ~~~~~~~~~~~~~~~~~ 8 &#125;; ~ This module is declared with using 'export =', and can only be used with a default import when using the 'allowSyntheticDefaultImports' flag.Found 1 error. 在 tsconfig.json 添加&quot;allowSyntheticDefaultImports&quot;: true 即可解决，或者修改为 1import * as getCom from './commonJS'; 15、resolveJsonModule 包括以“.json”扩展名导入的模块 ,一版这个要配合 include 选项，如果 include 选项没有配置.json 文件，那配置这个也没啥用 16、baseUrl/paths 设置 baseUrl 来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于 baseUrl，baseUrl 默认值为’.’当前路径注意是非相对模块 在 tsconfig.json 添加瞎写的&quot;baseUrl&quot;: &quot;../../../&quot;，添加path指定 a.ts 模块的路径: 123\"paths\": &#123; \"a\": [\"./a.ts\"] // 此处映射是相对于\"baseUrl\" &#125; 这个参数我来来回回试验没发现啥用，也不报错，后来发现是要用 ts 类型的文件，js 类型文件不报红，看下面例子 创建新文件 m.ts，添加内容（如果是 m.js 不会报错）： 12import decoraters from 'a';console.log(decoraters); a就是上面写的a.ts，编译发现报错，因为 ts 不知道去哪找这个文件 将baseUrl 改成./或. 发现 m.ts 不报错了，能找到模块 a 的定义 17、lib 这个是用于指定要引入的库文件，属性值为一个数组，如果不配置 lib，那么其默认会引入 dom 库，但是如果配置了 lib，那么就只会引入指定的库了 在 tsconfig.json 添加&quot;lib&quot;: &quot;ES6&quot;:在 m.ts 添加代码： 1document.getElementById('ccc'); 可以看见已经报错了： lib改为dom则编译通过 18、types 官网是这么说的：如果指定了 types，只有被列出来的包才会被包含进来，它说的不是指的 import 导入模块找不到定义，指的是如果用了全局的变量，全局变量的类型找不找的到，看例子 在 tsconfig.json 添加&quot;types&quot;:[]安装 jquery,npm i jquery -S，此时的 node_module/@types 目录为： node_modules 然后在 m.ts 中，分别用 jq 和 node 的全局变量，添加代码： 1234// nodeconsole.log(process);// jqueryconsole.log($); error tsconfig.json 修改为 &quot;types&quot;:[&quot;node&quot;,&quot;jquery&quot;]后，编译通过","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"工具包","slug":"工具包","date":"2020-04-30T09:48:01.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2020/04/30/工具包/","link":"","permalink":"http://yoursite.com/2020/04/30/工具包/","excerpt":"","text":"前言这篇文章记录的是关于一些工具包的使用和注意事项 一、husky这个东西的作用是方便的给 git 添加钩子 注意 这个东西只用 npm 安装才能正常使用，否则不能使用，cnpm 也不行 写法必须是这样写在 package.json 里,不要写在 package.json 的 scripts 里 12345 \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"echo 'husky'&amp;&amp;node ./test.js\" &#125;&#125;, 不足比如我添加了一个pre-commit钩子，就是在每次 commit 前进行指定操作，但是它这个操作是针对你的所有文件操作的，即使你没有改动的文件比如：每次 commit 我想 eslint --fix 一下，那么这个操作会执行到所有文件上，包括你没改动的文件 补充知道了不足肯定有解决办法，看下面的这个工具 二、lint-staged作用这个东西就是指明了上面钩子里的命令要作用于改动的文件 使用方法也是在 package.json 里 12345678910111213\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;&#125;,\"lint-staged\": &#123;// 匹配文件类型，如果没匹配到就忽略，匹配到就执行里面的命令 \"*.js\": [ \"echo 'js文件过'\", \"node ./test.js\", \"git add\" ]&#125;, 三、mocker-api这个是以 restful api 风格模拟假数据的，同样也有些要注意的地方 如果不和 webpack 配合使用，那命令行执行就可以,会启动一个服务 直接访问即可 与 webpack 配合，要使用 apiMocker，apiMocker 有三个参数 apiMocker(app,path,option) 1. app:devserver服务器实例（express实例） 2. mocker配置文件路径（一定要有后缀） 3. 这个参数一定要注意，如果在mocker/index.js(就是mocker的配置文件)利配置过了_proxy:{}这个参数，那这个option是没用的 配置项的一些说明 123456789101112131415161718192021222324252627282930313233_proxy: &#123; // 代理 proxy: &#123; // 代理规则，目标服务器配置 '/api/(.*)': 'https://api.github.com/' &#125;, // 重写路径，前端请求的是这个^/api/repos/，实际发送的是这个'/repos/' pathRewrite: &#123; '^/api/repos/': '/repos/', &#125;, // 是否设置请求头的host,true表示在请求头里会带有host信息，false不带 // 有的代理服务器设置了请求域名白名单（某些域名才能访问）就要设置这个 changeHost: true, // mocker-api其实是在http-proxy基础上封装的，这个配置项就是http-proxy的配置项 // http proxy配置项 httpProxy: &#123; options: &#123; // 转发到目的路径是否带上path // 在上面proxy配置了 '/api/(.*)'的前提下 // 比如 true 请求地址：localhost/api/user,那转发到代理服务器的请求是 1.1.1.1，没有path // false 就是1.1.1.1/api/user ignorePath: true, &#125;, // 监听事件 listeners: &#123; // 在每次请求转发前拦截，可以进行改动，比如设置一个请求头 // proxyReq.setHeader('X-Special-Proxy-Header', 'foobar'); proxyReq: function (proxyReq, req, res, options) &#123; console.log('proxyReq',req); &#125;, &#125;, &#125; &#125;, webpack 配置 demowebpack.js1234567891011121314151617181920212223242526272829const path = require('path');const merge = require('webpack-merge');const common = require('./webpack.common.js');const APIMocker = require('mocker-api');const os = require('os');module.exports = env =&gt; merge(common, &#123; mode: 'development', output: &#123; publicPath: '' &#125;, devtool: '#eval-source-map', devServer: &#123; // host: getNetworkIp(), host: '0.0.0.0', disableHostCheck: true, contentBase: path.join(__dirname, '/src/'), before(app) &#123; APIMocker(app, path.resolve('./mocker/mock.js')); &#125;, proxy: &#123; '/handwrite': &#123; target: 'http://xxxxx.com', // target host changeOrigin: true, // needed for virtual hosted sites ws: true, // proxy websockets pathRewrite: &#123; // '^/payui': '/payui' &#125; mock.js12345678910111213141516171819202122232425262728const glob = require('glob');const path = require('path');let proxy = &#123;&#125;;const files = glob.sync('src/pages/*?/test_data.js');files.forEach((file) =&gt; &#123; let paths = file.split('/'); let sub = paths.pop(); let namespace = paths.pop(); let filepath = path.join(__dirname, '../', file); let data = require(filepath); let n_data = &#123;&#125;; let isNameSpace = data.namespace; // 如果设定命名空间 for (let key in data) &#123; let addX = /^\\//g.test(key); let endKey = ''; if (key == 'namespace') continue; if (isNameSpace) &#123; endKey = `/test/$&#123;namespace&#125;$&#123;addX ? '' : '/'&#125;$&#123;key&#125;`; &#125; else &#123; endKey = `/test$&#123;addX ? '' : '/'&#125;$&#123;key&#125;`; &#125; n_data[endKey] = data[key]; &#125; proxy = Object.assign(proxy, n_data); console.log(proxy);&#125;);module.exports = proxy; test_data.js123456789101112131415161718192021222324252627282930let api = require('../../api/api');module.exports = &#123; // namespace: true, [api.demo.getUser]: &#123; id: 1, username: 'kenny', sex: 6 &#125;, [api.demo.updataUser]: (req, res) =&gt; &#123; const &#123; password, username &#125; = req.body; if (password === '888888' &amp;&amp; username === 'admin') &#123; return res.json(&#123; status: 'ok', code: 0, token: 'sdfsdfsdfdsf', data: &#123; id: 1, username: 'kenny', sex: 6 &#125; &#125;); &#125; else &#123; return res.status(403).json(&#123; status: 'error', code: 403 &#125;); &#125; &#125;&#125;;","categories":[],"tags":[{"name":"husky","slug":"husky","permalink":"http://yoursite.com/tags/husky/"},{"name":"lint-staged","slug":"lint-staged","permalink":"http://yoursite.com/tags/lint-staged/"},{"name":"mocker-api","slug":"mocker-api","permalink":"http://yoursite.com/tags/mocker-api/"}]},{"title":"安装黑苹果遇到的问题与解决记录","slug":"安装黑苹果遇到的问题与解决记录","date":"2020-01-03T12:51:02.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2020/01/03/安装黑苹果遇到的问题与解决记录/","link":"","permalink":"http://yoursite.com/2020/01/03/安装黑苹果遇到的问题与解决记录/","excerpt":"","text":"前言–这篇文章讲了啥？这篇文件是我在安装黑苹果时遇到的问题与解决办法的总结所以更注重的是发现问题 解决问题，关于黑苹果教程自己上网上找吧，资源非常多所以安装方面可能就几句话带过了 1. 硬件配置 电脑型号 戴尔 Inspiron 5680 台式电脑 操作系统 Windows 10 64位 家庭版 处理器 英特尔 Core i5-8400 主板 戴尔 0PXWHK（z370芯片组），找efi驱动首先按照这个主板来就行（z370） 内存 三星 DDR4 2400MHz / 金士顿 DDR4 2400MHz 硬盘 3块 东芝1T的机械硬盘（存放文件），SK hynix SC311 SATA 128GB（自带的win10系统）金士顿 480G （专门用来装黑苹果的） 显卡 Nvidia GeForce GTX 1060 6GB 显示器 2k的显示器 （这个无所谓） 网卡 瑞昱 RTL8168/8111/8112 Gigabit Ethernet Controller / 戴尔 2. 关于安装首先 你得查你电脑硬件支不支持黑苹果，如果支持黑苹果再看支持到那个版本，我电脑只能支持到 10.13.6，再往上说是因为没有对应的N卡驱动了efi驱动的选择 你很大程度找不到配置完全合适的efi文件，efi文件我主要是依据cpu来找的，也就是 i5 8400 z370 我用的这个 黑苹果镜像选择 我安装的是 集成了clover的版本 macOS High Sierra 10.13.6 17G65 With Clover 4596 ,本来我要传百度网盘分享出来的，万恶的百度网盘不让上传超过4G的文件，所以自己下载去吧，网上资源一大把 二、我遇到的问题1. 用U盘安装时，提示镜像资源过期（或者是什么镜像副本损坏之类的）解决办法：左上的菜单栏有一项是终端，打开，断网（要不自己又同步回来了）然后输入 date 102723252015.0610 -&gt; 月，27-&gt;日， 23-&gt;时， 25-&gt;分， 2015-&gt;年。然后再次安装，成功 （但是会带来后面的一个问题，第二条说） 2. 选择硬盘2次安装时，提示 安装器资源已过期，请重试(我也不知道为啥我的是英文的)这时用上面的方法就不行了，因为一打开终端，中间那个界面就消失了，不给你重试的机会，后来经过我N次的重试和摸索，解决方案如下： 断网且将bios时间设置为2015年10月27（别的时间也行，不一定非这个） 重新走上面的步骤，也就是u盘启动，抹掉要安装黑苹果的盘符（金士顿的硬盘），注意，格式选择为APFS,网上好多教程是 macos扩展，但我macos扩展有问题，所以我建议用APFS 硬盘抹掉安装macos安装器成功后会自动重启，还是上面的步骤选择中英文，一些设置然后点安装后，就没有这个问题了 3. 显卡驱动我的显卡是 GTX 1060ti 6G显存的，用的显卡驱动是WebDriver-387.10.10.10.40.105(官网下载,找到你显卡对应的驱动版本) 然后安装（基本就是一直下一步就可以），然后还需要在clover configuration 这个软件中，在引导参数中（英文BOOT）添加一个参数 nvda_drv=1，在 System parameters 勾选 NV显卡web驱动，重启即可 4. 关机不断电，鼠标键盘灯依然亮这个我折腾了好久好久好久 下载NTFS.efi和OsxAptioFixDrv.efi驱动，放在clover/drivers64UEFI目录下 网上说执行上面一步就行了，但我的就不行，我把clover手动更新到 r4586版本才成功 5. clover主题修改这个不是问题，用 cloverThemeManager 这个软件，教程自己搜很简单 6. 关于clover的升级我现在的clover是中文的，不跟网上一样有些版本看不见，所以我手动升级的，关于手动升级教程 7. 关于clover引导win10启动卡死的原因没错，我的就是卡死了，经过我反复测试和思考，原因如下： win10必须在 stat operation:READ ON模式下，启动，否则会报 （未检测到硬盘，如果硬盘已存在则硬盘没有响应） 目录是 C:\\windows\\system32\\logfiles\\srt\\srtTrail.txt 文件 日志 但是黑苹果又必须在 stat operation:AHCI 模式才能启动 解决方案：下载免AHCI补丁，这样就不用了开启AHCI模式了, 下载AHCIPortInjector.kext 这个文件，放在clover/kexts/other下面，就可以了 （这个文件真的难下，找了好久才找到），所以我存到了我的网盘并且贴心的提供了 下载地址 提取码: iapw 这样就不用了开启 stat operation:READ ON 就可以了，这样win10和MACOS都能被clover引导启动了 8. clover引导win10 loading转动后黑屏，不显示锁屏页面（输入密码那页）概率 ：每次启动win10都要启动两回才能成功，第一回黑屏，第二回成功解决方案： 在win10下关闭 快速启动 9. 解决不了的问题 dell自检画面分辨率局低（独显没启动）这是关闭 Secure boot 的后果，但是不关闭就不能用clover引导了，这个真没办法了 10. 声卡驱动这个我下载了 AudioDxe-64.efi 这个驱动，也注入了 显卡ID，但就是没声音，暂未解决","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/系统/"},{"name":"驱动","slug":"驱动","permalink":"http://yoursite.com/tags/驱动/"},{"name":"macOS","slug":"macOS","permalink":"http://yoursite.com/tags/macOS/"}]},{"title":"浏览器缓存机制","slug":"浏览器缓存机制","date":"2019-11-22T09:02:10.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2019/11/22/浏览器缓存机制/","link":"","permalink":"http://yoursite.com/2019/11/22/浏览器缓存机制/","excerpt":"","text":"前言下面的内容是 强缓存和协商缓存 的内容，以前学习过，时间长就忘了，所以记在这里（网上也有好多很好的文章）参考文章：缓存 😌 本来都写了一点了，但是我看这个参考文章写得很好了，就直接看这个参考文章吧 客户端====&gt;强缓存（客户端缓存）====&gt;协商缓存（虽然请求了服务器，但也是返回客户端资源）=====&gt;服务端返回资源 强缓存第一种1. Expires：服务端返回，客户端下次如果再请求，会首先判断一下过期时间是否大于了这个值，如果没大于，用缓存第二种2. Cache-control Cache-Control 优先级高于 Expires 协商缓存：第一种1. 服务端返回 Etag ，再次请求的时候If-None-Match 会将刚刚的Etag带上，去服务端做判断，优先级最高第二种2. 服务端返回Last-Modified（表示本地文件最后修改日期），再次请求的时候If-Modified-Since 会将刚刚的 时间带上，去服务端做判断","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"通信方式","slug":"通信方式","date":"2019-11-21T06:37:47.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2019/11/21/通信方式/","link":"","permalink":"http://yoursite.com/2019/11/21/通信方式/","excerpt":"","text":"一、WebSocket全双工通信通信双方都可以发送和接受信息 2. WebSocket协议一旦建立WebScoket协议的通信连接，通信可以发送JSON、XML、HTML或图片任意格式的数据 3. 功能（优点）1. 推送功能服务端可以主动向客户端推送数据啦 2. 减少通信量建立的WebSocket连接，一直保持连接状态，和HTTP相比减少了每次连接的开销，而且WebSocket的首部信息很小，所以通信量也少了 3. 连接过程为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次握手的步骤为了实现WebSocket,需要用到HTTP的 Upgrade的首部字段 ，告诉服务器通信协议发生改变，以达到握手的目的 请求头 Sec-WebSocket-Key 字段记录握手过程必不可少的键值Sec-WebSocket-Protocol 字段记录使用的子协议 流程 响应： 响应头 4. 实现1. 前台1234567891011121314151617181920&lt;body&gt; &lt;button id=\"a\"&gt;发信息&lt;/button&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; let ws = new WebSocket('ws://localhost:3333') // 触发连接 ws.onopen = function() &#123; console.log('连接') &#125; ws.onclose = function() &#123; console.log('断开连接') &#125; ws.onmessage = function(e) &#123; console.log('收到信息', e.data) &#125; document.getElementById(\"a\").onclick = function() &#123; // 监测 id=“sendb”的 按钮 触发 onclick 就会发送数据 send // ws.send('发信息了'); &#125;&lt;/script&gt; 2. 后台1234567891011121314const ws = require('nodejs-websocket')let server = ws.createServer(conn =&gt; &#123; console.log('连接', conn) conn.on('text', str =&gt; &#123; console.log(str) &#125;) conn.on('close', (code, reason) =&gt; &#123; console.log('连接断开') &#125;) conn.on('error', err =&gt; &#123; &#125;)&#125;).listen(3333) 3. 结果 信息头 点击发信息 结果 一、SSE （server-sent event）仅仅服务端往客户端推动，基于http协议1var source = new EventSource(url); EventSource实例的readyState属性，表明连接的当前状态。该属性只读，可以取以下值。 0：相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。1：相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。2：相当于常量EventSource.CLOSED，表示连接已断，且不会重连。 1. 数据格式（发送端）⓵ 响应头响应头必须有 Content-Type: text/event-stream MIME Type 规定为 text/event-stream Cache-Control: no-cache 不允许缓存（可不写） Connection: keep-alive 指定持久连接（长连接），默认都是持久连接（可不写） ⓶ data 数据数据用data表示，用 \\n\\n结尾比如： data: 这里是数据 \\n\\n多行用 \\n 分隔，\\n\\n 结尾比如：data: asdf \\ndata: ghjk \\ndata: asdf \\n\\n这是一条数据 ⓷ event 事件类型前端默认用 message 接收事件，但是也可以用服务端自定的事件名称 event: have \\ndata: 定义了一个have事件 \\n\\n 触发客户端 have 事件 ⓸ retry 最大间隔时间浏览器默认服务器端三秒内没有发送任何信息，则开始重连。服务器端可以用retry头信息，指定这个时间retry: 10000\\n ⓹ idid: msg1\\ndata: message\\n\\n 我没咋用到过 浏览器会一直跟踪最近的事件ID，如果发生了重连，浏览器会把最近接收到的事件ID放入 HTTP Header “Last-Event-ID” 中，作为一种简单的同步机制。 ⓺ 客户端主动关闭1source.close(); ⓻ 服务端关闭我用的node做测试的，就是接受一个前端触发的close事件，来关闭123req.connection.addListener(\"close\", function() &#123; clearInterval(interval);&#125;, false); 2. demo⓵ 客户端1234567let source = new EventSource('/url');source.onmessage = function(e) &#123; console.log(e, e.data);&#125;;setTimeout(() =&gt; &#123; source.close()&#125;, 5000); ⓶ 服务端（node）12345678910111213app.use(\"/url\", function(req, res) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/event-stream\", &#125;); setInterval(() =&gt; &#123; res.write(\"id: num1\\n\\n\"); res.write(\"data:\" + (new Date()) + \"\\n\\n\"); &#125;, 1000); req.connection.addListener(\"close\", function() &#123; clearInterval(interval); &#125;, false);&#125;) 每一秒触发一次，5秒断开连接 ⓷ gif 结果 三、comet解释基于HTTP长连接的，无需在浏览器安装插件的服务器推送的一种HACK技术 1. 与ajax对比Ajax要想取得数据，必须先发送请求，在延时要是比较高的web应用中，只能增加服务器请求的频率comet是客户端与服务器端保持一个长连接，只有客户端需要数据更新时，服务器才主动将数据推送到客户端 comet的实现主要有两种方式 基于Ajax的长轮询（long-polling） 基于Iframe及htmlfile的流（http streaming）方式 2. 基于Ajax的长轮询（long-polling） 两种区别 服务端发起请求，服务端挂起，有更新的时候，服务端才返回数据 demo⓵ 客户端123456789101112131415161718&lt;body&gt;&lt;button onclick=\"run()\"&gt;开始&lt;/button&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function run()&#123; // 这个超时时间不设置的话就是不会因超时而停止 // 因为有可能客户端已经超时了，服务端才返回 // 所以设不设置看需求 axios.get('/url',&#123;timeout: 10000&#125;).then(r=&gt;&#123; console.log(r.data) run() &#125;).catch(e=&gt;&#123; // 这块应该有个次数判断，我简写了 run() &#125;) &#125; &lt;/script&gt; ⓶ 服务端（node）1234567app.use(\"/url\", function(req, res) &#123; // 模拟一下时间 const time=Math.ceil(Math.random()*5); setTimeout(() =&gt; &#123; res.json(\"成功\"); &#125;, time*1000);&#125;) ⓷ gif 结果 3. 基于Iframe及htmlfile的流（http streaming）前台定义好获取数据的函数，参数是数据，后台传过来的是函数的调用 ⓵ 客户端 123456789 &lt;script type=\"text/javascript\"&gt; function getJSON(data)&#123; console.log(data) &#125;&lt;/script&gt;&lt;body&gt; &lt;!-- 一般这个iframe是隐藏的或者通过js创建的，我简化了 --&gt; &lt;iframe src=\"/iframe\" frameborder=\"0\"&gt;&lt;/iframe&gt;&lt;/body&gt; ⓶ 服务端（node）12345678app.use(\"/iframe\", function(req, res) &#123; // 模拟一下时间 const time=Math.ceil(Math.random()*5); setTimeout(() =&gt; &#123; // 这就直接调用了 res.send('&lt;script type=\"text/javascript\"&gt;parent.getJSON('+time+')&lt;/script&gt;'); &#125;, time*1000);&#125;) ⓷ gif 结果","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"HTTPS","slug":"HTTPS","date":"2019-11-20T07:02:14.000Z","updated":"2021-01-25T10:48:26.372Z","comments":true,"path":"2019/11/20/HTTPS/","link":"","permalink":"http://yoursite.com/2019/11/20/HTTPS/","excerpt":"","text":"前言以下是我对《图解HTTP》这本书阅读后的知识梳理，为了加深印象和忘了的时候能不瞎找 一、http缺点1. 通信使用明文，不加密，内容可能会被窃听TCP/IP协议族工作机制，通信内容在所有的通信线路上都有可能遭到窥视其实加密也会被窥视，只不过通信经过加密，报文信息无法被破解，但还是能看到的，用抓包工具Wireshark等 窃听 2. 不验证通信方身份，可能遭遇伪装http协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求，另外，服务器只要接收到请求，不管对方是谁都会返回一个相应 窃听 1. 伪装服务器（无法确定请求来自何方、出自谁手） 2. 伪装客户端 3. 无法阻止海量请求，DOS攻击 3. 无法证明报文完整性，篡改报文无法证明信息的准确度，无法确认发出的请求/相应和接受的请求/相应是前后相同的 无法确定准确度 中间人攻击 二、SSLSSL： 安全套接层用SSL建立安全通信线路后，就可以在这条线路进行HTTP通信，与SSL组合使用的HTTP称为HTTPS 安全的通信线路 1.证书使用HTTP协议无法确定通信方，但是SSL则可以，SSL不仅提供加密，还使用称为 证书的手段，用于确定通信双方。证书由值得信任的第三方机构颁发，用来 证明服务器和客户端是实际存在的 证书 2.加密（公开密钥加密）SSL采用公开密钥加密的加密方式使用一对非对称的密钥，一个叫私有秘钥（不能让别人知道），一个叫公有密钥（受任何人都可以知道） 𝟙.流程发送密文一方使用对方的公开密钥进行加密，对方收到加密的信息后，再用自己的私钥解密 不需要发送密钥了加密算法公开，密钥保密密钥被窃取，加密也就没有意义了(因为不需要发送密钥，也就不懂担心密钥被窃取了) 加密 𝟚.存在的问题—无法证明公开密钥本身就是货真价实的公开密钥当然也存在解决办法，那就是使用由数字证书认证机构和其相关机构办法的公开密钥和证书 数字证书认证机构（CA），处于客户端与服务器双方都可信赖的第三方机构，颁发的数字证书为最终用户数据加密的公共密钥。在这个过程中，CA的责任是确保公司或用户接收一个唯一的证书是一个有效的身份的认证。 流程 服务器运营人员向数字证书认证机构提出公开密钥的申请 机构在判明提出申请者身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定一起 服务器会将这个公钥证书发送给客户端，公钥证书也叫数字证书或证书 接收到证书的客户端使用数字证书认证机构的公开密钥对证书上的数字签名进行验证，一旦通过，就能确定这个公开密钥真实有效且值得信赖 加密 2.加密（共享密钥加密）加密和解密用同一个密钥的方式称为共享密钥加密也叫对称密钥加密 3.两种加密方式的对比公开密钥加密处理速度慢于共享密钥加密 公开密钥优势 不需要交换共享密钥，所以不用担心共享密钥会暴露公开密钥劣势 耗费资源，必须经过数字证书验证 共享密钥优势 不需要经过数字证书验证，速度优于公开密钥共享密钥劣势 需要发送共享密钥，有暴露的风向 三、HTTP+加密+认证+完整性保护=HTTPSHTTPS使用SSL和TLS两种协议 证书 HTTPS 问题：共享密钥的方式加密时必须将密钥也发给对方，那怎么安全发送呢？ 1.https的加密（混合加密）两个步骤 交换密钥环节：使用公开密钥加密（主要是为了传递共享秘钥加密方式里的密钥） 通信：确保密钥是安全的前提下，使用共享密钥进行通信 2.https的通信机制 通信步骤 步骤1. 客户端发送Client Hello 报文开始SSL通信。报文中含客户端支持的SSL的指定版本、加密组件列表（使用的加密算法和秘钥长度） 步骤2. 服务器可进行SSL通信时，会以server Hello报文作为应答，报文中包含SSL版本和加密组件，加密组件内容是从接收到的客户端加密组件内筛选出来的 步骤3. 服务器发送certificate报文，报文中含有公开密钥证书 步骤4. 服务器发送 server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束 步骤5. SSL第一次握手结束后，客户端以Client Key Exchange 报文最为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文用步骤3中的公开密钥加密（告知服务端共享秘钥） 步骤6. 接着客户端发送change cipher spec报文，该报文会提示服务器，在此报文之后的通信会采用Pre-master secret 密钥加密 步骤7. 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值，这次握手协商是否能成功，要以服务器是否能够正确解密该报文作为判定标准 （如果服务器能正确解密，则这次握手协商成功） 步骤8. 服务器同样发送Change cipher spec 报文 步骤9. 服务器发送Finished报文 步骤10. 服务器和客户端的Finished报文交换完毕后，SSL连接就算建立完成，当然，通信会受到SSL保护，从此处开始进行应用层协议的通信，即发送HTTP相求 步骤11. 应用层协议通信，即发送HTTP响应 步骤12。 最后由客户端断开连接，断开连接时，发送close_notify 报文 再发送TCP FIN报文来关闭与TCP的通信 应用层发送数据时会附加一种加MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整新 3.HTTPS通信过程总结 客户端和服务端协商决定加密组件 服务端发送公开密钥证书（当然服务器也存在配对的私有秘钥） 客户端确认这个证书的有效性，然后取出公开密钥 客户端生成一个 pre-master secret （随机数），然后用刚刚的公开密钥加密 客户端发送加密好的pre-master secret ，服务端用私有秘钥解密 上面的pre-master secret 就是共享秘钥，现在两边都有了 进行正常的http通信 4.客户端认证 basic jwt等这种认证 SSL客户端认证，一般登录个人网银时，需要下载证书安装 表单认证，就是开始登录网站需要输入的账号密码 四、HTTPS的缺点 HTTPS比HTTP要慢2到100倍 因为使用了SSL，它的处理速度会变慢 SSL慢分两种 SSL通信慢 由于大量消耗CPU及内存资源，导致处理速度变慢 消耗资源 加密通信会消耗更多的CPU内存和资源，那么计算机能够处理的请求数量就会减少，所以在传递一些敏感数据时采用HTTPS 费钱购买证书要花钱的 五、想法关于http我觉得还有些不足，比如不具备服务端主动推送供，每次想知道服务器内容是否更新等都需要客户端轮询做http请求等功能，所以我也总结了别的常用的通信方式，通信方式","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"http首部字段","slug":"http首部字段","date":"2019-11-19T06:33:29.000Z","updated":"2021-01-25T10:48:26.377Z","comments":true,"path":"2019/11/19/http首部字段/","link":"","permalink":"http://yoursite.com/2019/11/19/http首部字段/","excerpt":"","text":"前言代理缓存代理代理转发响应时，缓存代理会与湘江资源的副本保存在代理服务器上当代理再次受到对相同资源的请求时，就可以不从源服务器哪里获取资源，而是将之前缓存的资源作为相应返回 透明代理转发请求或相应时，不对报文做任何加工的代理类型被称为透明代理 客户端的缓存浏览器的缓存称为零食网络文件 temporary internet file当判定缓存期过期后，会向源服务器确认资源的有效性，（强缓存和协商缓存） http首部字段http首部字段类型根据实际用途被分为以下4种类型： 通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。 请求首部报文（Request Headers Fields）从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容，客户端信息，响应内容相关优先级等信息。 响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息。 一、通用首部字段（General Header Fields）1. Cache-control客户端缓存请求指令： no-cache 可以在本地缓存，可以子啊代理服务器缓存，但是这个缓存要服务器验证才可以使用 no-store 彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务端获取 max-age 如果缓存资源的缓存时间比这个数值小，那么客户端就使用缓存的资源，否则就要请求源服务器 min-fresh 要求缓存服务器返回值至少还未经过指定时间的缓存资源 期望在指定时间内响应有效，比如min-fresh=60,那么60s后就要重新请求服务器而不是使用缓存 max-stale: 缓存资源即使过期也照常接收，如果没有参数，无论经过多多久客户端都会接收，如果有参数，只要处于这个时间内，就会被接收 on-if-cached: 缓存服务器只要对目标有缓存资源的情况下返回，不重新加载相应 服务端缓存相应指令：客户端 —– 代理服务器 ——-源服务器 public 可以向任意方提供响应的缓存 private 只能针对个人用户，而不能被代理服务器缓存 no-cache 强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断 资源是否变更，是则返回新内容，否则返回304，未变更 max-age 缓存服务器不对资源的有效性进行确认，max-age数值代表资源保存为缓存的最长时间 2. connection 控制不再转发给代理的首部字段 upgrade:http/1.1 connection:upgrade 代理服务器：删除upgrate字段======&gt;源服务器 管理持久连接（持久连接：只要任意一方不明确说明那么就不断开链接(长连接)） connection:close http 1.1以前的都是非持久连接，如果要在旧版本保持持久连接，则指定connection为Keep-Alive 3. Date 表示创建http报文的日期和时间 4. Tralier事先说明在报文主体后记录了哪些首部字段（在报文最后写了很重要的东西，记得仔细阅读哦）Trailer:Expires(报文主体)expirs:一个日期 过程 5. Transfer-Encoding：传输报文主体时采用的编码方式 6. Upgrade用指定的协议进行通信注意 :这个字段仅限于客户端和临界服务器，就是中间不能有别的代理服务器啥的，所以通常还要额外指定connection:upgrade字段 过程 7. Via追踪客户端与服务器之间的请求和响应报文的传输路径 过程 8.warning警告与缓存相关的警告 过程 二、请求首部字段1.Accept告知服务器用户能处理的媒体类型和优先级，用q=来表示优先级 （；） 进行分割，范围0-1 2.Accept-Charset通知服务器用户代理支持的字符集和顺序Accept-Charset:iso-8859-5,unicode-1-1;q=0.8 3.Accept-Encoding通知服务器客户端支持的内容编码和优先级就4种：gzip、compress、deflate、identity 4.Accept-language客户端能处理的自然语言集Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3 5.Authorization认证信息，权限认证 6.Expect期待服务器出现某种特定行为,如果服务端无法理解客户端的期望发生错误时，会返回 417状态码 过程 7.From用户的电子邮箱地址 8.Hosthost地址 9.IF-Matchif-xxx的都可以称为条件请求只有当if-match字段值和etag值匹配一致时，服务器才会接受请求否则返回412 precondition failed 10.If-Modified-Sinceif-xxx的都可以称为条件请求表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则304状态码，从本地资源缓存读取 11.If-None-Matchif-xxx的都可以称为条件请求只有在这个字段的值与ETag不一致时，可处理该请求，与if-Match相反 12.if-range这个涉及到断点续传,如果这个字段的值满足条件，range头字段才会起作用这个字段可以用ETag验证，也可以用last-modified 验证如果验证失败则返回全部资源 200状态码 13.if-unmodified-Since与if-modified-since相反，告知服务器只有在这个时间点后未发生了更新才处理请求，如果发生了更新，则412(precondition failed)状态码返回 14.Max-Forwards指定可经过的服务器最大数目，过一个服务器就减1，直到为0时返回 过程 15.Referer请求的URI是从哪个web页面发起的 过程 16.TE告知服务器客户端能够处理响应的传输编码方式和优先级TE:gzip,deflate;q=5 17.User-Agent客户端浏览器信息 三、响应首部字段1.Accept-Ranges当不能处理范围请求时，Accept-Ranges:none(就是不支持断点续传204)Accept-Ranges:bytes 支持 2.Age:如果是源服务器：告知客户端多久前创建了响应，单位秒缓存服务器：指缓存后的响应再次发起认证到认证完成的时间 3.ETag:资源标识，每个资源都会有，资源更新时，ETag也会更新。这个相对last-modified和Expires优先级最高 强ETag值：不论实体发生多么细微的变化都会改变其值 弱ETag值：只有资源发生了根本的改变，产生差异时才会改变，这时会在字段开始处附加W/ ETag:W/“asdf” 4.Location:重定向（302&amp;301）如果是这俩状态码，就会读取这个location来确定要跳转的页面,注意别的状态码浏览器不会跳转 5.Proxy-Authenticate注意：这是在代理服务器和客户端之间进行认证的这个字段会把代理服务器所要求的的认证信息发送给客户端 6.Retry-After告知客户端多久之后再次发送请求，可以是秒数也可以是具体日期，配合503和3xx使用，试验了一下啥用没有，有的浏览器还不支持 7.server告诉客户端服务器安装的http服务器应用程序和信息Server:Apache/2.2.6 (unix) PHP/5.2.5Server: nginx 过程 8.Vary（参数是首部字段）关系 客户端—— 代理服务器———–源服务器代理服务器接收到源服务器包含Vary的响应后，如果客户端发送包含相同Vary指定的首部字段的请求，那么使用缓存，即便相同的资源如果没有Vary也要重新获取资源比如： 过程 实例 9.WWW-Authenticate书上说 401 Unauthorized 状态码响应中，肯定会带有这个首部字段，我试验了一下，发现返回401的时候，并没有带这个首部 四、实体首部字段（在请求和响应两房的报文中都包含有与实体相关的首部）1.Allow通知客户端能支持的所有HTTP方法：比如：Allow：GET,HEAD,如果遇到不支持的方法，那么返回405 Method Not Allowed 2.Content-EncodingContent-Encoding:gzip告知客户端，服务器对实体的主题部分选用的内容编码方式内容编码是指在不丢失实体信息的前提下所进行的压缩有四种编码方式： gzip，compress，deflate，identity 3.Content-Language实体主题使用的自然语言（中文、英文...） 4.Content-Length (字节)表明实体主题部分的大小，对实体主体进行编码传输时，不能再使用content-length 5.Content-Location（也没遇见过）给出与报文主体对应的URI 6.Content-MD5 （从来没遇见过）客户端对接收的报文主体执行相同的MD5算法，然后与首部字段的值比较，目的是检查报文主体是否传输的完整Content-MD5:SALDFJKHIJKNB UIJKNDSHIO234DF== 7.Content-Range针对范围请求，返回响应时的首部字段，告知客户端返回的是那部分的范围，断点续传断点续传 8.Contnet-Type实体主体的媒体类型 类型 9.Expires:将资源失效的日期告诉客户端，缓存服务器接收到含有expires的响应后，会使用缓存max-age优先级大于这个 10.last-modified资源最终修改的时间 最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间 而且如果源服务器有资源删除后重新生成，内容不变，这时这个字段也会变化","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"http状态码","slug":"http状态码","date":"2019-11-15T03:42:16.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2019/11/15/http状态码/","link":"","permalink":"http://yoursite.com/2019/11/15/http状态码/","excerpt":"","text":"1XX101 Switching Protocols客户端发送带有首部字段Upgrade的字段，告知服务器通信协议发生改变服务端返回 101 Switching Protocols，之后的通信不再采用HTTP，而采用Upgrade指定的方式 2XX200 ok含义 ：成功处理 204 no content 含义 ：服务器接受的请求已成功处理，但是在相应报文中不包含实体的主体部分（就是没有返回数据），浏览器不刷新页面也不导向新的页面 举例： form表单等如果返回 204，那么页面不刷新 a的href如果返回 204，那么页面不跳转 206 partial content含义 ：返回一部分内容（分片请求数据） 请求头限定范围 ：Range: bytes=0-1024 。 头部字段说明响应头 :响应头Content-Range表示文件真实大小12Content-Range: bytes 557056-6160883/6160884Content-Length: 5603828 请求头:1Range: bytes=557056- Range: bytes=startOffset-targetOffset/sum [表示从startOffset读取，一直读取到targetOffset位置)每次要续传时，先读取已下载文件的字节大小比如100000，然后 rang：100000-，就可以继续下载 Range: bytes=startOffset-targetOffset [字节总数也可以去掉] 应用：断点续传，大文件下载，迅雷，百度 3XX301：永久重定向含义： 该状态码表示请求的资源已被分配了新的uri，也就是会做一个跳转后台 12res.writeHead(302,&#123;'Location': '/'&#125;);res.end(); 记住：url重定向是在浏览器端完成的，url的重定向与状态码和location有关，浏览器先判断状态码是否为301或302时，才会根据location响应头内容进行跳转，上面的代码里，如果返回的状态码是别的比如200啥的，那么浏览器不会跳转 302：临时重定向临时跳转，不是永久性的 区别从 SEO 角度，302 跳转，搜索引擎仍然保留原来的地址，301 跳转，则会保留跳转后的地址 303：see other请求的资源存在另一个uri，应该使用get方法定向获取请求的资源 理解：这和302似乎很像，举个例子比如我要用post请求创建一个用户admin，到了后台发现admin已经存在，那返回个303和location位置，然后浏览器用get去请求admin的位置（响应头location里返回） 资源已存在 304：not modified资源找到了，但不符合条件，不返回任何主体 理解：当触发协商缓存时，就返回304一段悄悄地对话浏览器：我来找2019年后更新的A数据服务器：A数据2019年后没更新过啊，304走你浏览器：从（浏览器）缓存中读取 4XX：bad request 客户端错误请求报文中存在语法错误，当错误发生时，需要修改请求内容后再次发送 401 unauthorized一般是客户端需要认证（登录状态失效等） 412 precondition failed响应状态码 412 Precondition Failed（先决条件失败）表示客户端错误，意味着对于目标资源的访问请求被拒绝。这通常发生于采用除 GET 和 HEAD 之外的方法进行条件请求时无法进行请求（通常是上载或修改资源，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下 403 forbidden你介个用户没有权限访问指定资源的权限 404 not found没找到请求资源 405 Method Not Allowed服务端不支持这种HTTP方法 5XX 服务端错误500服务端有bug或错误 503 service unavailable服务器停机或超载维护","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"iphone拍照获取位置信息的原理","slug":"iphone拍照获取位置信息的原理","date":"2019-11-04T02:43:07.000Z","updated":"2021-01-25T10:48:26.377Z","comments":true,"path":"2019/11/04/iphone拍照获取位置信息的原理/","link":"","permalink":"http://yoursite.com/2019/11/04/iphone拍照获取位置信息的原理/","excerpt":"","text":"前言最近在做一个桌面应用，大致就是对图片备份分类等动能，iphone如果打开GPS的话，拍摄的照片时是可以显示地理位置的，我也想做一个同样的功能，做的过程中有几个关键点，这里记录一下 一、关于GPS 实际操作： 如果拿到了照片的GPS直接去腾讯、高德、百度地图中反查的话，地理位置偏差大概会有几百米，这肯定是不正常的，手机的GPS精度比这个精准多了，所以要找找到定位偏差的根本，是啥呢？ 原因： 关于坐标，手机的GPS坐标是WGS84，这个标准谷歌地球和非中国的谷歌地图在用（谷歌中国不是），但是中国的地图都是用的GCJ-02（火星坐标系，在标准上偏差几百米），腾旭，高德等中国的地图都是用的这个格式，在WGS84基础上加密来的，BD09 百度地图使用的坐标，在GCJ-02基础上二次加密来的 结论： 原来是标准不一样的问题，那我首先把获得的GPS转成标准为GCJ-02的坐标，然后用这个坐标反查地理位置，那我的问题又来了，如下 二、关于地理位置iphone图片库根据地理位置和时间分类这个设计体验非常好，那我既然获得了GPS，我也想获得位置，可是我这个位置是需要 连网 的啊，需要调用腾讯或者高德等API的，那如果我一次上传100张照片我都要获取位置，那就得请求100次API，所以我想有没有本地获取位置的方法，而且我好像发现在iphone中拍完照片就会有位置信息的吧，所以我做了一个测试，看看iphone是怎么实现获取位置信息的 三、实验 目的： 我的目的是探明iphone拍照片获取地理位置是否需要联网 试验 关闭网络 ，或者开启飞行模式，拍张照片，然后去图库里看，是否记录了位置信息，如图 关闭网络 而且开启网络后，地理信息会附加上 开启网络 ，操作同上，如图 开启网络 四、结论iphone拍照获取街道地址这一步的操作是请求是靠连接网络获取的ps：iphone的地图源是高德和tomtom","categories":[],"tags":[{"name":"GPS","slug":"GPS","permalink":"http://yoursite.com/tags/GPS/"},{"name":"地图定位","slug":"地图定位","permalink":"http://yoursite.com/tags/地图定位/"}]},{"title":"被遗忘的废墟","slug":"被遗忘的废墟","date":"2019-09-25T06:43:57.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2019/09/25/被遗忘的废墟/","link":"","permalink":"http://yoursite.com/2019/09/25/被遗忘的废墟/","excerpt":"","text":"一、背景时间：2019中秋节地点：王平煤矿（已废弃）这个视频是在今年中秋节去王平煤矿探险时拍摄的，王平煤矿东临永定河，西依九龙山系，景色非常优美，永定河水的干净程度打破了我对北京河水刻板的印象。从煤矿出来后想拍几张照片，但是碍于时间紧迫便作罢。王平煤矿建设投产于1958年，1994年关闭，是我国建国初期国家大力支持发展第一产业时期修筑的煤矿企业，有着“京西八大矿”之一的称号，这里的矿井口昼夜不停地吞吐着煤炭，年产优质煤达百万吨级，所以在逛的过程中，总是会联想当年这里的工人在这里辛勤劳作的样子，回过神来再看看今天的样子，心里就会感叹 ”兴亡谁人定，盛衰岂无凭。一夜风云散，变幻了时空“。视频里只展示了王平煤矿的冰山一角，有好多的地方没有进去，比如视频里透着恐怖气息的楼房等，总感觉这些建筑里透漏着一股寒意，关于这个煤矿关闭的原因，说是因为环境保护的需要，京煤集团宣布在2020年以前北京五大煤矿将全部关停。历史不停的发展，任何事物，不管是辉煌、没落，在历史的长河中也只是一片浪花，再过几十年、几百年，翻过这一页，谁又能记得这一切呢? 二、正文","categories":[],"tags":[{"name":"后期剪辑","slug":"后期剪辑","permalink":"http://yoursite.com/tags/后期剪辑/"}]},{"title":"景别","slug":"景别","date":"2019-09-17T10:07:29.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2019/09/17/景别/","link":"","permalink":"http://yoursite.com/2019/09/17/景别/","excerpt":"","text":"一、景别 大远景（extreme long shot）：可以看到人物的全身以及许多前景和背景，通常人物在画面里只有银幕高的二分之一或更小 远景（long shot）:可以看到主角的脸 全景（full shot）：全身的全，画面的高度刚好可以囊括主角的身高 中景（medium shot）：涵盖人物腰部以上到头部的画面 （人物对白或访谈 类） 中特写（medium close up）：人物胸口到头顶，拉近观众与主角距离，但又不是很近 特写（close up）：被摄物体沾满画面，展现它的细节（脸） 大特写（extreme close up）：被摄物体局部放大的画面，用来建立冲击感 二、不属于景别 过肩镜头（over shoulder shot）：两人对话过肩拍摄 过头镜头（over shoulder shot）：过头拍摄 大仰拍 仰拍 俯拍","categories":[],"tags":[{"name":"后期剪辑","slug":"后期剪辑","permalink":"http://yoursite.com/tags/后期剪辑/"},{"name":"拍摄","slug":"拍摄","permalink":"http://yoursite.com/tags/拍摄/"}]},{"title":"前端知识点","slug":"前端知识点","date":"2019-09-17T06:42:40.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2019/09/17/前端知识点/","link":"","permalink":"http://yoursite.com/2019/09/17/前端知识点/","excerpt":"","text":"一、JavaScript一、[‘1’, ‘2’, ‘3’].map(parseInt) ？ [1,NaN,NaN] parseInt(string, radix)，字符串转十进制整数 string：必需。要被解析的字符串。radix : 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 解析的时候，\u001cparseInt会认为 string 参数是 radix 进制的，比如：parseInt(3,4) ,这里会认为“3”是 4进制的，所以当遇到这种情况:parseInt(3,2), 会认为这里的“3”是二进制的，那么3的二进制是3吗？不是啊，是 “11”啊 ，所以会返回NaN 二、防抖和节流下面我都用的 函数属性timer作为记录定时器的变量，其实也可以在函数内声明一个变量 1. 防抖实现 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间, 比如窗口缩放事件 window.resize12345678function debounce(fn,time)&#123; return function()&#123; clearTimeout(fn.timer) fn.timer=setTimeout(()=&gt;&#123; fn.apply(this, arguments) &#125;,time) &#125;&#125; 问：为啥用apply?答：改变函数this指向问：为啥要改变fn的this指向？如果不apply这个this又指向谁？要是不改有啥影响？卒~ 解析：首先要明白一件事情，this的指向问题，this的指向只是与如何调用这个方法有关，看几个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253a=&#123; m:function()&#123; console.log(this) &#125;&#125;----------------------------------------------1. a.m() // a&#123;&#125; 对象----------------------------------------------2. var b=a.m; m() // 指向全局对象，这里是window----------------------------------------------3. a.s=function()&#123; setTimeout(function()&#123; console.log(this) &#125;)&#125;// 注意这里setTimeout我用的是 普通函数，this指向全局对象，这里指向window4. a.s=function()&#123; setTimeout(()=&gt;&#123; console.log(this) &#125;)&#125;// 因为用了箭头函数，这里的this指向上一层this，即a对象3、4 注意对比----------------------------------------------5. 在函数里面执行a.mfunction c()&#123; a.m()&#125;// a对象6.function m()&#123; console.log(this)&#125;a.c=function()&#123; m()&#125;a.c() // window5、6 注意对比，这俩都是函数里面的函数执行。因为里面函数里面的函数并不是作为一个方法所调用，所以指向的是window，注意与 5 做对比---------------------------------------------- 看完上面例子，你就知道了setTimeout里如果用箭头函数，那么this是当前作用于，但是 fn() 这样执行的时候，里面的this指向全局，所以要给这个fn绑定当前执行环境的this，以避免一些因为作用域问题引起bug 2. 节流实现高频事件触发，但在n秒内只会执行一次123456789function debounce(fn,time)&#123; return function()&#123; if(fn.timer)return fn.timer=setTimeout(()=&gt;&#123; fn.apply(this, arguments) clearTimeout(fn.timer) &#125;,time) &#125;&#125; 三、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？阮一峰es6 四、深度优先遍历和广度优先遍历12345678910111213141516&lt;div class=\"parent\"&gt; &lt;div class=\"child-1\"&gt; &lt;div class=\"child-1-1\"&gt; &lt;div class=\"child-1-1-1\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"child-1-2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"child-2\"&gt; &lt;div class=\"child-2-1\"&gt;&lt;/div&gt; &lt;div class=\"child-2-2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"child-3\"&gt; &lt;div class=\"child-3-1\"&gt;&lt;/div&gt; &lt;div class=\"child-3-2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1. 深度优先遍历12345678910function deepTraversal(node)&#123; let result=[] result.push(node) if(node.children)&#123; for(let i =0,length=node.children.length;i&lt;length;i++)&#123; result=result.concat(deepTraversal(node.children[i])) &#125; &#125; return result&#125; 深度优先遍历 2. 广度优先遍历123456789101112131415function widthTraversal(node)&#123; let result=[] let stack=[] let cd=undefined stack.push(node) while(cd=stack.shift())&#123; result.push(cd) if(cd.children)&#123; for(let i =0,length=cd.children.length;i&lt;length;i++)&#123; stack.push(cd.children[i]) &#125; &#125; &#125; return result&#125; 广度优先遍历 五、深拷贝函数12345678function deepCopy(obj) &#123; if (typeof obj != 'object') return obj let newValue = obj.constructor.name == 'Array' ? [] : &#123;&#125; for (let i in obj) &#123; newValue[i] = typeof obj[i] == 'object' ? deepCopy(obj[i]) : obj[i] &#125; return newValue&#125; 六、事件循环js中的栈和堆分别存储值类型和引用类型执行栈和上面的栈意义不同，当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。 事件循环 js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起（浏览器去执行），继续执行执行栈中的其他任务。当一个异步事件返回结果后（注意是异步有了返回结果后，将回调函数添加到事件队列），js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕(这也是为什么setTimeout 时间不会非常精确的原因)， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 事件循环 callback queue：事件队列webAPIs ：异步操作（浏览器执行）stack:执行栈 七、宏任务和微任务异步事件也分宏任务和微任务，他们执行顺序的优先级不同宏任务:setTimeout、setInterval、I/O、UI 渲染微任务:Promise、MutaionObserver同一次事件循环中微任务比宏任务优先级高 执行顺序执行队列空闲=&gt;检查微任务队列=&gt;检查宏任务队列1234567891011setTimeout(function () &#123; console.log(1);&#125;);new Promise(function(resolve,reject)&#123; console.log(2) resolve(3)&#125;).then(function(val)&#123; console.log(val);&#125;)// 2,3,1 执行过程script进入主线程开始执行同步代码，将异步操作交给浏览器执行，所以先将setTimeout挂起，然后打印 2 ，遇到了promise则挂起，此时任务队列空闲（这时异步操作都已经执行完加入了事件队列），那么去检查事件队列，先检查微任务队列，好，发现了 promise的then回调，执行 ，打印3，微任务队列空了，检查宏任务队列 打印1 ，此时执行栈为空 ,退出 比较特殊的例子1234567891011121314async function async1()&#123; console.log('1'); await async2(); console.log('2')&#125;async function async2()&#123; console.log('3')&#125;console.log('4');async1();console.log('5')// 4，1，3，5，2 async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行也就是 await async2()后面（下面）的部分是放在了promise（微任务），async1 转换一下就是这样：123456async function async1()&#123; console.log('1'); return new Promise(resolve=&gt;resolve(async2())).then(e=&gt;&#123; console.log('2') &#125;)&#125; 可以看到 async2() 实在promise的executor（执行器）里同步执行的，所以是主线程 4 , async 1 ，async2 , 将console.log(2) 加入微任务， 主线程的 console.log(5)执行栈已经空闲，查看事件队列（优先微任务，然后宏任务） 输出2练习题，写出执行结果考点：就是事件循环、宏任务、微任务的执行顺序，上面说的弄明白了，就很容易了1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 八、for循环每隔1秒输出对应数值因为以前面试遇到过，所以就记录下来 async、await 12345678910async function a() &#123; for (var i = 0; i &lt; 10; i++) &#123; await new Promise((resolve, reject) =&gt; &#123; console.log(i); setTimeout(() =&gt; &#123; resolve(i) &#125;, 1000) &#125;) &#125;&#125; 闭包，这种方式的缺陷就是第一次其实是有间隔时间的，而上面是马上输出的 123456789function b() &#123; for (var i = 0; i &lt; 10; i++) &#123; (function(i) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000 * i) &#125;)(i) &#125;&#125; let/const,原理是每次循环let或const形成了自己的局部作用域 1234567function b() &#123; for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000 * i) &#125;&#125; 九、编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 方法一 1[...new Set(arr.flat(Infinity))].sort((a,b)=&gt;a-b) 方法二 1234567891011function flat(arr)&#123; let result =[] for(let i in arr)&#123; if(typeof arr[i]=='object')&#123; result=result.concat(flat(arr[i])) &#125;else&#123; result.push(arr[i]) &#125; &#125; return result.sort((a, b) =&gt; a - b)&#125; 十、new的时候发生了啥 || 实现一个new1234567891011/*@param constructor被new的类（构造函数）*/function new2(constructor)&#123; //创建一个实例对象o，并将该对象原型（__proto__）指向func（构造函数）的原型对象 var o = Object.create(constructor.prototype); //将o作为构造函数的this执行构造函数 var k= constructor.call(o); // 如果构造函数返回值是引用类型则将实例对象o代替 return typeof k==='object' ? k : o; &#125; 十一、检测js类型这个问题都快要问烂了，一般都是说 Object.prototype.toString.call(参数) ，可是为什么要用这种方式？先列出来我知道的几种方式 typeof缺点：不能判断出来数组，对象 , undefined，null 因为它们都返回object 参数.constructor.name缺点：不能检测undefined，null Object.prototype.toString.call(参数)这种方式很全面，但是为什么要用Object的原型？Array ，function 继承了Object，但重写了 toSting，可以验证一下12345delete Array.prototype.toString&gt; truea=[]a.toString()&gt; \"[object Array]\" 十二、模板编译解析模板1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 解析函数12345678910111213141516171819202122232425262728function compile(template)&#123; let m=template.replace(/&lt;%=(.+?)%&gt;/g,' `) \\n echo(`$1`) \\n echo(`').replace(/&lt;%(.+?)%&gt;/g,'`) \\n $1 \\n echo(` ') m='echo(` '+m+ '`)' // 要解析成这样 // echo('&lt;ul&gt;') // for(let i=0; i &lt; data.supplies.length; i++) &#123; // echo('&lt;li&gt;') // echo(data.supplies[i]) // echo('&lt;/li&gt;') // &#125; // echo('&lt;/ul&gt;') // 这个需要加小括号，否则eval解析不出来 let script = `(function parse(data)&#123; let outHtml='' function echo(html)&#123; outHtml+=html &#125; $&#123;m&#125; return outHtml &#125;)` return eval(script)&#125;let x = compile(template)x(&#123; supplies: [ \"broom\", \"mop\", \"cleaner\" ] &#125;) 十三、补全字符串12345// 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"'xxx'.padEnd(4, 'ab') //\"xxxa\" 附加知识点 二、CSS一、什么是包含块？怎么确定包含块？一个元素的大小和位置要依据一个矩形框来设置，这个矩形框就是包含块 1. 确定包含块一个元素的包含块完全依赖于这个元素的position属性 如果postion属性为static/relative,包含块就是他最近的祖先块元素的内容区的边缘组成的（注意是块元素哦）下面几条注意了，是内边距的外边缘(边框的内边缘)，而不是内容区域边缘了,上面的是内容区边缘 如果position属性为absolute,包含块就是由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的外边缘组成。 如果position属性是fixed，包含块是viewport(浏览器中就是window，可视区域) 如果position属性是 absolute/fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的外边缘组成的 transform或perspective属性（不为none） 剩下几条都是些浏览器不怎么兼容的属性，略 参考链接 2. 根据包含块定位像 margin/position:absolute 这类的元素，如果设置百分比，则会根据它的包含块的大小来计算定位ps: margin不管是 margin-top还是margin-left等都是根据 父元素宽度来计算的 css的offsetParent 指的是祖先元素中已经定位（position/transfrom/perspective）的元素，如果没有就是 bodycss的parentNode 指的是父级元素 二、块级格式化上下文BFCBFC隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素创建BFC： 元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 比如：123&lt;div id='box' style='margin-top:10px'&gt; &lt;div id='son' style='margin-top:5px'&gt;&lt;/div&gt;&lt;/div&gt; 这种情况实际上会发生外边距重叠（浏览器试一下就明白），实际我想要不让它们重叠，也就是box里的元素不要影响到外面或者外面的元素属性不要影响到里面，那么给box创建一个BFC即可 三、块级元素的垂直居中123&lt;div class=\"f\"&gt; &lt;div class=\"s\"&gt;sadf&lt;/div&gt;&lt;/div&gt; 子元素必须固定大小 123456789101112131415.f&#123; position:relative; width: 200px; height: 400px;&#125;.s&#123; width:100px; height:100px; margin:auto; position:absolute; top:0; left:0; right:0; bottom:0;&#125; 子元素宽高没有限制 12345678910.f&#123; position:relative; width: 200px; height: 400px;&#125;.s&#123; position: absolute; top: 50%; transform: translate(-50%,-50%);&#125; 子元素宽高没有限制 123456789.f&#123; display: table-cell; vertical-align: middle; width: 200px; height: 400px;&#125;.s&#123; margin:auto;&#125; 子元素要固定大小 1234567891011.f&#123; width: 200px; height: 400px;&#125;.s&#123; position: absolute; top: 50%; left: 50%; height: 100px; margin: -50px 0 0 -50px;&#125; 子元素宽高没有限制 1234567.f&#123; width: 200px; height: 400px; display: flex; justify-content: center; align-items: center;&#125; 子元素宽高没有限制 12345678.f&#123; display: grid; align-content: center; justify-content: center; /* align-content: center; justify-content: center; */&#125;","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"实现一个promise","slug":"实现一个promise","date":"2019-09-10T03:35:22.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2019/09/10/实现一个promise/","link":"","permalink":"http://yoursite.com/2019/09/10/实现一个promise/","excerpt":"","text":"一、提问环节经过学习，学会了promise实现，但是有一点不懂， 就是 _resolve、_reject 里面为什么用异步？ setTimeout(run, 0); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221/* * @Description: 实现一个promise * @Author: ymbo * @Date: 2019-09-09 11:07:26 * @LastEditTime: 2019-09-11 17:49:59 * @LastEditors: Please set LastEditors */const PENDING = 'PENDING'const FULFILLED = 'FULFILLED'const REJECTED = 'REJECTED'class myPromise &#123; constructor(handle) &#123; // 判断handle是否为函数 if (typeof handle !== 'function') &#123; throw new Error('handle must be a function！') &#125; // promise状态 this._status = PENDING // 当前value值 this._value = undefined // 成功队列 this._fulfilledQueues = [] // 失败队列 this._rejectedQueues = [] try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (error) &#123; this._reject(error) &#125; &#125; // 成功 // 1.这个value也可能是一个promise，这个promise的状态和值都将赋给当前的value和status _resolve(value) &#123; // 如果不是pending状态则表示已完成，就不执行了 if (this._status !== PENDING) &#123; return &#125; let run = () =&gt; &#123; let runFulfilled = (val) =&gt; &#123; let cd = undefined // 当从pending变为fulfilled/rejected时，执行成功队列的内容 while (cd = this._fulfilledQueues.shift()) &#123; cd(val) &#125; &#125; let runRejected = (err) =&gt; &#123; let cd = undefined // 当从pending变为fulfilled/rejected时，执行成功队列的内容 while (cd = this._rejectedQueues.shift()) &#123; cd(err) &#125; &#125; if (value instanceof myPromise) &#123; value.then(val =&gt; &#123; this._value = val this._status = FULFILLED runFulfilled(val) &#125;, err =&gt; &#123; this._value = err this._status = REJECTED runRejected(err) &#125;) &#125; else &#123; this._value = value this._status = FULFILLED runFulfilled(value) &#125; &#125; setTimeout(run, 0); &#125; _reject(err) &#123; // 如果不是pending状态则表示已完成，就不执行了 if (this._status !== PENDING) &#123; return &#125; let run = () =&gt; &#123; // 状态变更 this._status = REJECTED // 值变更 this._value = err let cd = undefined // 当从pending变为fulfilled/rejected时，执行成功队列的内容 while (cd = this._rejectedQueues.shift()) &#123; cd(_value) &#125; &#125; setTimeout(run, 0); &#125; // then函数 // 1.then接受两个函数参数 // 2.then返回一个新的promsie // 3. then(onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this return new myPromise((resolve, reject) =&gt; &#123; let fulfilled = value =&gt; &#123; try &#123; // 如果then的第一个参数不是函数，则直接将值传递下去 if (typeof onFulfilled !== 'function') &#123; resolve(value) &#125; else &#123; let res = onFulfilled(value) // 如果res是一个promise，则需要等待这个promise执行完毕，再传递值 console.log('是一个promise', res instanceof myPromise) if (res instanceof myPromise) &#123; res.then(resolve, reject) &#125; else &#123; // 如果返回值是值类型,则直接传递下去 resolve(res) &#125; &#125; &#125; catch (error) &#123; resolve(error) &#125; &#125; let rejected = err =&gt; &#123; try &#123; // 如果then的第一个参数不是函数，则直接将值传递下去 if (typeof onRejected !== 'function') &#123; reject(err) &#125; else &#123; let res = onRejected(err) // 如果res是一个promise，则需要等待这个promise执行完毕，再传递值 if (res instanceof myPromise) &#123; res.then(resolve, reject) &#125; else &#123; // 如果返回值是值类型,则直接传递下去 reject(res) &#125; &#125; &#125; catch (error) &#123; reject(error) &#125; &#125; switch (_status) &#123; // 如果还在pending中就把函数放到指定队列里 case PENDING: this._fulfilledQueues.push(fulfilled) this._rejectedQueues.push(rejected) break; // 如果处于 fulfilled 则直接执行 case FULFILLED: fulfilled(_value) break; case REJECTED: rejected(_value) break; &#125; &#125;) &#125; finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) ); &#125; //catch catch (onRejected) &#123; return this.then(undefined, onRejected) &#125; // 静态resolve static resolve(value) &#123; if (value instanceof myPromise) &#123; return value &#125; else &#123; return new myPromise((resolve, reject) =&gt; &#123; resolve(value) &#125;) &#125; &#125; // 静态reject static reject(err) &#123; return new myPromise((resolve, reject) =&gt; &#123; reject(err) &#125;) &#125; //all // list内容可以是promise 或者其他 static all(list) &#123; return new myPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = [] let count = 0 for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then(res =&gt; &#123; values[i] = res count++ // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values) &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err) &#125;) &#125; &#125;) &#125; static race(list) &#123; return new myPromise((resolve, reject) =&gt; &#123; for (let [i, p] of list.entries()) &#123; this.resolve(p).then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; &#125;) &#125;&#125;","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"colorful","slug":"colorful","date":"2019-09-02T02:38:34.000Z","updated":"2021-01-25T10:48:26.375Z","comments":true,"path":"2019/09/02/colorful/","link":"","permalink":"http://yoursite.com/2019/09/02/colorful/","excerpt":"","text":"一、前言本来是想多拍点的，可是刚到地方，好友以手机没电为由非要回去，我只能匆匆拍了几个素材，而且去的时候是中午，太阳很足，就更加疲惫了，所以前期拍摄的视频素材并不是太多，所以结果只有大约一分半钟最好选择超清观看，360p看的太难受了上次的《视频demo》我是通过传到github上，然后通过video标签播放了，果然这种免费的博客太水了，上传慢不说，播放还要等一年，所以这次用了bilibili的播放器，因为我比较喜欢bilibili的播放器 二、正文 三、总结最后的时候有些镜头晃动的幅度太大，没剪好应该撇掉一些晃动幅度大的素材换成比较稳素材，这样配合音乐，静谧、五彩缤纷、自然的这种感觉会更强烈最奇怪的是，正常拍的是1920 x 1080 的视频，我用了慢动作拍摄，视频大小竟然是 1280 x 760的，好奇怪，回头再研究一下准备把上一个视频也换成bilibili的源了，要不太难用了","categories":[],"tags":[{"name":"后期剪辑","slug":"后期剪辑","permalink":"http://yoursite.com/tags/后期剪辑/"}]},{"title":"视频demo","slug":"视频demo","date":"2019-08-25T09:11:17.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2019/08/25/视频demo/","link":"","permalink":"http://yoursite.com/2019/08/25/视频demo/","excerpt":"","text":"iphone premiere 好友 一、效果 二、知识点 超级慢动作效果 注意：因为速度放慢的原因会导致视频看起来卡顿效果，所以放慢的同时要选择 时间插值&gt;光流法 这个选项会把空帧用算法补全，不过用这个的话，视频里不能有太多杂色，否则会有这种效果 信号损坏效果（片头文字和0:00:01-0:00:02） 位置： 视频效果&gt;扭曲&gt;波形变形 注意：我选择的是波形类型是正方形和杂色，正方形模拟信号最不好的时候，杂色模拟信号快恢复的时候，偏移角度每一帧要有变动 rgb颜色分离（3D色差失真） 位置： 视频效果&gt;图像控制&gt;颜色平衡（RGB）&amp;&amp;不同明度&gt;混合模式 选择滤色 视频复制两次，每一次的视频RGB三个通道选择一个单一通道，比如第一个视频R:100 G:0 B:0,第二个R:0 G:100 B:0,第三个个R:0 G:0 B:100，然后通过变换每个视频的位置，大小等形成色差 看图： 缩放镜头模糊转场（00:00:00:21） 位置： 视频效果&gt;扭曲&gt;变换（缩放&amp;&amp;快门角度&amp;&amp;关闭是用合成的快门角度） 为了看起来更流畅 三、总结 运动里的操作和变换里的操作有什么区别？运动只能用在视频片段上，不能用在调整图层上 快门角度？0-360指的是曝光时间","categories":[],"tags":[{"name":"后期剪辑","slug":"后期剪辑","permalink":"http://yoursite.com/tags/后期剪辑/"}]},{"title":"文字镂空效果","slug":"文字镂空效果","date":"2019-08-19T09:51:18.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2019/08/19/文字镂空效果/","link":"","permalink":"http://yoursite.com/2019/08/19/文字镂空效果/","excerpt":"","text":"一、前言闲逛苹果官网的时候，看到一个效果： iphoneXR 在粗略的看过实现以后，想当然的认为不就是文字设为透明，然后加一个背景么。正好今天有空，测试了一下，发现竟然没有想的那样，所以切记眼高手低，在仔细分析实现方式后，终于找到了原因，共有两点收获 二、效果实现1. html首先html的实现是没有异议的123&lt;div class='bg'&gt; &lt;p&gt;测试文字&lt;/p&gt;&lt;/div&gt; 2. css关于css用到了两个点 @supports @supports CSS at-rule 关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件. demo 123456@supports (animation-name: test) &#123; … /* 如果支持不带前缀的animation-name,则下面指定的CSS会生效 */ @keyframes &#123; /* @supports是一个CSS条件组at-rule,它可以包含其他相关的at-rules */ … &#125;&#125; background-clip: text","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"axios源码分析","slug":"axios源码分析","date":"2019-06-10T03:38:32.000Z","updated":"2021-01-25T10:48:26.373Z","comments":true,"path":"2019/06/10/axios源码分析/","link":"","permalink":"http://yoursite.com/2019/06/10/axios源码分析/","excerpt":"","text":"一、前言其实一开始是不想看源码的，但是之前有次使用axios的cancel取消请求功能后，对这一块的实现比较好奇，就决定看一下源码这一部分的实现，但是看着看着最后还是需要看axios主要功能的实现，所以就有了这篇文章。我画了一个关于axios的流程图，源码配合这个流程图看能让脑中有一个整体的架构，对axios的结构更清晰 1.1、流程图说明流程图分为图片版和html在线交互版 html交互版 name 优势 劣势 图片版 加载相对较快（其实也挺慢2M的图） 图片质量有限 html版 提供好的交互，图示更清晰 加载相对较慢（加载过一次后由于缓存的原因会快很多） 1.2、流程图预览 tip：在新标签页中打开更清晰哦 图片版axios流程图 二、关键点Axios 是一个基于 promise 的 HTTP 库，所以阅读源码前对Promise的了解程度很重要 axios Promise队列 三、流程 axios的cancel取消请求的实现 以及拦截器原理 node和web环境的适配都在上面的导图里清晰的说明了,进入html交互版或上面的图片版仔细查看","categories":[],"tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"git版本回退","slug":"git版本回退","date":"2019-05-29T03:36:19.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2019/05/29/git版本回退/","link":"","permalink":"http://yoursite.com/2019/05/29/git版本回退/","excerpt":"","text":"一、版本回退 file可以用“.”代替，表示所有文件 1.丢弃工作区修改git checkout -- file 2.丢弃暂存区git reset HEAD &lt;file&gt;后，会将指定文件回退到工作区 3.回退版本库3.1、回退且暂存区、工作区保存修改git reset --soft commit–soft参数告诉Git重置HEAD到另外一个commit，但也到此为止。如果你指定–soft参数，Git将停止在那里而什么也不会根本变化。这意味着暂存区,工作区都不会做任何变化，所有的在original HEAD和你重置到的那个commit之间的所有变更集都放在暂存区区域中。工作区=暂存区!=版本库 tip:仅把改动内容回退到暂存区 soft 3.2、回退且丢弃修改git reset --hard commit回退到commit版本且，从HEAD到另外一个commit之间的所有修改都会被丢弃，现在暂存区，工作区，版本库的内容都是commit这个点的内容工作区=暂存区=版本库 hard 3.3、回退且保存修改到工作区git reset --mixed commit参数默认，可以不写原理同上，只不过修改会保存在工作区，暂存区会跟版本库一致工作区!=暂存区=版本库 mixed","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"记录一次git操作（git远程仓库地址变更）","slug":"记录一次git操作","date":"2019-05-26T03:55:36.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2019/05/26/记录一次git操作/","link":"","permalink":"http://yoursite.com/2019/05/26/记录一次git操作/","excerpt":"","text":"背景项目远程仓库地址是A，将项目以名称为appclone在本地，而且在服务器上也以项目名称为appclone。由于一些原因，将远程仓库A迁移到远程仓库B,所以需要将远程服务器app的仓库地址由A改为B，但由于服务器的一些程序的限制，app文件名称不可以变，只需要变动里面的项目内容 远程仓库，有三次提交记录 远程仓库 本地仓库 本地仓库 仓库地址 一、仓库迁移1. 将A仓库镜像到B仓库名称为old仓库迁移到了名称为new仓库里 新的仓库地址 2.本地额外提交到old仓库两次记录 old仓库的提交记录 new仓库的提交记录 可以看到old仓库领先new仓库两次提交 远程服务器仓库的提交记录 3. 将new仓库内容与old仓库内容同步因为old里面内容较新，所以讲old文件同步到new上，并且同步后再提交一次记录到new上 远程服务器仓库的提交记录 4. 将服务器仓库的地址变更为new仓库地址并更新4.1. 服务器地址切换 远程服务器仓库地址切换 4.2. 服务器git pull 远程服务器git pull 可以看到更新失败需要手动处理冲突，其实关键就在这里如果服务跑一个程序比如说web服务，这些文件是web页面，那么此时web页面就会展示错误，因为文件里有待解决的冲突，那怎么解决呢？ 二、解决方案其实下面1、2方法在一定程度上是一个意思 1. 方法1服务器clone最新的new仓库到app的同级目录，然后将本来存在的app删除，并将new仓库改名为app即可（mv也可以改名） 2. 方法2服务器clone最新的new仓库到app的同级目录，将new文件下的.git 隐藏文件（工作区）移动到app文件下替换app的.git，git reset –hard HEAD^后git pull即可 3 git remote -set-url origin &lt;新地址&gt; 首先git remote -set-url origin &lt;新地址&gt; git fetch（拉取更新但不合并） git reset –hard origin/master （用远程服务器的origin/master替换本地、暂存区、版本库） tip: 当更新仓库的时候用 git pull ，但是git pull 包含了两个操作 ，git fetch 和git merge,git fetch 是将远程的master（默认）分支存储到本地的origin/master命名空间中，不会进行合并但是有时候我们想用远程仓库的内容完全替换到本地的容：git reset –hard origin/master撤销本地、暂存区、版本库(用远程服务器的origin/master替换本地、暂存区、版本库) 总结上面说了这么一大堆，其实都是我实际中遇到的坑坑，差点坑死我，不过上面说的确实是很麻烦，所以再总结一下问题：切换远程分支避免遇到merge，或者说怎么更好的切换远程分支并更新解决方案：上面三种","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"linux命令nohup和&区别","slug":"linux命令nohup和-区别","date":"2019-01-15T06:27:22.000Z","updated":"2021-01-25T10:48:26.377Z","comments":true,"path":"2019/01/15/linux命令nohup和-区别/","link":"","permalink":"http://yoursite.com/2019/01/15/linux命令nohup和-区别/","excerpt":"","text":"一、前言因为我想把一个程序一直运行在centos系统上，后来的知 nohup ，&amp; 命令都可以，在网上查找资料后，对这些资料进行整理，让这两条命令的异同更直观的展现出来 二、nohup命令nohup 是 no hang up 的缩写,不挂断的意思 语法：nohup Command [ Arg … ] [ &amp; ]作用：不挂断的运行指定程序下面我会按照 nohup command &gt; myout.file 2&gt;&amp;1 这条命令进行拆分讲解 1、nohup command 不挂起的执行 command 程序,当 ctrl+c 的时候会退出 command 程序 （因为对SIGINT信号不免疫） 2、 &gt; myout.file 2&gt;&amp;1 标准输出和标准错误都打印到当前目录下的myout.file文件里 如果直接执行 nohup command 没有后面的一串，那么将在当前目录自动创建 nohup.out文件，并shell中提示 appending output to nohup.out，输出都将附加到这个文件里。 如果没有当前目录创建文件的权限，那么输出重定向到跟目录下的 /nohup.out 文件中， 如果没有文件能创建或打开以用于追加，那么那么 Command 参数指定的命令不可调用（执行失败） 2.1、问题1： 2&gt;&amp;1 什么意思？操作系统中有三个常用的流： 0：标准输入流 stdin 1：标准输出流 stdout 2：标准错误流 stderr一般当我们用 &gt; console.txt，实际是 1&gt;console.txt的省略用法；&lt; console.txt ，实际是 0 &lt; console.txt的省略用法。补充 :&gt; console.txt 每次执行会覆盖文件内容，使用 &gt;&gt; console.txt 进行追加，则console.txt不会被覆盖 有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2&gt;1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&amp;进行区分。就有了 2&gt;&amp;1 这样的用法 这句话意思是把标准错误（2）重定向到标准输出中（1），而标准输出又导入文件myout.file里面，所以结果是标准错误和标准输出都导入文件myout.file里面了 2.2、问题2： 为何2&gt;&amp;1要写在&gt;myout.file后面？command &gt; file 2&gt;&amp;1 首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。command 2&gt;&amp;1 &gt;file 2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。 3、例子：执行jenkins服务nohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8088 &gt; /Users/admin/nohup.out 2&gt;&amp;1 启动jenkins,并将输出导入到文件nohup.out里 执行结果 可以看到执行成功了，新建窗口 再看看日志文件打开 /Users/admin/nohup.out 这个文件： 文件内容 结论：控制台没有输入jenkins的启动信息 4、关闭当前终端 关闭启动jenkins的终端 结论 ：可以看到关掉终端不会关闭jenkins进程 5、注意注意！ctrl+c可以从执行结果图看到，任务开始后终端是不能输入的，那我执行 ctrl+c 让终端编程可输入状态会发生什么呢？ 执行ctrl+c后任务结束了 可以看到任务结束！！ 结论：ctrl+c使jenkins进程结束了 6、 nohup总结 nohup Command [ Arg … ] [ &amp; ]:程序运行不挂起，默认会将输出重定向nohup.out文件中，也可以自定义输出文件，ctrl+c的话会退出a.sh进程（因为对SIGINT信号不免疫），关闭Command, Command进程还是存在的（对SIGHUP信号免疫） 三、&amp;命令1、command &amp;让command程序在后台运行 2、还以jenkins为例子测试 启动jenkins 结论：控制台输出了jenkins的启动信息 3、执行ctrl+c 执行ctrl+c 结论：ctrl+c不会使jenkins进程停止 4、关闭当前终端 关闭当前终端 结论：关闭终端会使jenkins进程停止 5、补充这时我突然想到了，上面介绍了 &gt;a.txt 这样可以把信息输入到a.txt文件里，那可不可以 Command &gt;a.txt &amp;这样用呢？java -jar jenkins.war --ajp13Port=-1 --httpPort=8088 &gt; /Users/admin/nohup.out 2&gt;&amp;1 &amp; 猜想测试 结论：command &gt;a.txt &amp;可以不在终端输出信息 6、&amp;总结 Command &amp; :&amp;的意思是在后台运行， 当你在执行 Command &amp; 的时候， 即使你用 ctrl+C, 那么Command照样运行（因为对SIGINT信号免疫）。 但是要注意， 如果你直接 关掉终端 后， 那么，Command进程同样消失（因为对SIGHUP信号不免疫）。 四、表格对比 命令方式 ctrl+c关闭后进程是否关闭 直接关闭终端后进程是否关闭 是否终端输出信息 nohup 关闭 不关闭 不输出，无论是否加上 &gt;nohup.out，信息都被导入到nohup.out（指定）文件 &amp; 不关闭 关闭 默认输出，但加上&gt;nohup.out则会不输出，信息被导入到nohup.out（指定）文件 五、实际应用鉴于它们个自的优缺点，一般都是这样用nohup command &gt; myout.file 2&gt;&amp;1 &amp;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Django开发安装MySQL-python解决过程","slug":"Django开发安装MySQL-python解决过程","date":"2018-12-19T09:52:13.000Z","updated":"2021-01-25T10:48:26.372Z","comments":true,"path":"2018/12/19/Django开发安装MySQL-python解决过程/","link":"","permalink":"http://yoursite.com/2018/12/19/Django开发安装MySQL-python解决过程/","excerpt":"","text":"一、前言这篇文章写的是我安装 MySQL-python遇到的问题，因为使用django开发所以我要和MySQL数据库连接，然后就死活安装不上，各种报错，折腾了一天多，终于解决了，趁着现在还有点印象，赶紧写下来，做个记录 1.问题描述django新建一个mysite项目，将数据库设置为MySQL，然后执行 pip install MySQL-python 安装数据库模块开始遇到的问题 2. 环境 macOS 10.13.6django 1.11.17python 2.7.10 二、解决问题历程 执行 pip install MySQL-python 报错 百度后说需要安装 mysql-connector-c 1brew install mysql-connector-c 如果有这种报错 那就按提示的输入命令解决（应该是brew unlink mysql），然后再次安装mysql-connector-c安装完后记得 安装成功后执行一次brew link mysql 安装 Command Line Tools 这个去苹果官网下就可以了 100多兆，网上说要下xCode，但是我没下xCode也成功了安装上这个了，所以不用下xCode就可以，终端输入 which gcc 查看 这时安装MySQL-python 肯定依然报错，反正我是这样 ，然后执行 export CC=’/usr/bin/gcc’export CFLAGS=’-isysroot/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk -I/opt/X11/include -arch i386 -arch x86_64’export LDFLAGS=’-arch i386 -arch x86_64’export ARCHFLAGS=’-arch i386 -arch x86_64’ 我也不知道这啥意思，惭愧惭愧。。。 安装 MySQL-python，还会报这个错误 这里要说明一下 之前我的mysql是通过下载dmg包那种方式安装的，但是现在没办法我卸载mysql后又用brew方式安装了一下，版本为 8.0.12 Homebrew 修改mysql配置文件：mysql_config 1234112 # Create options113 libs=&quot;-L$pkglibdir&quot;114 #libs=&quot;$libs -l &quot; ##注释掉源代码115 libs=&quot;$libs -lmysqlclient -lssl -lcrypto &quot; ##修改成这样 安装 MySQL-python 如果你的还报错，那我只能说再百度吧 ，离安装成功不远了， 因为我安装的时候也是疯狂报错，现在我回想的可 能不太全，因为我解决了好久 好了 现在安装好了MySQL-python ,然后执行 pip install MySQL-python， 妈的依然提示Did you install mysqlclient or MySQL-python? 好，在django根目录init.py文件里写上 12import pymysqlpymysql.install_as_MySQLdb() 执行pip install MySQL-python 报错 ImportError: No module named pymysql 然后安装 pip install pymysql 再次执行 python manage.py migrate 终于成功了，我差点哭出来 去数据库看，对应的表已经创建了","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"身份认证-jwt","slug":"身份认证-jwt","date":"2018-09-27T12:39:51.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2018/09/27/身份认证-jwt/","link":"","permalink":"http://yoursite.com/2018/09/27/身份认证-jwt/","excerpt":"","text":"一、jwt简介关于jwt的概念网上有很多非常好的博客讲解，在这里就不解释了，看下面内容之前最好对jwt有个大致的了解。这里讲的是前后台怎么利用jwt进行身份验证。（react+axios+node） 二、基本逻辑1. 后台逻辑前台 /login 路由进入后，在账号密码正确的前提下创建一个 token(附带上过期时间等)，返回给前台，后续前台的每次请求，都需要经过后台的一个中间件来判断 token是否过期或者有误，如果有误，返回错误信息 2. 前台逻辑前台收到返回信息后，将token存储在localStorage或者cookie里，然后后续的每次的请求带上这个token 3.附加其实除了每次的请求要附带token检查有效之外，还需要在路由跳转的时候进行token检查，下面会说到三种方法 三、 后台代码所使用的包： express-jwt //用来验证token jsonwebtoken //用来生成token给客户端 当/login进入的时候，生成token返回12345678910111213141516171819202122232425262728//jwt.sign(payload, secretOrPrivateKey, [options, callback])// 登录exports.login = function(req, res) &#123; const &#123; user, pwd &#125; = req.body; UserModel.findOne(&#123; user: user, pwd: utility.md5(md5Pwd(pwd)) &#125;, &#123; pwd: 0 &#125;, (err, doc) =&gt; &#123; if (err) &#123; console.log(err) return res.json(&#123; code: 1, msg: '未知错误' &#125;) &#125; if (!doc) &#123; return res.json(&#123; code: 1, msg: '用户不存在或密码错误' &#125;) &#125; // 生成token // secretOrPrivateKey：用\"YMBo's club\"字符串加密 let token = jwt.sign(&#123; name: 'job', &#125;, \"YMBo's club\", &#123; expiresIn: 1 * 60 //过期时间1分钟 &#125;) return res.json(&#123; code: 0, data: doc, token &#125;) &#125;)&#125; /login后返回信息 每次有路由请求的时候对token判断是否过期添加一个中间件：123456789101112131415161718192021222324const expressJWT = require('express-jwt')const secret = \"ymb's club\"app.set(secret, secret)// jwt验证app.use(expressJWT(&#123; secret: secret&#125;, &#123; expiresIn: 60&#125;).unless(&#123; path: ['/user/login'] &#125;))// jwt验证,如果有错误（token不对，过期等错误）app.use(function(err, req, res, next) &#123; if (err.name === \"UnauthorizedError\") &#123; res.status(401).send(&#123; code: 1, msg: '请登录' &#125;); &#125;&#125;);app.use(bodyParser.json())app.use('/user', userRouter) 这里有一个关键点，当使用express-jwt进行token验证的时候，前台发过来的token必须是带 Bearer前缀的，比如token是aaa.bbb.ccc，那么应该格式化为 Bearer aaa.bbb.ccc 这种形式 四、 前台代码123// setLocalStorage是自定义的方法，存储tokensetLocalStorage('Authorization', `Bearer $&#123; res.data.token &#125;`)// 后台返回正确信息后 将token 存储在localStorage里 在项目的总入口或者次级入口加上这个，意思是后续的每一次axios请求都将携带Authorization信息1axios.defaults.headers.common['Authorization'] = getLocalStorage('Authorization'); 五、验证token1. 第一种方法上面说了后台添加中间件 express-jwt 来验证，网上的好多教程说的是通过一个单独的路由 /info，每次请求的时候先请求这个路由是否过期等，但是我觉得这种方法太浪费了，何必每次请求都要发送这个 /info这个验证请求呢 2. 第二种方法1234jwt.decode（token [，options]） //解密，注意了之前存储到localStorage里的token是带 Bearer 要把它去掉进行解密。//返回解码没有验证签名是否有效的payload。警告：这不会验证签名是否有效。它只是返回后端设置的payload// 特点：不用secretOrPrivateKey进行解密 前台的顶层路由（就是进别的路由都要经过的路由）进行判断，怎么判断呢？用 jsonwebtoken 这个包(上面用到过) 进行解密，然后取出设定的 expiresIn 过期时间，然后取到本地时间戳，与这个进行判断，看是否过期。 3. 第三种方法12345678910111213jwt.verify（token，secretOrPublicKey，[options，callback]）//验证token合法性// 去掉了Bearer let token = getLocalStorage('Authorization').replace(/Bearer\\s/, '');jwt.verify(token, \"ymb's club\", (err, decoded) =&gt; &#123; if (err) &#123; alert('过期了快去登录') this.props.history.push('/login') &#125;&#125;)//如果token没用了 直接返回err//用到了secretOrPrivateKey：用\"YMBo's club\"字符串解密，注意这个字段一定要和后台那个加密字段一致，否则它一致err 六、效果查看过期时间我设置的1分钟，为了方便调试 /login 返回token成功 返回token成功 后台express-jwt验证token成功 后台express-jwt验证token成功 路由跳转前验证token成功 路由跳转前验证token成功","categories":[],"tags":[]},{"title":"vue自定义父子组件组件v-model的通信","slug":"vue自定义父子组件组件v-model的通信","date":"2018-09-25T02:38:15.000Z","updated":"2021-01-25T10:48:26.379Z","comments":true,"path":"2018/09/25/vue自定义父子组件组件v-model的通信/","link":"","permalink":"http://yoursite.com/2018/09/25/vue自定义父子组件组件v-model的通信/","excerpt":"","text":"一、前言前些天写一个checkbox的vue组件的时候想用v-model来进行状态的判断，但是想到这了，却不知道v-model怎么在组件里面实现，这篇文章记录v-model的实现以及v-model的扩展。具体效果可以参考iview的 Checkbox组件和CheckboxGroup组件 二、分析 (功能描述)我想做两个组件 第一个叫 ButtonSelect 、 ButtonSelectGroup ButtonSelect : 其实这个组件就是一个checkbox复选框，只不过样式上进行的修改，我想在这上面绑定v-model，通过v-model来告诉父级组件当前的复选框状态(true/false)，ButtonSelect 的效果同iview的 Checkbox组件 CheckBox组件效果 ButtonSelectGroup : 当有多个 ButtonSelect 的时候，可以用 ButtonSelectGroup包裹ButtonSelect，然后通过 ButtonSelectGroup 上绑定 v-model ，来获得所有的选中项，格式是数组，效果同iview的 CheckboxGroup CheckboxGroup组件效果 三、关于v-modelv-model 双向绑定是一个很好用的功能，对于不同的组件v-model返回值也不同,但是这里只说说 checkbox复选框的v-model 单个复选框，绑定到布尔值 多个复选框，绑定到同一个数组官网描述 这里一定要仔细观察，当多个复选框的时候它的v-model的值是一样的，只有这样才能返回数组，而数组每一项的值就是checkbox的value值 1.自定义v-model（v-model传递）父组件===&gt;子组件：默认名为value的prop子组件===&gt;父组件：默认名为input的事件通过 value 和 input 来完成v-model的赋值和传递 但是有时候我们不想用value的input进行传递，name可以用model选项自定义：1234model: &#123; prop: 'checked', event: 'change'&#125;, 这样就变成了 prop为change 和 checked事件来代替value和input了 四、ButtonSelect的实现最顶级的组件ButtonSelectGroup、ButtonSelect的父组件，就叫他HelloWord组件12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;ButtonSelectGroup v-model=&quot;select&quot;&gt; &lt;ButtonSelect label=&apos;第一个&apos; &gt;&lt;/ButtonSelect&gt; &lt;ButtonSelect label=&apos;第二个&apos;&gt;&lt;/ButtonSelect&gt; &lt;ButtonSelect label=&apos;第三个&apos;&gt;&lt;/ButtonSelect&gt; &lt;/ButtonSelectGroup&gt; &#123;&#123;select&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ButtonSelect from &quot;./ButtonSelect.vue&quot;;import ButtonSelectGroup from &quot;./ButtonSelectGroup.vue&quot;;export default &#123; name: &apos;HelloWorld&apos;, components:&#123; &apos;ButtonSelect&apos;:ButtonSelect, &apos;ButtonSelectGroup&apos;:ButtonSelectGroup &#125;, data()&#123; return&#123; select:[] &#125; &#125;,&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;style&gt;@keyframes ani &#123; 0% &#123; background-color: #52c41a; -webkit-box-shadow: 0 0 5px #52c41a; box-shadow: 0 0 5px #52c41a; &#125; 50% &#123; background-color: #73d13d; -webkit-box-shadow: 0 0 10px #73d13d; box-shadow: 0 0 10px #73d13d; &#125; 100% &#123; background-color: #95de64; -webkit-box-shadow: 0 0 5px #95de64; box-shadow: 0 0 5px #95de64; &#125;&#125;.selectBut&#123; display: flex; flex-wrap: nowrap; margin: 5px; border-radius: 5px ; line-height: 30px; height: 30px; position: relative;&#125;.selectBox&#123; display: inline-block; overflow: hidden;&#125;.con&#123; padding:0 5px; box-shadow: 0 0 8px 0px #88d6f7; background: -webkit-linear-gradient(left,#5ec8ff,#4a9fd7); background: -o-linear-gradient(left,#63e77d,#3e8aa6); background: -moz-linear-gradient(left,#63e77d,#3e8aa6); background: linear-gradient(left,#63e77d,#3e8aa6);&#125;.check&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; cursor: pointer; opacity: 0; width: 100%; height: 100%; box-sizing: border-box; padding: 0; margin: 0;&#125;input.check:checked+.light&#123; /* background: #19be6b; */ animation: ani 3s infinite alternate;&#125;.num&#123; padding: 0 5px; border-radius:0 5px 5px 0; color: #fff; font-weight: bold; text-shadow: 0 -1px 1px #40a9ff; /* box-shadow: 0 0 8px 0px #88d6f7; */ background: -webkit-linear-gradient(left,#4a9fd7,#2d60a2); background: -moz-linear-gradient(left,#3e8aa6,#2c5d9d); background: -o-linear-gradient(left,#3e8aa6,#2c5d9d); background: linear-gradient(left,#3e8aa6,#2c5d9d);&#125;.lightbox&#123; position: relative; width: 20px; height: 100%;&#125;.light&#123; transition:all .5; background: #ccc; height: 100%; cursor: pointer; border-radius: 5px 0 0 5px;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;selectBox&quot;&gt; &lt;div class=&quot;selectBut&quot;&gt; &lt;div class=&quot;lightbox&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check&quot; :checked=&quot;currentValue&quot; @change=&quot;change&quot;/&gt; &lt;div class=&quot;light&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;con&quot;&gt; &lt;slot name=&quot;con&quot;&gt;ssss&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;num&quot;&gt; &lt;slot name=&quot;num&quot;&gt;aaa&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&apos;ButtonSelect&apos;, data()&#123; return&#123; //根据v-model初始化当前组件状态 currentValue:this.value &#125; &#125;, props:&#123; // v-model获取 value:&#123; type:[Array,Boolean], default:false &#125; &#125;, methods:&#123; change(event)&#123; var value=event.target.checked; // 赋值v-model this.$emit(&apos;input&apos;,value) &#125; &#125;&#125;&lt;/script&gt; 关键点： template的 inputscript:props的value和data里currentValue（获得初始状态）script: change里this.$emit(‘input’) 单个的复选框组件基本功能完成 五、ButtonSelectGroup组件实际应用中ButtonSelect会有很多个，我需要获取每一个的选中状态或者值（参考上面的CheckBoxGroup组件） 1. 分析 让多个checkbox返回数组的原理是什么？ 上面提到了，是给每一个checkbox相同的model，所以就要在父组件（ButtonSelectGroup）里给所有子组件（ButtonSelect）相同的v-model 当所有的子组件其中有一个改变的时候，应该给父组件返回变化后的数组，父组件（上面提到了，是给每一个checkbox相同的model，所以就要在父组件（ButtonSelectGroup）里给所有子组件（ButtonSelect）设置相同的v-model）再将该数组通过input事件返回给ButtonSelectGroup的调用者(ButtonSelectGroup的父组件)，完成v-model的传递 当ButtonSelectGroup的父组件给定一个初始v-model值的时候，需要把每一个ButtonSelect进行状态的变换 2. 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 寻找子组件function findComponentsDownward (context, componentName) &#123; return context.$children.reduce((components, child) =&gt; &#123; if (child.$options.name === componentName) components.push(child); const foundChilds = findComponentsDownward(child, componentName); return components.concat(foundChilds); &#125;, []);&#125;export default &#123; name:&apos;ButtonSelectGroup&apos;, props:&#123; value:&#123; type:Array, default()&#123; return [] &#125; &#125; &#125;, data()&#123; return&#123; childrens:[], &#125; &#125;, mounted()&#123; this.updateModel() &#125;, methods:&#123; updateModel()&#123; this.childrens = findComponentsDownward(this, &apos;ButtonSelect&apos;); if(this.childrens)&#123; const &#123; value &#125;=this; // 给子组件设置相同的model this.childrens.forEach(child=&gt;&#123; child.model=value; child.group = true; &#125;) &#125; &#125;, change(data)&#123; // 通知上级组件的v-model this.$emit(&apos;input&apos;,data); &#125; &#125;, watch: &#123; value () &#123; this.updateModel(); &#125; &#125;&#125;&lt;/script&gt; 注意注意注意 这里有一个非常非常非常重要的点，就是这个watch里面这个value监听触发updateModel方法，你可以尝试去掉这个watch是什么结果。我就在这里卡了好久。来解释一下原因：来一起想一下，子组件(ButtonSelect)的model是他爹(ButtonSelectGruop)给的，每次我点击了 ButtonSelect会通过this.parent.change(this.model) 来告诉父组件去更新使用的HelloWord里的 select，好了此时此刻我已经更新完了HelloWord里的 v-model(select),但是注意子组件（ButtonSelect）的v-model是通过 父组件 （ButtonSelectGroup）赋值过来了，并不能直接更改，所以ButtonSelectGruop如果不加 watch的value监听的话，子组件的v-model永远是[]，所以可以在ButtonSelect change的时候打印一下，每次数组一定是一个值，所以要用过watch监听，每一次HelloWord的v-model变动，都要重新给ButtonSelect赋值一次，这样才能达到预期目的 不加watch的样子： 不加watch 加watch的样子： 加watch 五、总结上面什么input事件、默认value什么的都还好理解，最最最重要的点就是上面说的watch来监听value，听我这么说可能云里雾里，需要自己动手实践一下，才能明白其中的意思","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"python格式化字符","slug":"python格式化字符","date":"2018-08-09T03:38:07.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2018/08/09/python格式化字符/","link":"","permalink":"http://yoursite.com/2018/08/09/python格式化字符/","excerpt":"","text":"一、前言本文是我初学python对格式化字符操作中的一些相对疑难问题的记录和理解 二、python中格式化方法format1.简单用法对于format最简单的用法就是这样了123name='YMBo'age=18print '&#123;0&#125; is &#123;1&#125; years old'.format(name,age) 输出为 YMBo is 18 years old 对于这种字符串拼接也可以用这种方式：123name='YMBo'age=18print name+' and '+str(age) 注意！这种方式的字符串拼接类型都要为 str，所以age这一项要转为str，而format这中方式就不用 2.复杂用法123name='YMBo'print('lalallala :&#123;0:3&#125;'.format(name))# &#123;0:3&#125; 0：这里的 0 表示第几个参数，这里只有一个所以是 0 3：这个3表示输出宽度，如果输出宽度小于字符串宽度则最后输出宽度为字符串宽度 123name='YMBo'print('lalallala :&#123;0:^3&#125;'.format(name))# &#123;0:^3&#125; 这里多了个 ^表示右对齐 12print('lalallala :&#123;0:.3f&#125;'.format(1.0/3))# &#123;0:.3f&#125; 0表示第一个参数 ：后面没有数字表示宽度则自动分配 .3表示小数点后3位 f表示按照浮点数输出 12print(' :&#123;0:_^100.3f&#125;'.format(1.0/3))# &#123;0:.3f&#125; 这里的下滑线是填充文本 总结对比一下，python字符串格式化操作和JavaScript很相似的都有两种方式1.字符串和变量++++这种操作，但是python需要将不是str类型的变量转为str类型，而js不用2.python中’{}’.format()，js中`${}`这种操作","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"webpack配置代码分割","slug":"webpack配置代码分割","date":"2018-05-21T10:05:27.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2018/05/21/webpack配置代码分割/","link":"","permalink":"http://yoursite.com/2018/05/21/webpack配置代码分割/","excerpt":"","text":"一、前言webpack 4.0 使用 optimization.splitChunks.cacheGroups 配置项来进行包的拆分，其实默认情况下，webpack是会自动帮我们分割的，但是有时候我们可能也需要自定义配置，下面来说下我对这个配置项的理解，如有错误，烦请指出 二、配置项说明 cacheGroups 用这个配置项来自定义生成的文件 test 限制范围，可以是正则，匹配文件夹或文件 name 生成的文件名 priority 优先级，当有chunks满足多个分组条件的时候，优先选择优先级高的 minSize 分出来的包最小尺寸必须大于此值，默认30000B minChunks 表示分离前被引用次数,默认为1 maxInitialRequests 最大初始化加载次数，一个入口文件可以并行加载的最大文件数量，默认1 maxAsyncRequests 最大按需加载次数，最大异步加载次数，默认1 enforce: true 优先处理，这一项好像和priority有些重叠了 reuseExistingChunk:true 表示可以使用已经存在的块，即如果满足条件的块已经存在就是用己有的的，不再创建一个新的块 chunks 值为”initial”, “async”（默认） 或 “all” initial 入口chunk，对于异步导入的文件不处理 async 异步chunk，只对异步导入的文件处理 all 全部chunk 12.1234567891011121314151617181920runtimeChunk: &#123; name: 'manifest' /* 管理被分出来的包，runtime 指的是 webpack 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单， 模块信息清单在每次有模块变更(hash 变更)时都会变更 */&#125;,cacheGroups:&#123;//设置缓存chunks priority: 0,//缓存组优先级 //当需要优先匹配缓存组的规则时，priority需要设置为正数，当需要优先匹配默认设置时，缓存组需设置为负数，0为两者分割线 default:&#123;//设置缓存组默认配置，可通过default:false禁用默认缓存组， //然后就可以自定义缓存组，将初始化加载时被重复引用的模块进行拆分 minChunks:2,//引用两次 priority:-20,//缓存组优先级为-20 reuseExistingChunk:true,//表示可以使用已经存在的块，即如果满足条件的块已经存在就是用己有的的，不再创建一个新的块 &#125;， [key]:&#123;//自定义缓存组，可以根据需求，自由创建 chunks:'initial', test: /vue/,//正则规则验证，如符合就提取chunk放入当前缓存组，值可以是function、boolean、string、RegExp，默认为空 enforce: true//优先处理 &#125;&#125; 三、疑难配置项 maxInitialRequests :这个配置项我一直很不理解，网上的很多资源都是千篇一律，有用的基本没有，后来我发现了这篇文章 关于webpack模块拆分规则 让我有对这个配置项有了点浅显的了解 现在说说我的理解，举个小例子：这是一个多页应用，index.js和shop.js是入口文件我的目录结构： 目录结构 ； 这是webpack分割代码1234567891011121314151617181920212223runtimeChunk: &#123; name: 'manifest'&#125;,splitChunks: &#123; cacheGroups: &#123; //项目公共组件 common: &#123; chunks: 'initial', name: 'common', minChunks: 2, maxInitialRequests: 3, //最大初始化加载次数，一个入口文件可以并行加载的最大文件数量，默认1 minSize: 0 //表示在分离前的最小模块大小，默认为0，最小为30000 &#125;, //第三方组件 vendor: &#123; test: /node_modules/, chunks: \"initial\", name: \"vendor\", priority: 10, enforce: true &#125; &#125;&#125; 现在先别急着看分包结果，先来分析一下：其中除了React、ReactDOM是第三方包以外剩下的都是自定义组件 index.js(入口文件)：React、ReactDom、index.jsx(index目录下)shop.js(入口文件)：React、ReactDom、index.jsx(shop目录下)index.jsx(shop目录下)：React、Header.jsx、A.jsx、B.jsx、shop.cssindex.jsx(index目录下)：React、A.jsx、index.cssA.jsx：React、Common.cssB.jsx：React、b.css、common.css那么画出的依赖图就是这个样子： 目录结构 这里来自 node_modules 的包肯定是被打包到 vender 里了，不用管这个，主要是看 common 这个包的信息 暂且忽略掉maxInitialRequests这个配置（当然代码里是不能忽略的因为有默认值，想象这一项不起作用就行了），如果按照使用次数超过2次，大小超过0的包，打包到一起，那么结果是这样的： Common（chunks）：A.jsx、Common.cssvender（chunks）：第三方shop.js（chunks）：Header.jsx、B.jsx、b.css、shop.cssindex.js（chunks）：index.css 那么此时的maxInitialRequests（初始加载次数）是：shop页入口：shop.js、vender、Common 一共三次 index页入口：index.js、vender(chunks)、Common 一共三次 如果此时我限制了 maxInitialRequests：2 为2的话，那么结果是这样的 vender（chunks）：第三方shop.js（chunks）：Header.jsx、B.jsx、b.css、shop.css、A.jsx、Common.cssindex.js（chunks）：index.css、A.jsx、Common.css shop页入口：shop.js、vender 一共两次 index页入口：index.js、vender一共两次看截图： maxInitialRequests：2的情况 maxInitialRequests：3或大于三的情况 可以看到以上的分析是正确的 四、总结不过话说会来，如果每次配置wepback的这一项都按这么分析，那得累死，可以这么分析，每次页面初始加载我想让它的并发请求不超过自己的预期就可以了","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack4.0中的mode和.babelrc的env.development配置项目","slug":"webpack4-0中的mode和-babelrc的env-development配置项目","date":"2018-04-12T06:29:57.000Z","updated":"2021-01-25T10:48:26.379Z","comments":true,"path":"2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","link":"","permalink":"http://yoursite.com/2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","excerpt":"","text":"一、前言之前写过怎么在webpack中使用react-hot-loader做热更新功能，不得不说是真的非常麻烦，今天发现了更好用的办法来记录一下 1.这篇文章讲的什么？1.更简单的配置 热更新的方法2.webpack4.0的mode配置项有啥用？3.babelrc中的env.development是干啥的？ 二、热更新注意，本部分着重讲解的是热更新，至于上面提到的2和3放在下个部分webpack.config.js的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const webpack=require('webpack')const opn=require('opn')const merge=require('webpack-merge')const path=require('path')const baseWebpackConfig=require('./webpack.base.config')const webpackFile=require('./webpack.file.config')const htmlWebpackPlugin=require('html-webpack-plugin')let config=merge(baseWebpackConfig,&#123; mode:'development', output:&#123; path:path.join(webpackFile.devDirectory), filename:'js[name].[hash].js', publicPath:'' &#125;, plugins:[ /*热更新*/ new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin(&#123; template:path.join(__dirname,'../template/index.html') &#125;) ], module:&#123; rules:[ &#123; test:/\\.(js|jsx)$/, use:'babel-loader', include:[ path.join(__dirname,'../client') ], exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, devServer:&#123; host:'0.0.0.0', port:'8888', hot:true, overlay:&#123; errors:true &#125;, contentBase:path.join(__dirname,webpackFile.devDirectory), historyApiFallback: true, proxy:[ &#123; context:['/api'], target:'localhost:8888', secure: false &#125; ], /*打开浏览器*/ after()&#123; opn('http://localhost:'+this.port) &#125; &#125;&#125;)module.exports=config; .babelrc 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; package.json文件的启动命令1\"dev\": \"webpack-dev-server --config build/webpack.dev.config.js\" 现在配置热替换仅需三个步骤 webpack中devServer.hot=true webpack中plugins添加new webpack.HotModuleReplacementPlugin() ‘.babelrc’文件中使用 react-hmre （npm i babel-presets-react-hmre）预设 配置完成是不是很简单？看看执行结果 hmr 三、webpack4.0的mode配置项有啥用？mode配置项会告诉webpack使用相应的内置优化 webpack运行时还会根据mode设置一个全局变量process.env.NODE_ENV,这里的process.env.NODE_ENV不是node中的环境变量,而是webpack.DefinePlugin中定义的全局变量,允许你根据不同的环境执行不同的代码. 参数： 选项 描述 development Provides process.env.NODE_ENV with value development. Enables NamedChunksPlugin and NamedModulesPlugin. production Provides process.env.NODE_ENV with value production. Enables FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin and UglifyJsPlugin. 从网上找到了更详细的优化说明列出了针对这两种情况做的对应优化development1234567891011121314151617181920//调试devtool:eval//缓存模块, 避免在未更改时重建它们。cache:true//缓存已解决的依赖项, 避免重新解析它们。module.unsafeCache:true//在 bundle 中引入「所包含模块信息」的相关注释output.pathinfo:true//在可能的情况下确定每个模块的导出,被用于其他优化或代码生成。optimization.providedExports:true//找到chunk中共享的模块,取出来生成单独的chunkoptimization.splitChunks:true//为 webpack 运行时代码创建单独的chunkoptimization.runtimeChunk:true//编译错误时不写入到输出optimization.noEmitOnErrors:true//给模块有意义的名称代替idsoptimization.namedModules:true//给模chunk有意义的名称代替idsoptimization.namedChunks:true production1234567891011121314//性能相关配置performance:&#123;hints:\"error\"....&#125;//某些chunk的子chunk已一种方式被确定和标记,这些子chunks在加载更大的块时不必加载optimization.flagIncludedChunks:true//给经常使用的ids更短的值optimization.occurrenceOrder:true//确定每个模块下被使用的导出optimization.usedExports:true//识别package.json or rules sideEffects 标志optimization.sideEffects:true//尝试查找模块图中可以安全连接到单个模块中的段。- -optimization.concatenateModules:true//使用uglify-js压缩代码optimization.minimize:true 例如: 12345if(process.env.NODE_ENV === 'development')&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 最终将编译成 12345if(true)&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 生产环境下,uglify打包代码时会自动删除不可达代码,也就是说生产环境压缩后最终的代码为:1//生产环境 do something 四、babelrc中的env.development是干啥的？env选项可以针对特定环境进行设置。此env值会从process.env.BABEL_ENV中获取；如果该值不存在，会使用process.env.NODE_ENV；二者都不存在，使用默认值”development”。 启动命令设置process.env.BABEL_ENV1\"dev\": \"cross-env BABEL_ENV=development webpack-dev-server --config build/webpack.dev.config.js\" 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; 这样就会执行”development”下配置的内容","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react生命周期详解","slug":"react生命周期详解","date":"2018-03-27T09:11:54.000Z","updated":"2021-01-25T10:48:26.379Z","comments":true,"path":"2018/03/27/react生命周期详解/","link":"","permalink":"http://yoursite.com/2018/03/27/react生命周期详解/","excerpt":"","text":"一、react生命周期 componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentUnmount每个生命周期概念不是本文讲解重点，重点是生命周期在组件渲染时候容易造成的混淆 二、componentWillReceiveProps 和 componentWillUpdate ？？componentWillReceiveProps ： 组件接收到一个新的props会被调用，在初始化render时不会调用componentWillUpdate : 组件接收到系的props或state时被调用，初始化不会被调用 看起来好像一样啊，有什么区别呢？来看下面 1.来做测试先定义两个组件，App和Son，我们的目的就是看看上面提到的两个生命周期的不同，所以这一部分暂不讨论每个生命周期执行顺序，留在下一节讨论。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;App点我&lt;/button&gt; &lt;Son word=&#123;this.state.word&#125; /&gt; &lt;/div&gt; ) &#125;&#125;class Son extends Component&#123; constructor()&#123; super() this.state=&#123; word:'' &#125; &#125; componentWillMount()&#123; console.log('儿子生命周期：componentWillMount') this.setState(&#123; word:this.props.word &#125;) &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 逻辑很简单，父组件和子组件都可以通过各自的按钮改变子组件文字的内容 先点击 儿子按钮 按钮，也就是子组件Son里的按钮 执行结果 可以看到 componentWillReceiveProps 没有执行 然后点击 APP点我 按钮：点之前： 点之前 点之后： 点之后 可以看到子组件的文字并没有发生变化，执行了上图中的这些生命周期方法。 所以可以得到结论：componentWillReceiveProps触发条件是props更新，而componentWillUpdate触发条件是props或者states更新，上面说的时候也着重标记了 为了让父组件的按钮能更改子组件的内容，我需要在componentWillReceiveProps或componentWillUpdate里写上123this.setState(&#123; word:nextprops.word&#125;) 官网上说不能写在componentWillUpdate里，建议写在componentWillReceiveProps，我就不明白了，我非得写在componentWillUpdate里，看看执行结果 报错 看 死循环了，因为上面提到componentWillUpdate触发条件是 states 变化 和 props变化，写在了这里就不停的setState states的值，所以就不停的触发componentWillUpdate，因此像这种父组件更改子组件的内容应该写在 componentWillReceiveProps 里，来试试： ojbk 好，一切正常！ 总结： 名称 componentWillReceiveProps componentWillUpdate 触发条件 props变化 props或states变化 注意事项 setState的更新要写在componentWillReceiveProps里 三、生命周期执行顺序还是上面的例子 1.初始化时父子组件的声明周期执行顺序 结果 2.点击父组件的按钮时生命周期执行顺序 结果 3.点击子组件执行顺序 结果 4.还有一种情况，点击子组件触发父组件内容的更改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Son extends Component&#123; ponentWillMount()&#123; console.log('儿子生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; var word=this.props.word === '儿子' ? '孙子':'儿子' this.props.click(word) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:word &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;Son word=&#123;this.state.word&#125; click=&#123;this.handleClick.bind(this)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 结果 上述的几种执行结果也很简单，看一看就会执行顺序就会变得清晰了","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"body-parser使用注意","slug":"body-parser使用注意","date":"2018-03-08T07:53:13.000Z","updated":"2021-01-25T10:48:26.375Z","comments":true,"path":"2018/03/08/body-parser使用注意/","link":"","permalink":"http://yoursite.com/2018/03/08/body-parser使用注意/","excerpt":"","text":"一、前言这几天在学习服务端渲染的时候用到了这个包 body-parser ,很方便的一个包，这个模块提供了四种解析器 JSON body parser Raw body parser Text body parser URL-encoded form body parser 每一项详细的配置都能在网上找到，这篇记下的是我在使用中遇到的问题 bodyParser.json(option)和bodyParser.urlencoded(option)的不同，在网上搜这个问题，得到的答案还是让我一头雾水，终于试了几次并结合资料弄清楚两者的使用场景 二、区别看官方的解释：bodyParser.json(options)：中间件只会解析 json ，允许请求任意Unicode编码,支持 gzip 和 deflate 编码。 bodyParser.urlencoded(option)：中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。(tip:一般这一项是接收表单提交form) 三、例子看到这里我明白了一个接受form请求，一个接受json请求，好，我写了下面的例子：12345678910111213141516171819202122232425262728293031323334//server端关键代码var jsonParser =bodyParser.json();app.post('/login',jsonParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;)//客户端请求&lt;form method=\"post\" action=\"/login\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputTitle\" class=\"col-sm-3 control-label\"&gt;电影名称&lt;/label&gt; &lt;input id=\"inputTitle\" type=\"text\" name=\"title\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputLanguage\" class=\"col-sm-3 control-label\"&gt;海报&lt;/label&gt; &lt;input id=\"inputLanguage\" type=\"text\" name=\"poster\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt;&lt;button type=\"submit\" class=\"btn btn-default\"&gt;确定&lt;/button&gt;&lt;/form&gt;setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 客户端有一个用于测试的表单和一个1s后发送post请求的ajax 先看一下表单请求的结果： 表单请求 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到bodyParser.json()并没有解析到ajax和form表单请求，现在来换bodyParser.urlencoded(option)的解析方式12345var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);app.post('/login',urlencodedParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;) 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到这种解析方式成功将请求解析到了body里。到了这里，我又有疑问了，知道了bodyParser.urlencoded期望的数据形式，那bodyParser.json适用于什么情况呢？ 看下面例子，既然api说bodyParser.json适用于json的数据类型，所以我将ajax的content-Type设置为json 123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 请求结果： 返回结果 请求失败，那么疑问来了，我设置了json格式的请求，为什么bodyParser.json解析不了 关键： jq的ajax 默认的ContentType的值为:application/x-www-form-urlencoded; charset=UTF-8此格式为表单提交格式，数据为 key1=value1&amp;key2=value2的格式 虽然ajax的data属性值格式为:{key1:value1,key2:value2},但最后会转为key1=value1&amp;key2=value2的格式提交到后台 如果想传json格式数据，content-type设置好后，ajax必须将date属性值转为json字符串，不能为json对象（js对象，会自动转为key=value形式）,这样传输的时候才是json格式 我们来试一下：123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:JSON.stringify(&#123; url:'login', name:'123', password:123456 &#125;), success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 返回结果 现在就可以请求成功啦","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"mobx基本用法","slug":"mobx基本用法","date":"2018-03-06T01:59:46.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2018/03/06/mobx基本用法/","link":"","permalink":"http://yoursite.com/2018/03/06/mobx基本用法/","excerpt":"","text":"一、前言本文是我初学mobx时对mobx一些基本的认识，如果新发现会继续更新 二、redux和mobx相同点：都是用来管理JavaScript应用的状态，他们不一定要跟react结合使用，还可以与别的框架结合 不同点： redux学习成本相对于mobx成本要高很多，有reducer、action、dispatch等概念，规则多，比如更新数据必须要用 dispatch，更新的逻辑必须要用 action，刚学的时候可能有点懵。mobx比较自由，可以用obj.key 的方式更新 redux更新数据的时候，要将更新数据的整个对象替换为一个新的对象才可以触发更新(这点接触过redux的会有感受)，而mobx自始至终是一份引用，所以redux每次会触发很多的组件的重新渲染，为了优化会配合immutable。mobx则是更新哪个属性，仅仅这个属性所在的位置会重新渲染（不是组件的重新渲染，不触发componentWillMount等方法，会触发componentWillUpdata） 以上为自己理解，如有错误烦请指出 三、mobx基本概念 tip:以下提到的 @ 是ES7里的修饰器，可以到网上找资源学习 es7的修饰器 1. @observable 将属性转为可观察的，一旦发生变化，则变量所处的位置会立即发生变化 2. @computed这是一个有点不好理解的API，而且官网描述的也不是很清楚，下面是我的理解，如果有误，请指出讲这个API之前先看一下下面的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************mobx********************************/import &#123; observable ,computed,autorun,action &#125; from 'mobx'class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125;&#125;const appState = new AppState;setInterval(()=&gt;&#123; appState.add()&#125;,2000)export default appState;/************************************index.jsx********************************/import React,&#123; Component &#125; from 'react'import &#123;observer,inject&#125; from 'mobx-react'import PropTypes from 'prop-types'@inject('appState')@observerexport default class TopicList extends Component&#123; constructor()&#123; super() this.changeName=this.changeName.bind(this) &#125; componentWillUpdate()&#123; console.log('更新！') &#125; changeName(event)&#123; this.props.appState.changeName(event.target.value) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.changeName&#125;/&gt; &lt;span&gt;&#123;this.props.appState.msg&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;TopicList.propTypes=&#123; appState:PropTypes.object&#125; 逻辑是有两个变量 count和max，在msg的getter里判断max&gt;count的情况,其中max为固定值，count每秒+1。 在第二节的redux和mobx异同之处提出了mobx数据变化的时候组件只会触发 componentWillUpdata （没什么来源，自己试的），下面来看看上面代码 (mobx里msg部分加了 @computed) 运行情况： 可以看到只有当 msg 值发生变化的时候，才会触发 componentWillUpdata ，也就是前5s msg的结果一直为 true时，组件里是没有接收到新的 {this.props.appState.msg} 的（因为接受新的props值会触发 componentWillUpdata） 下面再来看看 mobx里msg部分不加 @computed 运行情况1234get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;`&#125; 不加 @computed 可以看到每一次的count值变化都会触发组件的componentWillUpdata 看明白了上面的例子和运行时的不同，再看看下面的总结就会好理解了 总结：如果使用了@computed （@computed msg getter()），那么msg的值将会被缓存，如果count的变化没有触发msg值的变话，那么msg的getter()值就不会改变，index.jsx组件也不会收到通知(componentWillUpdata)。（第一种情况） 如果不使用@computed属性，直接msg getter()的话，那么一旦count改变，所有用到msg getter()的地方都将重新计算(第二种情况)。 @computed的意义在于它能够由MobX进行更智能的优化 3. autorun 定义的 @observable 变量如果发生变化，autorun会自动执行相应的方法,例如将上面的mobx修改，index.jsx不变 1234567891011121314151617181920212223242526 import &#123; observable ,computed,autorun,action &#125; from 'mobx' class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125; &#125; const appState = new AppState;// 添加了 autorun autorun(()=&gt;&#123; console.log(`$&#123;appState.count&#125; 运行运行~`) &#125;) setInterval(()=&gt;&#123; appState.add() &#125;,1000) export default appState; 因为autorun里的函数依赖了 count ，所以每一次setInterval的时候，都会执行autorun里的函数 4. @action 如果要更新store里的内容，就要在相应的函数前加上 @action 例如上面的例子，标记为@action 。 作用：在mobx-react高级渲染性能优化小节中，我们知道，使用transaction可以将多个应用状态(Observable)的更新视为一次操作，并只触发一次监听者(Reactions)的动作(UI更新、网络请求等)，从而更大程度地提升应用的性能，避免多余的UI渲染和网络请求。action中封装了transaction，对函数使用action修饰符后，无论函数中对@observable变量（应用状态）有多少次修改，都只会在函数执行完成后，触发一次对应的监听者。如下代码，reset函数只会触发一次UI更新。 123456789101112class TodoItemModel &#123; id; @observable title; @observable completed; //使用action后，reset函数执行完成后，才会触发一次其监听者 @action reset() &#123; this.completed = false; this.title= ''; &#125;&#125; 5. @oberver observer 函数/装饰器可以用来将 React 组件转变成响应式组件 oberver是用来连接mobx与组件的一个API（告诉mobx本组件依赖于mobx的状态），由一个单独的包 mobx-react 提供，例子看上面的 index.jsx组件。使用了 observer 的react组件中用到的变量发生变化，组件才会更新 四、运行环境的配置@(修饰器)是ES7的一个提案，Babel 转码器已经支持 Decorator需要安装 babel-preset-stage-1 （stage-0也可以）和babel-plugin-transform-decorators，babel-plugin-transform-decorators一定要放在别的plugins前 .babelrc配置 6. useStaticRendering我们知道可以通过使用@observer，将react组件转换成一个监听者(Reactions)，这样在被监听的应用状态变量(Observable)有更新时，react组件就会重新渲染。而对于服务端的React组件，我们只需要它被渲染一次，而不需要组件监听模型的状态。事实上，如果服务端React组件像客户端组件一样监听模型的状态变化，就会造成严重的内存泄漏问题。官方提供了useStaticRendering方法，用于避免mobx服务端渲染的内存泄漏问题; 该方法只需要在server启动时设置一次。 useStaticRendering(true);","categories":[],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://yoursite.com/tags/mobx/"}]},{"title":"javascript的数据属性和访问器属性","slug":"javascript的数据属性和访问器属性","date":"2018-02-28T03:25:55.000Z","updated":"2021-01-25T10:48:26.377Z","comments":true,"path":"2018/02/28/javascript的数据属性和访问器属性/","link":"","permalink":"http://yoursite.com/2018/02/28/javascript的数据属性和访问器属性/","excerpt":"","text":"一、数据属性1.基本认识1.1概念数据属性包含一个数据值的位置，在这个位置可以读取和写入值 数据属性有4个描述其行为的特性 [[Configurable]] : 表示能否通过 delte 删除属性从而重新定义属性，能修改属性的特性，或者能把属性修改为访问器属性。默认true,（说的磨磨唧唧，其实就是能否通过delete删除属性、能否再修改Enumerable、Writable（特殊，把Configurable设置为false后，这个属性也能被修改）、Value（更特殊，看下面例子）、Configurable属性这四个属性） [[Enumerable]] : 表示能否通过 for-in 循环返回属性。 默认 true [[Writable]] : 表示能否修改属性的值 。 默认 true [[Value]] : 包含这个属性的数据值。 默认 undefined tip：为了表示特性是内部值，该规范把他们放在了两对括号中 2.对数据属性的操作必须使用 ECMAScript 5 的 Object.defineProperty() 方法三个参数 属性所在的对象 属性的名字 描述符对象 栗子12345678910111213var person = &#123; name:'y'&#125;//禁止修改属性值Object.defineProperty(person,\"name\",&#123; writable:false&#125;)console.log(person.name) // y//尝试修改属性person.name='b';console.log(person.name) //y//可以看到禁止修改属性的值后，修改属性值无效 2.1注意！！！这四个数据属性中，configurable 是比较特殊的，一旦把属性定义为不可配置的，就不能再把它变回可配置了，此时再调用 Object.defineProperty 方法修改 除writable之外的特性 都会导致失败。1234567891011121314151617181920212223242526272829303132333435363738var b=&#123; age:0&#125;//定义为不可配置Object.defineProperty(b,'age',&#123; configurable:false&#125;)//尝试删除配置delete b.ageconsole.log(b.age)// 成功打印0//尝试修改enumerableObject.defineProperty(b,\"age\",&#123; enumerable:false&#125;)/* 报错：Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:3:8 */// 看下面这俩顺序👇👇👇👇👇👇👇👇👇👇👇👇👇//尝试修改writableObject.defineProperty(b,\"age\",&#123; writable:false&#125;)/*修改成功，不会报错*///尝试修改valueObject.defineProperty(b,\"age\",&#123; value:1&#125;)/*报错：VM17512:1 Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:8*/// 👆👆👆👆👆👆👆👆👆👆👆👆👆 tip:上面的操作只针对于 b对象的age 属性，所以此时我再添加一个属性也是成功的，比如123b.name='m';console.log(b)// 输出 &#123;age: 0, name: \"m\"&#125; tip2:看上面的代码 22-37行，这俩属性很特殊， 就算configurable:false了，writable属性依然可以被修改 注意注意！！ 看到代码里的顺序了么？writable的修改是在value的修改的上面的，这时修改value报错，但我发现如果writable和configurable同时为false（且的关系，不是或），这个value属性才会报错（也就是修改不了）,否则也是可以修改的 tip3:ES5有三个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 二、访问器属性1.基本认识概念访问器属性不包含数据值。它包含一对getter和setter函数。当读取访问器属性时，会调用getter函数并返回有效值；当写入访问器属性时，会调用setter函数并传入新值，setter函数负责处理数据。 访问器属性的四个特性 [[Configurable]]：默认为true。表示能否通过delete删除属性从而重新定义属性，能否修改属性特性，或者能否把属性修改为访问器属性； [[Enumerable]]：默认为true。表示能否通过for-in循环返回属性； [[Get]]：读取属性时调用的函数，默认为undefined； [[Set]]：写入属性时调用的函数，默认为undefined； 2.对访问器属性的操作 tip :1.当使用了getter或setter方法，不允许使用 writable 和 value 这两个属性。2.get和set 函数不是必须的3.先看这种写法： 特别要注意这种写法，容易写错！ 可以看到 堆栈溢出 了，` 原因是因为如果在get里return this.year ，这样如果我们在外面 book .year时，就会运行get函数，而get函数里面执行到this.year时又会运行get函数，造成死循环。正常写法是利用一个中间值来设置某一个属性，看下面代码 正确写法 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。一般上面上面代码目的是 设置一个属性的值会导致其他属性发生变化，就不用把属性单拿出来计算了，很方便 三、总结1.到底怎么判断是数据属性还是访问器属性可以通过 Object.getOwnPropertyNames()方法获取到所有实例中的属性，包括不可枚举的属性。然后，使用Object.getOwnPropertyDescriptor(）方法获取到每一个属性的描述符，如果描述符中有get/set方法，说明它是访问器方法，否则它就是数据属性。其实由于两种属性各自的4种特征都是都不一样的，如果一个对象的属性描述符里含有一个单独的特征就可以判断是什么类型的属性，比如1234var book=&#123;&#125;;Object.defineProperty(book,'age',&#123; value:5&#125;) 描述符里我单独定义了value属性，而value属性仅仅输入数据属性，所以可以判断出 age属于数据属性 2.定义多个属性Object.defineProperty()这种写法每次只能定义一个属性，那么可以通过 Object.defineProperties 来定义多个属性定义多个属性：请注意下面图片内代码是有问题的，这是《js高级程序设计》 里的例子 定义多个属性 这个方法定义多个属性没问题，但是也可以从上面的图看出来，定义的访问器属性year的set方法里面并没有生效，这俩属于数据属性，原因是因为 定义的_year属性和edition属性不能往里面写值了。 自己解决历程：我自己猜想原因可能是这样，因为_year和edition写不进去值了，所以设置 enumerable 为true。我尝试修改了一下，如下 给两个数据属性添加了writable(可读写 )特征 这样运行成功。为了验证猜想，做了如下例子： 所有特性 ； 可以看到只要是用 Object.defineProperties() 定义的对象的属性，那么定义过的每个属性描述符的4个默认属性（除了set和get外）都默认都是 false 总结：使用 Object.defineProperties() 方法来定义多个属性的时候，每个属性的描述符里的属性都是默认的false(除了set和get外)，set或者get没定义的话默认 undefined 四、实际应用介绍了这个东西后，在实际中我该在什么情况用呢？ 数据双向绑定 （Module&lt;==&gt;View）数据双向绑定就是通过 Object.defineProperty 实现的，我们来手写一个数据绑定 &lt;input class=\"inputText\" type=\"text\" /&gt; &lt;p class=\"text\"&gt;&lt;/p&gt; var inputText=document.querySelector('.inputText'); var text=document.querySelector('.text'); //module var obj={_txt:null}; Object.defineProperty(obj,'txt',{ get:function(){ return this._txt; }, set:function(value){ this._txt=value; text.innerHTML=value; inputText.value=value } }) //view inputText.addEventListener('input',function(e){ const text=e.target.value; obj.txt=text; },false) 此时在input输入值的时候p的内容和obj.txt内容会变，在浏览器console中更改obj.txt的值，input和p也会变","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"受控组件和非受控组件","slug":"受控组件和非受控组件","date":"2018-02-07T02:48:32.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2018/02/07/受控组件和非受控组件/","link":"","permalink":"http://yoursite.com/2018/02/07/受控组件和非受控组件/","excerpt":"","text":"一、前言在HTML中，表单元素例如 input , textarea , select 通常是根据用户的输入来维护它们自己的状态。在React中，可变状态通常保存在 state 中，只能用 setState() 来进行更新操作 二、定义解释正如上面所说，表单元素的数据可以由自身DOM元素来管理，也可以由React组件来管理 1.controlled_Component ( 受控组件 )将表单状态保存在React组件中（state），呈现表单的React组件也会控制用户输入后所发生的情况。表单元素数据托管到React组件中的这种方式叫做 受控组件 React能控制 2.uncontrolled_Component ( 非受控组件 )与受控组件相反，表单数据由dom元素自身管理的组件叫 非受控组件 React不能控制 三、栗子1.controlled_Component ( 受控组件 )12345678910111213141516171819202122232425262728class App extends Component &#123; constructor()&#123; super() this.state=&#123; name:'姓名', text:'请输入' &#125; &#125; handleName(e)&#123; this.setState(&#123; name:e.target.value &#125;) &#125; handleText(e)&#123; this.setState(&#123; text:e.target.value &#125;) &#125; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' value=&#123;this.state.name&#125; onChange=&#123;this.handleName.bind(this)&#125;/&gt; &lt;textarea name=\"text\" value=&#123;this.state.text&#125; onChange=&#123;this.handleText.bind(this)&#125;&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都交给了React组件来管理。 注意 :这种情况下每个表单元素必须要有 onChange 事件，这样用户每次操作对应的元素，对应元素数据才能得到改变 2.uncontrolled_Component ( 非受控组件 )123456789101112/*uncontrolled Component*/class App extends Component &#123; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' defaultValue='姓名'/&gt; &lt;textarea name=\"text\" defaultValue='想法'&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都是由自身DOM元素来管理的。 注意 :非受控组件这功中，通常你需要指定表单元素的初始值，但不控制后续的更新，这种情况需要指定 defaultValue 属性，而不是 value属性如果你不想让他有初始值，也可以不用写 defaultValue 三、两者优缺点？ name 优点 缺点 非受控组件 简练、操作数据的方式更简洁 表单验证 、选择性开启或者关闭按钮 等功能不能处理 受控组件 相比之下略显繁琐 表单验证 、选择性开启或者关闭按钮 等功能能轻松处理 所以通常情况下受控组件更能满足我们需求","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"sublime中使用EditorConfig","slug":"sublime中使用editconfig","date":"2018-01-19T02:22:50.000Z","updated":"2021-01-25T10:48:26.379Z","comments":true,"path":"2018/01/19/sublime中使用editconfig/","link":"","permalink":"http://yoursite.com/2018/01/19/sublime中使用editconfig/","excerpt":"","text":"一、作用EditorConfig是统一代码格式的解决方案，它可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格，比如多人合作的时候统一代码风格，避免一些潜在的问题，增加代码可读性 二、使用方法1.编辑器插件有些编辑器已经集成了这个插件，所以不用再安装，而有些编辑器没有集成这个插件，需要安装 下面这些编辑器不需要安装： 已经集成的编辑器 这些编辑器需要安装： 需要单独安装插件的编辑器 sublime里直接搜索 EditorConfig 安装即可 安装 2.配置文件说明在需要的地方配置 .editorconfig文件 注意1： 当打开一个文件时，EditorConfig插件会在打开文件的目录和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=true。什么意思呢？比如我的文件结构是这样的： 文件目录 在 b.js 里的代码，会先从同级目录 ——&gt; 父级目录 这个路径进行查找（冒泡 ），如果遇到了 .editorconfig 里 root=true 则停止，因为 b.js 同级目录的 .editorconfig 里 root=true 所以 b.js 用的就是b.js上面这个文件配置的规则 注意2：EditorConfig配置文件从上往下读取，并且路径最近的文件最后被读取。匹配的配置属性按照属性应用在代码上，所以最接近代码文件的属性优先级最高。什么意思呢？ .editconfig 意思就是 我的 js文件会读取 注释2 (第十行)下面的配置，而python文件会读取上面 (注释1)的配置 3.文件格式详情EditorConfig文件使用INI格式，斜杠(/)作为路径分隔符，#或者;作为注释。注释应该单独占一行。 4.支持的属性注意：不是每种插件都支持所有的属性，具体可见Wiki。 indent_style：tab为hard-tabs，space为soft-tabs。indent_size：设置整数表示规定每级缩进的列数和soft-tabs的宽度（译注：空格数）。如果设定为tab，则会使用tab_width的值（如果已指定）。tab_width：设置整数用于指定替代tab的列数。默认值就是indent_size的值，一般无需指定。end_of_line：定义换行符，支持lf、cr和crlf。charset：编码格式，支持latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用uft-8-bom。trim_trailing_whitespace：设为true表示会除去换行行首的任意空白字符，false反之。insert_final_newline：设为true表明使文件以一个空白行结尾，false反之。root：表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件。 三、我遇到的问题看我的配置文件： .editconfig 我设置了缩进方式为 tab,每级缩进 8 列，但是我设置好后，打开a.js文件后每级的缩进并没有变化，为此我还找了好久~╮(╯▽╰)╭，最后我发现，只要把a.js关闭，再打开就生效了~ 四、总结EditorConfig 可以说很好用了，很适合多人合作情景，但这个只是编辑器级别的格式统一，我会在后面说到代码级别的检测—ESLint，它可以通过我们配置很详细的配置文件，来规范我们的代码风格。","categories":[],"tags":[{"name":"EditorConfig","slug":"EditorConfig","permalink":"http://yoursite.com/tags/EditorConfig/"}]},{"title":"http-proxy-middleware配合gulp使用时的一些坑","slug":"http-proxy-middleware配合gulp使用时的一些坑","date":"2018-01-09T01:23:58.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","link":"","permalink":"http://yoursite.com/2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","excerpt":"","text":"一、介绍在我们用gulp、webpack等方式开发项目的时候，由于会启动个本地服务器，所以如果访问后台提供的接口就是跨域了，这种情况该怎么办呢？这就涉及到了 代理服务 的配置，react项目的webpack的代理服务配置我之前已经写过了，传送门~~。因为使用 http-proxy-middleware 也遇到了多多少少的问题，网上关于遇到的问题解决办法很少或是没有提及（难道问题太弱智？），所以写下这篇文章记录一下（干货满满呦），如果错误烦请指出~~~ 二、环境先说明我的环境：gulp + 静态html 。gulp主要是处理 less 文件和启动服务器方便程序调试 三、目的本地的服务器为：lcoalhost:8080，想要请求的地址为：https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0 （请求地址是我从QQ音乐找的，正因为这样我又遇到了另外一个 ajax的坑，最后一节有说明，所以这个地址也具有一定的教学意义） 四、配置1.gulpfile.js1234567891011121314151617181920212223var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware'), path = require('path'),gulp.task('connect', function() &#123; connect.server(&#123; /*根路径*/ root: './dist', /*开启浏览器自动刷新*/ livereload: true, /*端口号*/ port: 8080, /*使用代理服务*/ middleware: function(connect, opt) &#123; return [ proxy('/api/', &#123; target: 'https://c.y.qq.com/', changeOrigin:true, &#125;) ] &#125; &#125;);&#125;); 说明 proxy配置项： 其中return 返回是一个数组，所以通过配置多个proxy返回值可以实现多重代理 changeOrigin 这个意思是，如果我们代理的目标地址是一个虚拟托管站点，比如 http://www.baidu.com 这种域名的形式的target项，则需要配置此项。如果target项为ip值，比如http://10.10.16.5/ 则不用配置此项 2.index.html12345678910$.ajax(&#123; type: 'GET', url: \"/api/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 3.结果可以看到，请求失败 /(ㄒoㄒ)/~~ 4.解决办法就是在这个问题上我卡了一下午，为了能游刃有余的使用这个东西，有些基本的参数还是要非常明白的123pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;, 很多的技术文章的配置都有写这个东西，但是很少有介绍这个参数的意思。 下面我们来看看不配置此项真正请求的地址： 不配置这个参数请求代理的地址：https://c.y.qq.com/ api /soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0看我标记粉色的地方，再回过头对比我们要请求的地址，是不是多个了 /api/ ? 所以 pathRewrite 这个配置项的意思是，当有 /api/ 字段请求的时候，指定 重写 /api/ 这个字符串，这里为空。 比如：目标地址：http://www.baidu.com/aaa/bbb proxy配置：12345proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, &#125;) 本地服务器：http://localhost:8888 ajax：12345678910$.ajax(&#123; type: 'GET', url: \"/api/aaa/bbb\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 但是实际上请求的是 http://www.baidu.com/api/aaa/bbb 这个地址 ！！！！！。 所以第一种解决办法是配置重写路径1234567proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;,&#125;) 第二种解决办法就是利用已有路径 1234proxy('/aaa/', &#123; target: 'http://www.baidu.com/', changeOrigin:true,&#125;) 关于 http-proxy-middleware 我遇到的问题，已经说完了。下面来说 ajax的一个坑 五、ajax用jq的 ajax请求一个地址，如果返回的数据格式与ajax里预期格式的配置不一样，那么就会在 error 函数里面返回后台提供的数据 ，具体例子就不写了，很简单，可以试一试","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"webpack热更新(HMR)","slug":"webpack热更新-HMR","date":"2018-01-02T07:40:44.000Z","updated":"2021-01-25T10:48:26.380Z","comments":true,"path":"2018/01/02/webpack热更新-HMR/","link":"","permalink":"http://yoursite.com/2018/01/02/webpack热更新-HMR/","excerpt":"","text":"一、HMR介绍在我们开发react应用的时候，在配置了webpack-dev-server的前提下每一次的组件内容修改都需要手动的刷新浏览器，为了解决这个问题，所以有了热更新这个概念，网上的文章弄得我一头雾水，在我配置成功后，自己来记录一下热更新的配置 时隔三个月今天发现了配置更简单的热替换的方法，点我查看 二、配置1.从零开始–项目初始化首先创建一个基本的react的项目，然后命令行运行 npm init 生成 package.json 文件。 新建 build,client 文件夹，分别用来存放 webpack 配置（webpack.config.js文件）和 react 组件。当前目录结构： 目录结构 2.基本的webpack配置为了自动产出html文件，安装 html-webpack-plugin 为了解析 react 组件和对es6的解析，安装 babel-loader babel-core babel-preset-es2015 babel-preset-es2015-loose babel-preset-react 模块，并在根目录新建文件 .babelrc 文件 babel 的配置文件 .babelrc 此时 package.json 文件的包 package.json 添加 webpack-devserver 配置，此时 webpack-config.js 配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');module.exports=&#123; entry: &#123; app:path.join(__dirname,'../client/app.js') &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin() ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; 此时启动webpack-dev-server后，运行成功 package.json 友情提示：： 如果在执行命令的过程中报错 ‘cannot find …’ 这类的错误，首先检查是否少装了包，如果没有少装，则删除 node_module文件夹，重新安装下。 如果运行 webpack-dev-server 启动服务器的时候，网页的 js 文件显示404，首先检查是否本地已经有了一个编译好的 dist 文件夹，因为webpack-dev-server会优先读取本地文件，配置的时候我们添加了 /pubilc/ 所以是读取不道德，这时，删除本地 dist文件夹即可。（这个相当相当的坑） 在入口文件中，我这样写 document.body 是不可取的，正确的做法是 获取Id的形式。 知识点！( 敲黑板 )：path.join 和 path.resolve 区别 path.join：拼接地址（会正确使用当前系统的路径分隔符，Unix系统是/，Windows系统是\\）比如：path.join（‘m’,’/b’） 或者 path.join（‘m’,’b’） 返回m/b这个路径path.resolve：将参数转换为绝对路径比如 path.resolve(‘m’) ;如果当前命令窗口是在c盘打开的，那么返回C:\\m(总是返回一个绝对路径)对比：两种方法都可以获得当前目录的绝对路径（通过__dirname），因为path.join可以适应unix和windows，所以join可能好一些 三、重头戏-配置HMR这里说是简单，但我觉得对于初次使用还是比较繁琐，整理一下，分为下面几个步骤(与顺序无关) 安装 react-hot-loader 配置 babelrc 文件 配置 入口文件app.js 配置 webpack.config.js 2.配置 .babelrc 文件 .babelrc 3. 配置 入口文件app.js 4. 配置 webpack.config.js改动部分标记为 //add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');const webpack=require('webpack'); //addmodule.exports=&#123; entry: &#123; app:[ 'react-hot-loader/patch', //add path.join(__dirname,'../client/app.js') ] &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(), new webpack.HotModuleReplacementPlugin() //add ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*热加载*/ //add hot:true, //add /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; react-hot-loader参考 好了，该做的做完了，打开浏览器测试，发现更改App.jsx文件后浏览器竟然特么没有变化,这就很气人，我也按照你官网上写的做了，现在出不来？好吧，看下面的解决办法 四、解决上面的问题app.js这个入口文件中，更改为： 更改为 如果有了更改，那么 重新用 require 的方式获取一下这个组件，然后进行渲染 成功啦！ 是不是有了疑问，为啥用 require 的方式引入呢？因为这种形式的文件引入import的方式引入不了 五、总结本来一个挺好的功能，分别写在了 webpack官网和 react-hot-loader 官网，这还不算啥，最后还运行不了，多坑，好了就记录到这里了,如果有问题或者补充欢迎回复","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"HMR","slug":"HMR","permalink":"http://yoursite.com/tags/HMR/"}]},{"title":"react服务端渲染","slug":"react服务端渲染","date":"2017-12-26T09:02:19.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2017/12/26/react服务端渲染/","link":"","permalink":"http://yoursite.com/2017/12/26/react服务端渲染/","excerpt":"","text":"看了react服务端渲染，有点蒙圈，先挖坑准备","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"select禁止更改值","slug":"select禁止更改值","date":"2017-11-30T02:31:59.000Z","updated":"2021-01-25T10:48:26.379Z","comments":true,"path":"2017/11/30/select禁止更改值/","link":"","permalink":"http://yoursite.com/2017/11/30/select禁止更改值/","excerpt":"","text":"一、效果介绍select框选中了一个值后禁止更改select 二、方法1.css利用disabled=&quot;true&quot;来禁止选中缺点：这种方法虽然简单，但是它禁止了select框获得焦点，不能看到select的内容优点：简单 2.js123456&lt;select name=\"selectname\" id=\"selectid\" onfocus=\"this.defaultIndex=this.selectedIndex;\" onchange=\"this.selectedIndex=this.defaultIndex;\"&gt; &lt;option value=\"1\"&gt;dd&lt;/option&gt; &lt;option value=\"2\"&gt;mm&lt;/option&gt; &lt;option value=\"3\" selected=\"selected\"&gt;cc&lt;/option&gt; &lt;option value=\"4\"&gt;ff&lt;/option&gt;&lt;/select&gt; 1.获取焦点时，将当前的值 selectedIndex 赋值给一个自定义的属性 defaultIndex2.change时，将当前的值设置为 defaultIndex 优点：select框依然可以选择，被下拉","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"滑动窗口算法解决指定字符串最长子串长度问题","slug":"滑动窗口算法解决指定字符串最长子串长度问题","date":"2017-11-16T07:52:51.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","link":"","permalink":"http://yoursite.com/2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"gitment评论插件的配置","slug":"Hexo博客下gitment评论功能","date":"2017-11-13T08:11:31.000Z","updated":"2021-01-25T10:48:26.373Z","comments":true,"path":"2017/11/13/Hexo博客下gitment评论功能/","link":"","permalink":"http://yoursite.com/2017/11/13/Hexo博客下gitment评论功能/","excerpt":"","text":"今天我在第N次搭建博客的时候想加一个评论功能，我用的主题是indigo，在根目录_config.yml文件里经过测试发现最简洁好用的就是gitment，所以这里记录我gitment配置过程： 第一步先注册一个 oAuth Application注册成功会得到一个client id和 client secret两个参数，它们将被用于后面的用户登录 oAuth Application _config.yml 其中githubID需要https://api.github.com/users/github账户名 访问这个链接来获取 第二步如果你想要此功能的页面存在这一部分： gitment页面配置 这是一个ejs页面，里面是模板，通过使用主题的_config.yml文件配置那么你可以跳过这一步，否则需要在使用评论功能的页面添加这写代码：1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', // 可以是你的GitHub用户名，也可以是github id repo: '存储评论的 github repo', oauth: &#123; client_id: '你的 client id', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 第三步到这里已经默认你添加了上面的代码，现在注意了，我用的主题本身就带上面的代码的，只不过需要在 主题的 _comfig.yml文件中配置对应项，我在配置文件中配置好后，启动本地服务器，发现回复模块报错，控制台中发现他会请求一个链接，链接上带有刚刚配置好的参数，这里参数全部为空，我以为我配置文件有问题，折腾了好久，仍然不行，后来发现我要添加这个功能的页面里的模板并没有获取到我在_config.yml配置，最后通过修改要添加回复功能页面的模板文件才成功： 修改为 直接赋值，而不是使用模板，不知道为啥用模板获取不到值，现在已经配置成功如果配置失败，那么一定是上面的参数写错了，或者像我这种情况模板页面获取不到值，只需要直接赋值即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"for循环的灵活运用","slug":"for循环的灵活运用","date":"2017-11-13T08:11:30.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2017/11/13/for循环的灵活运用/","link":"","permalink":"http://yoursite.com/2017/11/13/for循环的灵活运用/","excerpt":"","text":"一、介绍for循环是平时在写代码过程中最常用的代码了，一般写的时候都是中规中矩，比如这样：1234for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125;//打印出四次i的值 个人觉得，要想用好一个东西就要明白它的工作原理，那么for循环的工作原理是什么呢？ 二、工作原理其实对于for循环的工作原理之前也是有多次了解的，可是长时间不去回忆一个知识点，知识点就会变得模糊，这里再次记录一下它的工作流程123for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125; 1.声明一个变量i=02.判断i是否小于43.如果满足判断条件，执行console.log(i)（函数体）4.i++5.循环步骤1-4 图 三、延伸上面的写法都是中规中矩的，for循环有三个对应的参数，以；分隔，那么我可不可以省略其中某个参数呢？ 省略之前要注意，；是一定要加的1.全都省略123for(;;)&#123; console.log(1)&#125; 结果：这样写相当于无限循环了，根本停不下来 2.省略第一参数12345var i=0;for(;i&lt;2;)&#123; console.log(i)&#125;// 在外面声明了一个 i ，如果不声明这个东西，那判断条件该判断啥？所以这就相当于没有省略第一个参数，当然正常情况下我还没见到省略第一个参数的情况，一般情况第一个参数都是有的 结果：这样也会无限循环，因为i的值一直为0，所以它会无限的循环下去延伸：既然第三个参数省略了，我们可以再函数体里面定义它的累加规则啊，比如这样1234567for(var i=0;i&lt;20;)&#123; // 6的倍数 i=i+6; if(i%6===0&amp;&amp;i&lt;20)&#123; console.log(i) &#125;&#125; 好处：循环的次数大大降低，性能提升了，在这里正常情况下需要循环20次进行判断，现在的写法仅需要循环4次（第四次没有打印但是执行了函数体） 仔细观察后发现，其实这种方式就是仅仅省略了第三个参数 3.看看省略第三个参数还能干嘛问题：给定一个很大的数组，数组里面有许多证书，用JavaScript实现一个函数，要求：将数组中之和为10的每一对数配对并找出，返回这些数配对后的数组。例如：[11,3,8,9,7,-1,1,2,4…]得到：[[11,-1],[3,7],[8,2],[9,1]…] 思路：其实一般的写法是两个for循环进行潜逃的那种，这里就不展示了，这里写的是优化后的写法123456789101112131415161718192021let list = [1,2,3,-5,9,45,6];function map(list)&#123; let ret=[]; list=list.sort((a,b)=&gt;a-b); /*省略的第三个参数*/ for(let i=0,j=list.length-1;i&lt;j;)&#123; let a=list[i],b=list[j]; if(a+b===10)&#123; ret.push([a,b]); i++; j--; &#125;else if(a+b&lt;10)&#123; i++; &#125;else&#123; j--; &#125; &#125; return ret;&#125;console.log(JSON.stringify(map(list)))//结果：[[1,9]] 思路：这里影响性能的主要是太多次的for循环，数据量小还好，如果特别多怎么办？所以要减少for循环次数，先将数组从小到大排序，然后进行从两边到中间的计算，符合条件就 push一次 四、总结简简单单的一个for循环可以有不同的写法，所以说写代码简单，写出有质量的代码难","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"斐波那契数列的实现","slug":"斐波那契数列的实现","date":"2017-10-25T09:10:02.000Z","updated":"2021-01-25T10:48:26.381Z","comments":true,"path":"2017/10/25/斐波那契数列的实现/","link":"","permalink":"http://yoursite.com/2017/10/25/斐波那契数列的实现/","excerpt":"","text":"一、扫盲斐波那契数列也叫黄金分割数列，也叫兔子数列原理：假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？ 月份 兔子情况 总数 第0个月 a（小兔子） 1 第1个月 a（具备繁殖能力） 1 第2个月 b（生啦生啦）+ a（他父母） 2 第3个月 b（2月份出生的具备繁殖能力，正跃跃欲试） + b2（他父母又生二胎了） +a（他父母） 3 第4个月 c（2月份的兔子b喜当爹）+b（二月份出生的兔子） + b2（二胎具备繁殖能力，准备生娃） +a（他父母）+d(a生三胎) 5 … … … 1、1 、2、3、5、8、13、21、34、55、89……所以规律就是 fn(n)=fn(n-1)+fn(n-2) 二、代码实现1.第一种这种是最常见的实现：迭代12345678910111213/**i 月份*/function fn(i)&#123; var a=[]; /*0个月什么都不存在*/ a[0]=0; a[1]=1; for(var o=2;o&lt;=i;o++)&#123; a[o]=a[o-1]+a[o-2]; &#125; return a[i]&#125; 2.第二种递归1234567/** i 月份*/function fn(i)&#123; if(i&lt;=1)&#123;return 1&#125; return fn(i-1)+fn(i-2)&#125; 是不是感觉很简洁 三、缺陷针对这个例子来说，这里的递归会进行太多次的调用（比迭代多），所以简洁的背后牺牲的是性能 四、优化上面的递归非常消耗性能，所以要优化一下 1. 关于优化的思路是什么导致上面的性能消耗大的？，可以看到，递归的循环次数非常多，且没有尾调用 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 所以每一次的fn执行都会增加一个调用帧，导致内存消耗变大 1234function fn(i,prev=1,current=1)&#123; if(i&lt;=1)&#123;return current&#125; return fn(i-1,current,prev+current)&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"css中的attr()","slug":"css中的attr","date":"2017-10-11T03:43:15.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2017/10/11/css中的attr/","link":"","permalink":"http://yoursite.com/2017/10/11/css中的attr/","excerpt":"","text":"1.介绍attr() 用来获取一个html元素的属性值，可以用于伪元素，可以用于任何css属性 2.用法这个使用起来非常方便且简单1content:attr(属性值); attr()可以传三个值，分别是属性值、类型限制、默认值（必须符合类型限制），不过我试了半天也没调试成功，而且一般写一个参数就行，三个参数的情况基本用不到，所以就跳过了 3.例子12345678910111213141516171819&lt;hear&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 400px; height: 400px; border:1px solid #ccc; &#125; .box:after&#123; content:attr(data-foo); background-color: #ff461d; color: #fff; border-radius: .32rem; padding: .053333rem .133333rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\" data-foo=\"hello\"&gt;&lt;/div&gt;&lt;/body&gt; 此时，在div中将会出现一个红色背景的hello 4.实例那么这个东西在什么情况下能用到呢？ 购物车","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"attr()","slug":"attr","permalink":"http://yoursite.com/tags/attr/"}]},{"title":"react中的this.props.children","slug":"React.Children","date":"2017-09-28T09:34:55.000Z","updated":"2021-01-25T10:48:26.373Z","comments":true,"path":"2017/09/28/React.Children/","link":"","permalink":"http://yoursite.com/2017/09/28/React.Children/","excerpt":"","text":"一、介绍React.Children 是顶层API之一，为处理 this.props.children 提供了几个方法this.props.children 表示组件所有子节点 二、所有方法1.React.Children.map12345678//必须有返回值React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;)//没有返回值React.Children.map(this.props.children,function(child)&#123; /*这里进行处理*/&#125;) 这里的 child 表示组件的每一个子元素，也可以用箭头函数来写，这样方便this的传递 2.this.props.children这个是获取当前组件的所有子节点注意 ：1.如果没有子节点，返回 undefined2.如果一个子节点，返回 object3.如果多个子节点，返回 array但是用 React.Children.map 来遍历的话不会有问题 3.React.Children.count返回组件的所有子元素个数 4.React.Children.only12console.log(React.Children.only(this.props.children[0])); //输出对象this.props.children[0] 单独 this.props.children[0] 输出不出来 5.child.key在用 React.Children.map 的时候可能想获取传过来的属性值，例如123456789101112&lt;Tabs_li data=&#123;data&#125;&gt; &lt;div key=&#123;0&#125;&gt;1&lt;/div&gt; &lt;div key=&#123;1&#125;&gt;2&lt;/div&gt; &lt;div key=&#123;2&#125;&gt;3&lt;/div&gt;&lt;/Tabs_li&gt;/*Tabs组件*/&#123;React.Children.map(this.props.children,(child)=&gt;&#123; console.log(child.key) // 分别打印 0 ， 1 ，2 return ...&#125;)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react中跨域请求数据","slug":"react中跨域请求数据","date":"2017-09-27T06:03:37.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2017/09/27/react中跨域请求数据/","link":"","permalink":"http://yoursite.com/2017/09/27/react中跨域请求数据/","excerpt":"","text":"一、介绍在我写 react ele 项目的时候，里面的所有数据都要从ele获取，所以我之前的想法是先用死的数据模拟，然后用 node 写几个接口请求ele数据并返回给我的react。知道今天早上，我在纳闷 react开发过程中是用 webpack 起服务器的，那跟后台就是跨域了啊，这样ajax是没有办法请求的，所以吃完一个鸡蛋后查找了一番，果然让我找到了，看下面 传送门 – gulp里服务端代理配置 二、配置webpack中 proxy 是设置代理的1234567proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", secure: false, changeOrigin : true &#125;&#125;, 现在比如说我 /api/users 这么请求，现在将代理请求http://localhost:3000/api/users 注意 ：这里的 secure 参数表示能请求 https 的服务器changeOrigin 表示是否支持跨域请求，默认 false 实例好了 现在我来试验一下12345\"/base\": &#123; target: \"http://c.y.qq.com/\", secure: false, changeOrigin : true&#125; 这个是我从qq音乐找了一个借口，在react中通过 fetch 请求12var result = fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; credentials: 'include', headers: &#123; 'Accept': 'application/json, text/plain, */*' &#125; &#125;)result.then(res =&gt;&#123;return res.text();&#125;).then(text =&gt; &#123; console.log(text) &#125;) 看看返回结果 控制台输出 是不是很方便~","categories":[],"tags":[{"name":"webpack proxy","slug":"webpack-proxy","permalink":"http://yoursite.com/tags/webpack-proxy/"},{"name":"react跨域请求","slug":"react跨域请求","permalink":"http://yoursite.com/tags/react跨域请求/"}]},{"title":"认识pushstate、popstate,无刷新改变URL","slug":"认识pushstate、popstate-无刷新改变URL","date":"2017-09-22T06:39:04.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2017/09/22/认识pushstate、popstate-无刷新改变URL/","link":"","permalink":"http://yoursite.com/2017/09/22/认识pushstate、popstate-无刷新改变URL/","excerpt":"","text":"一、回顾 window.historyhistory对象包含用户（在浏览器窗口中）访问过的url12345678910//回退history.back();//前进history.forward();//跳转history.go();//历史记录条数（当前网页的，不是浏览器的）history.length//状态history.state 二、认识新特性HTML5扩展了history,使历史记录更加灵活，可以在历史记录中存储指定记录点、替换当前历史记录点，监听历史记录点 2.1.存储历史记录点123456window.history.pushState('新添加的','','?page=3');// 第一个参数：设置state// 第二个参数：页面标题，但是所有浏览器都忽略了，传空字符串就行// 第三个删除：想要添加的链接//`注意，这个api会改变当前的网址，会添加一条历史记录，不是push到后面，这样会添加一条历史` 执行后，页面的URL为当前url？page=3 执行前 执行后 此时的history.length也会+1，新增了历史记录点 2.2.替换历史记录点12345window.history.replaceState('新添加的','','?page=3');//`注意，这个api会改变当前的网址(不跳转)，不会添加一条历史记录，注意与上面pushState区别`&gt; 补充：location.replace()也是替换当前网址，但是页面会跳转，而且不会添加历史记录 区别：1.history.length不会变2.替换了当前页的历史记录点 2.3.监听历史记录点1window.onpopstate=function()&#123;&#125; 浏览器前进后退都会触发这个事件比如可以这样：123window.onpopstate=function(event)&#123; console.log(event.state)&#125; 后退操作时，就会打印出后退到的历史记录点的state信息。 四、用途在我写react饿了么的项目时，点击首页的定位信息，会从右滑动出一个新的页面，此时再通过浏览器的前进后退按钮也可以实现页面的滑动 浏览器控制动画 具体制作过程看我的github：ele项目 五、补充在用 document.referrer 做返回按钮的时候，是只有 a标签 才能添加一条来源的。比如我通过点击页面的一个 链接 调到了对应的页面，那么此时 document.referrer 是有值的，通过 history.pushState 添加的历史记录跳转的页面,不会添加一条 document.referrer 来源","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"position的sticky属性","slug":"position的sticky属性","date":"2017-09-13T02:25:03.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2017/09/13/position的sticky属性/","link":"","permalink":"http://yoursite.com/2017/09/13/position的sticky属性/","excerpt":"","text":"表头跟随 图中展示的效果使我们在日常开发中常见的效果。以前我都是用js判断是否滚动一定距离然后给这个元素设置position:fixed这种方式来做的，今天就来记录一下用css怎么做 一、介绍css 中的 position 属性的值常用的主要有下面几种：1.absolute2.relative3.fixed现在用到的值为 sticky：设置了sticky的元素，不脱离文档流，在屏幕范围时（viewport），该元素位置不受到定位影响（top、left等值无效），当该元素的视图将要离开偏移范围时，定位会变成 fixed 的效果，并且根据设置的top 、left值进行定位 二、用法上面的gif图里，我将搜索框的元素设置为123postion:sticky;top:0;left:0 所以当移出屏幕时就会触发fixed定位 三、兼容性刚刚把它用在实际项目中去了，结果安卓自带的浏览器不支持，所以附加上解决办法：12345678910111213141516171819202122232425262728//判断是否支持if (CSS.supports(\"position\", \"sticky\") || CSS.supports(\"position\", \"-webkit-sticky\")) &#123; // 支持 sticky,顶部吸附 this.setState(&#123; support:true &#125;)&#125;else&#123; document.addEventListener('scroll',this._scrollTop)&#125;//不支持的主要处理_scrollTop()&#123; let offsetY=this.searchDOM.offsetTop; let css=null; if(window.scrollY&gt;offsetY)&#123; css=&#123; position:'fixed', top:0, zIndex:999 &#125; &#125;else&#123; css=&#123; position:'static', &#125; &#125; this.setState(&#123; css &#125;)&#125; 四、总结 该元素不脱离文档流，仍保留元素原本在文档流中的位置 当元素在容器中被滚动超过指定偏移值时，元素在容器内固定在指定位置。比如你设置了 top:50px 那么sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动 元素固定的相对偏移是相对于它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于 viewport 来计算元素的偏移量","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"create-react-app配置webpack","slug":"create-react-app配置webpack","date":"2017-09-06T08:42:15.000Z","updated":"2021-01-25T10:48:26.376Z","comments":true,"path":"2017/09/06/create-react-app配置webpack/","link":"","permalink":"http://yoursite.com/2017/09/06/create-react-app配置webpack/","excerpt":"","text":"在学习react过程中，每次都要配置webpack，非常的麻烦，我是要写react的，不是配置这东西哒！！好在有了’create-react-app’，通过npm安装后，创建项目变得非常简单但是它里面没有做less等你实际项目需要的loader或者plugins，所以这里记录的是怎么定制create-react-app创建的项目的webpack 一、先配置less1.创建一个项目我创建的叫test test测试项目 创建完毕后，进入创建的项目，运行npm start启动此项目 启动 2.找到webpack.config.dev.js和webpack.config.prod.js运行npm run eject安装less-loader和less进入config文件夹，这里会有两个文件webpack.config.dev.js和webpack.config.prod.js应该一个是开发环境一个生产环境的配置文件，两个文件都要修改打开webpack.config.dev.js找到module rules部分，也就是配置loader的部分，找到配置css文件的test（/\\.(css)$/）修改为test:/\\.(css|less)$/,添加一个loader：{ loader: require.resolve(&#39;less-loader&#39;) },放在最下面1234567891011121314151617181920212223242526&#123; test: /\\.css$/, use: [require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () = &gt;[require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: ['&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') &#125;, ],&#125;, 3.测试现在我们做一下测试可以随便在css文件中加入less语法我在App.css中设置了整体的背景颜色：1234567@base: pink;.App-header &#123; background-color: @base; height: 150px; padding: 20px; color: white;&#125; 因为我们修改了webpack的配置项，所以需要重新启动服务器： 添加成功 可以看到，配置已经成功 二、配置px2rem1.解释px2rem是做移动端页面开发的时候，自动将px单位转换为rem，非常的方便这里要用支持webpack的对应loader，我用的是postcss-px2rem配置这个功能相对来说有些复杂 2.安装npm install postcss-px2rem postcss-loader --save执行这个命令安装 3.配置还是webpack.config.dev.js，引入1const px2rem = require('postcss-px2rem') 添加在的autoprefixer下面添加，好像loaders里只能有一个postcss，多个的话不会报错，对应的功能会不管用12345678910111213141516171819202122&#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), //这个位置 px2rem(&#123;remUnit: 75&#125;) ], &#125;,&#125;, 这里面的数值就是1rem对应的px 4.测试现在启动服务器，因为原有的都是以px为单位，所以现在页面上应该全部转换为了rem 添加成功 不要忘了配置webpack.config.prod.js这个文件，最后只需要在你的页面上对html的font-size做变换就可以了，这里略过 5.总结webpack的文档和有些npm的文档写的走点心好么，搞得本来挺简单的东西查了好久！","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"px2rem","slug":"px2rem","permalink":"http://yoursite.com/tags/px2rem/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"箭头函数的this指向","slug":"箭头函数的this指向","date":"2017-08-25T07:14:31.000Z","updated":"2021-01-25T10:48:26.382Z","comments":true,"path":"2017/08/25/箭头函数的this指向/","link":"","permalink":"http://yoursite.com/2017/08/25/箭头函数的this指向/","excerpt":"","text":"前言 es6的箭头函数非常简洁，而且还可以解决很多问题1.解决以前通过var that=this方式传值的问题1234567document.body.addEventListener('click',function()&#123; setTimeout(function()&#123; console.log(this) /*window*/ /*对body节点操作代码...*/ &#125;)&#125;) 比如点击body，过一段时间对body这个元素进行对应的js操作，如上代码，很明显是不对的，因为setTimeout里的this是全局window所以是不能通过它操作body元素， 一般这种情况以前都是通过在外层通过一个变量将this传递进来，但是有了箭头函数就不用这么做了 es6:1234567document.body.addEventListener('click',function()&#123; setTimeout(()=&gt;&#123; console.log(this) /*body(当前节点)*/ /*对body节点操作代码...*/ &#125;)&#125;) 这类的问题还有很多，但是为什么箭头函数能轻易地解决这些问题呢？所以要清楚能这么写的原因就要清楚箭头函数中this的指向 一、写箭头函数的小提示1.当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。1234/*错误*/()=&gt;&#123;&#125;/*正确*/()=&gt;(&#123;&#125;) 因为JavaScript引擎会将{x}理解成一个代码块，空对象和块在这里都是{}这样表示，所以如果返回的是一个对象，需要加一个小括号 箭头函数的this箭头函数没有自己的this!!!!!!!!!,它内部的this值集成自外围作用域123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 t1、t2、t3都输出1因为箭头函数没有自己的this所以this.id会顺着作用域链查找一直找到foo()函数 箭头函数的的特点它没有arguments变量12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 如果有了新发现，会回来补充","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"react中的context","slug":"react中的context","date":"2017-08-21T03:29:02.000Z","updated":"2021-01-25T10:48:26.378Z","comments":true,"path":"2017/08/21/react中的context/","link":"","permalink":"http://yoursite.com/2017/08/21/react中的context/","excerpt":"","text":"一、为什么用context？现在我们有一颗组件树： 组件树 假如这个组件树代表的应用是用户可以自定义主题的，每个子组件都会根据主题的不同来调整自己的样式，所以‘主题色’这个东西就应该是组件之间共享的一个状态，所以应该放到Index组件中。但是在此之前能想到的办法只能是this.props.主题色 主题色的传递 这种形式，这种形式实在是麻烦，如果组件嵌套过深，就不得不一层层传递到最底层，所以就出现了简单的办法——通过context传递context这种方法是全局都能共享的状态，我们需要的时候就去取这个状态，不需要手动传递 context共享状态 二、实践，看看代码怎么写先创建一个整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;Title /&gt; &lt;/div&gt; ) &#125;&#125;class Main extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is main&lt;/h2&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;class Title extends Component &#123; render () &#123; return ( &lt;h1&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;React.js 小书内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 修改Index组件修改Index组件，让他往自己的context中放一个themeColor：1234567891011121314151617181920212223class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: 'red' &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 代码说明1.state初始化一个themeColor状态，方便以后的修改2.getChildContext方法设置context，返回一个的对象就是context，所有子组件动能访问到，且用this.state.themeColor来设置context里面的themeColor3.注意，还需要加上一段参数的验证 childContextTypes,需要使用prop-types这个包，验证的是getChildContext返回的对象以上这些都是必须的,这里要提及一下为啥要验证context，这么多步骤多麻烦，据说context是一个危险的属性(context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料),所以按照react.js团队的想法就是，把危险的事情搞复杂一些，提高使用门栏人们就不去用了 子组件的设置class Title extends Component { static contextTypes = { themeColor: PropTypes.string } render () { return ( &lt;h1 style=&lt;!--￼7--&gt;&gt;React.js 小书标题&lt;/h1&gt; ) } } 1.利用contextTypes进行验证，必写的，不写就无法获取context的状态，2.使用的话是通过this.context.themeColor来获取值的 修改context在Index里面，我们已经初始化一个state状态了，叫：this.state.themeColor,所以使用setState就可以了 四、我的例子: 点击变色按钮前 点击变色按钮后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript时间处理小技巧","slug":"js时间","date":"2017-08-18T07:41:37.000Z","updated":"2021-01-25T10:48:26.377Z","comments":true,"path":"2017/08/18/js时间/","link":"","permalink":"http://yoursite.com/2017/08/18/js时间/","excerpt":"","text":"获取当前时间1new Date() 获取当前时间的毫秒数12345678new Date().getTime()/*返回1970年1月1日至今的毫秒数*//*下面是作用相同，写法不同*/Date.now()/*这个也返回值相同*/+new Date() +”操作符123456789/*将元素转换成number类型*/+'123'/*返回123*/+'www'/*返回NaN*//*同理*/+Date.now() toLocaleDateString() 和 toLocaleTimeString() 区别123456789new Date().toLocaleDateString()/*2017/8/18 获取的年月日*/new Date().toLocaleTimeString()/*下午3:56:16 获取的时分秒*//*注意必须要用时间对象调用才行 比如 Date.now().toLocaleDateString()会报错，因为Date.now()返回的是毫秒数*/ 时间格式处理技巧如果想格式处理 当前时间与之前某个特定时间的时差 可以用这样的方式123456789/*duration为差值*/duration&gt;60 ?`$&#123;Math.round(duration/60)&#125;分钟前` : `$&#123;Math.round(Math.max(duration , 1))&#125;秒前`/*1.利用了ES6的模板字符串，结构更清晰2.利用三目运算符(三元运算符)进行判断，避免各种if3.Math.max 如果差值小于1s，则按1s计算，避免又一次的if判断*/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]}