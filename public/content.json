{"meta":{"title":"DHYANA","subtitle":null,"description":"YMBo的博客，blog，YMBo","author":"YMBo","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-08-14T08:24:32.000Z","updated":"2018-12-19T10:58:34.973Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-13T13:51:41.000Z","updated":"2018-12-19T10:58:34.915Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"记录一次git操作（git远程仓库地址变更）","slug":"记录一次git操作","date":"2019-05-26T03:55:36.000Z","updated":"2019-05-26T09:52:13.025Z","comments":true,"path":"2019/05/26/记录一次git操作/","link":"","permalink":"http://yoursite.com/2019/05/26/记录一次git操作/","excerpt":"","text":"背景项目远程仓库地址是A，将项目以名称为appclone在本地，而且在服务器上也以项目名称为appclone。由于一些原因，将远程仓库A迁移到远程仓库B,所以需要将远程服务器app的仓库地址由A改为B，但由于服务器的一些程序的限制，app文件名称不可以变，只需要变动里面的项目内容 远程仓库，有三次提交记录 远程仓库 本地仓库 本地仓库 仓库地址 一、仓库迁移1. 将A仓库镜像到B仓库名称为old仓库迁移到了名称为new仓库里 新的仓库地址 2.本地额外提交到old仓库两次记录 old仓库的提交记录 new仓库的提交记录 可以看到old仓库领先new仓库两次提交 远程服务器仓库的提交记录 3. 将new仓库内容与old仓库内容同步因为old里面内容较新，所以讲old文件同步到new上，并且同步后再提交一次记录到new上 远程服务器仓库的提交记录 4. 将服务器仓库的地址变更为new仓库地址并更新4.1. 服务器地址切换 远程服务器仓库地址切换 4.2. 服务器git pull 远程服务器git pull 可以看到更新失败需要手动处理冲突，其实关键就在这里如果服务跑一个程序比如说web服务，这些文件是web页面，那么此时web页面就会展示错误，因为文件里有待解决的冲突，那怎么解决呢？ 二、解决方案其实下面1、2方法在一定程度上是一个意思 1. 方法1服务器clone最新的new仓库到app的同级目录，然后将本来存在的app删除，并将new仓库改名为app即可（mv也可以改名） 2. 方法2服务器clone最新的new仓库到app的同级目录，将new文件下的.git 隐藏文件（工作区）移动到app文件下替换app的.git，git reset –hard HEAD^后git pull即可 3 git remote -set-url origin &lt;新地址&gt; 首先git remote -set-url origin &lt;新地址&gt; git fetch（拉取更新但不合并） git reset –hard origin/master （用远程服务器的origin/master替换本地、暂存区、版本库） tip: 当更新仓库的时候用 git pull ，但是git pull 包含了两个操作 ，git fetch 和git merge,git fetch 是将远程的master（默认）分支存储到本地的origin/master命名空间中，不会进行合并但是有时候我们想用远程仓库的内容完全替换到本地的容：git reset –hard origin/master撤销本地、暂存区、版本库(用远程服务器的origin/master替换本地、暂存区、版本库) 总结上面说了这么一大堆，其实都是我实际中遇到的坑坑，差点坑死我，不过上面说的确实是很麻烦，所以再总结一下问题：切换远程分支避免遇到merge，或者说怎么更好的切换远程分支并更新解决方案：上面三种","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"linux命令nohup和&区别","slug":"linux命令nohup和-区别","date":"2019-01-15T06:27:22.000Z","updated":"2019-01-15T09:17:19.198Z","comments":true,"path":"2019/01/15/linux命令nohup和-区别/","link":"","permalink":"http://yoursite.com/2019/01/15/linux命令nohup和-区别/","excerpt":"","text":"一、前言因为我想把一个程序一直运行在centos系统上，后来的知 nohup ，&amp; 命令都可以，在网上查找资料后，对这些资料进行整理，让这两条命令的异同更直观的展现出来 二、nohup命令nohup 是 no hang up 的缩写,不挂断的意思 语法：nohup Command [ Arg … ] [ &amp; ]作用：不挂断的运行指定程序下面我会按照 nohup command &gt; myout.file 2&gt;&amp;1 这条命令进行拆分讲解 1、nohup command 不挂起的执行 command 程序,当 ctrl+c 的时候会退出 command 程序 （因为对SIGINT信号不免疫） 2、 &gt; myout.file 2&gt;&amp;1 标准输出和标准错误都打印到当前目录下的myout.file文件里 如果直接执行 nohup command 没有后面的一串，那么将在当前目录自动创建 nohup.out文件，并shell中提示 appending output to nohup.out，输出都将附加到这个文件里。 如果没有当前目录创建文件的权限，那么输出重定向到跟目录下的 /nohup.out 文件中， 如果没有文件能创建或打开以用于追加，那么那么 Command 参数指定的命令不可调用（执行失败） 2.1、问题1： 2&gt;&amp;1 什么意思？操作系统中有三个常用的流： 0：标准输入流 stdin 1：标准输出流 stdout 2：标准错误流 stderr一般当我们用 &gt; console.txt，实际是 1&gt;console.txt的省略用法；&lt; console.txt ，实际是 0 &lt; console.txt的省略用法。补充 :&gt; console.txt 每次执行会覆盖文件内容，使用 &gt;&gt; console.txt 进行追加，则console.txt不会被覆盖 有时候希望将错误的信息重新定向到输出，就是将2的结果重定向至1中就有了”2&gt;1”这样的思路，如果按照上面的写法，系统会默认将错误的信息（STDERR）2重定向到一个名字为1的文件中，而非所想的（STDOUT）中。因此需要加&amp;进行区分。就有了 2&gt;&amp;1 这样的用法 这句话意思是把标准错误（2）重定向到标准输出中（1），而标准输出又导入文件myout.file里面，所以结果是标准错误和标准输出都导入文件myout.file里面了 2.2、问题2： 为何2&gt;&amp;1要写在&gt;myout.file后面？command &gt; file 2&gt;&amp;1 首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。command 2&gt;&amp;1 &gt;file 2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。 3、例子：执行jenkins服务nohup java -jar jenkins.war --ajp13Port=-1 --httpPort=8088 &gt; /Users/admin/nohup.out 2&gt;&amp;1 启动jenkins,并将输出导入到文件nohup.out里 执行结果 可以看到执行成功了，新建窗口 再看看日志文件打开 /Users/admin/nohup.out 这个文件： 文件内容 结论：控制台没有输入jenkins的启动信息 4、关闭当前终端 关闭启动jenkins的终端 结论 ：可以看到关掉终端不会关闭jenkins进程 5、注意注意！ctrl+c可以从执行结果图看到，任务开始后终端是不能输入的，那我执行 ctrl+c 让终端编程可输入状态会发生什么呢？ 执行ctrl+c后任务结束了 可以看到任务结束！！ 结论：ctrl+c使jenkins进程结束了 6、 nohup总结 nohup Command [ Arg … ] [ &amp; ]:程序运行不挂起，默认会将输出重定向nohup.out文件中，也可以自定义输出文件，ctrl+c的话会退出a.sh进程（因为对SIGINT信号不免疫），关闭Command, Command进程还是存在的（对SIGHUP信号免疫） 三、&amp;命令1、command &amp;让command程序在后台运行 2、还以jenkins为例子测试 启动jenkins 结论：控制台输出了jenkins的启动信息 3、执行ctrl+c 执行ctrl+c 结论：ctrl+c不会使jenkins进程停止 4、关闭当前终端 关闭当前终端 结论：关闭终端会使jenkins进程停止 5、补充这时我突然想到了，上面介绍了 &gt;a.txt 这样可以把信息输入到a.txt文件里，那可不可以 Command &gt;a.txt &amp;这样用呢？java -jar jenkins.war --ajp13Port=-1 --httpPort=8088 &gt; /Users/admin/nohup.out 2&gt;&amp;1 &amp; 猜想测试 结论：command &gt;a.txt &amp;可以不在终端输出信息 6、&amp;总结 Command &amp; :&amp;的意思是在后台运行， 当你在执行 Command &amp; 的时候， 即使你用 ctrl+C, 那么Command照样运行（因为对SIGINT信号免疫）。 但是要注意， 如果你直接 关掉终端 后， 那么，Command进程同样消失（因为对SIGHUP信号不免疫）。 四、表格对比 命令方式 ctrl+c关闭后进程是否关闭 直接关闭终端后进程是否关闭 是否终端输出信息 nohup 关闭 不关闭 不输出，无论是否加上 &gt;nohup.out，信息都被导入到nohup.out（指定）文件 &amp; 不关闭 关闭 默认输出，但加上&gt;nohup.out则会不输出，信息被导入到nohup.out（指定）文件 五、实际应用鉴于它们个自的优缺点，一般都是这样用nohup command &gt; myout.file 2&gt;&amp;1 &amp;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Django开发安装MySQL-python解决过程","slug":"Django开发安装MySQL-python解决过程","date":"2018-12-19T09:52:13.000Z","updated":"2018-12-19T10:55:56.709Z","comments":true,"path":"2018/12/19/Django开发安装MySQL-python解决过程/","link":"","permalink":"http://yoursite.com/2018/12/19/Django开发安装MySQL-python解决过程/","excerpt":"","text":"一、前言这篇文章写的是我安装 MySQL-python遇到的问题，因为使用django开发所以我要和MySQL数据库连接，然后就死活安装不上，各种报错，折腾了一天多，终于解决了，趁着现在还有点印象，赶紧写下来，做个记录 1.问题描述django新建一个mysite项目，将数据库设置为MySQL，然后执行 pip install MySQL-python 安装数据库模块开始遇到的问题 2. 环境 macOS 10.13.6django 1.11.17python 2.7.10 二、解决问题历程 执行 pip install MySQL-python 报错 百度后说需要安装 mysql-connector-c 1brew install mysql-connector-c 如果有这种报错 那就按提示的输入命令解决（应该是brew unlink mysql），然后再次安装mysql-connector-c安装完后记得 安装成功后执行一次brew link mysql 安装 Command Line Tools 这个去苹果官网下就可以了 100多兆，网上说要下xCode，但是我没下xCode也成功了安装上这个了，所以不用下xCode就可以，终端输入 which gcc 查看 这时安装MySQL-python 肯定依然报错，反正我是这样 ，然后执行 export CC=’/usr/bin/gcc’export CFLAGS=’-isysroot/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk -I/opt/X11/include -arch i386 -arch x86_64’export LDFLAGS=’-arch i386 -arch x86_64’export ARCHFLAGS=’-arch i386 -arch x86_64’ 我也不知道这啥意思，惭愧惭愧。。。 安装 MySQL-python，还会报这个错误 这里要说明一下 之前我的mysql是通过下载dmg包那种方式安装的，但是现在没办法我卸载mysql后又用brew方式安装了一下，版本为 8.0.12 Homebrew 修改mysql配置文件：mysql_config 1234112 # Create options113 libs=&quot;-L$pkglibdir&quot;114 #libs=&quot;$libs -l &quot; ##注释掉源代码115 libs=&quot;$libs -lmysqlclient -lssl -lcrypto &quot; ##修改成这样 安装 MySQL-python 如果你的还报错，那我只能说再百度吧 ，离安装成功不远了， 因为我安装的时候也是疯狂报错，现在我回想的可 能不太全，因为我解决了好久 好了 现在安装好了MySQL-python ,然后执行 pip install MySQL-python， 妈的依然提示Did you install mysqlclient or MySQL-python? 好，在django根目录init.py文件里写上 12import pymysqlpymysql.install_as_MySQLdb() 执行pip install MySQL-python 报错 ImportError: No module named pymysql 然后安装 pip install pymysql 再次执行 python manage.py migrate 终于成功了，我差点哭出来 去数据库看，对应的表已经创建了","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"身份认证-jwt","slug":"身份认证-jwt","date":"2018-09-27T12:39:51.000Z","updated":"2018-12-19T10:58:34.915Z","comments":true,"path":"2018/09/27/身份认证-jwt/","link":"","permalink":"http://yoursite.com/2018/09/27/身份认证-jwt/","excerpt":"","text":"一、jwt简介关于jwt的概念网上有很多非常好的博客讲解，在这里就不解释了，看下面内容之前最好对jwt有个大致的了解。这里讲的是前后台怎么利用jwt进行身份验证。（react+axios+node） 二、基本逻辑1. 后台逻辑前台 /login 路由进入后，在账号密码正确的前提下创建一个 token(附带上过期时间等)，返回给前台，后续前台的每次请求，都需要经过后台的一个中间件来判断 token是否过期或者有误，如果有误，返回错误信息 2. 前台逻辑前台收到返回信息后，将token存储在localStorage或者cookie里，然后后续的每次的请求带上这个token 3.附加其实除了每次的请求要附带token检查有效之外，还需要在路由跳转的时候进行token检查，下面会说到三种方法 三、 后台代码所使用的包： express-jwt //用来验证token jsonwebtoken //用来生成token给客户端 当/login进入的时候，生成token返回12345678910111213141516171819202122232425262728//jwt.sign(payload, secretOrPrivateKey, [options, callback])// 登录exports.login = function(req, res) &#123; const &#123; user, pwd &#125; = req.body; UserModel.findOne(&#123; user: user, pwd: utility.md5(md5Pwd(pwd)) &#125;, &#123; pwd: 0 &#125;, (err, doc) =&gt; &#123; if (err) &#123; console.log(err) return res.json(&#123; code: 1, msg: '未知错误' &#125;) &#125; if (!doc) &#123; return res.json(&#123; code: 1, msg: '用户不存在或密码错误' &#125;) &#125; // 生成token // secretOrPrivateKey：用\"YMBo's club\"字符串加密 let token = jwt.sign(&#123; name: 'job', &#125;, \"YMBo's club\", &#123; expiresIn: 1 * 60 //过期时间1分钟 &#125;) return res.json(&#123; code: 0, data: doc, token &#125;) &#125;)&#125; /login后返回信息 每次有路由请求的时候对token判断是否过期添加一个中间件：123456789101112131415161718192021222324const expressJWT = require('express-jwt')const secret = \"ymb's club\"app.set(secret, secret)// jwt验证app.use(expressJWT(&#123; secret: secret&#125;, &#123; expiresIn: 60&#125;).unless(&#123; path: ['/user/login'] &#125;))// jwt验证,如果有错误（token不对，过期等错误）app.use(function(err, req, res, next) &#123; if (err.name === \"UnauthorizedError\") &#123; res.status(401).send(&#123; code: 1, msg: '请登录' &#125;); &#125;&#125;);app.use(bodyParser.json())app.use('/user', userRouter) 这里有一个关键点，当使用express-jwt进行token验证的时候，前台发过来的token必须是带 Bearer前缀的，比如token是aaa.bbb.ccc，那么应该格式化为 Bearer aaa.bbb.ccc 这种形式 四、 前台代码123// setLocalStorage是自定义的方法，存储tokensetLocalStorage('Authorization', `Bearer $&#123; res.data.token &#125;`)// 后台返回正确信息后 将token 存储在localStorage里 在项目的总入口或者次级入口加上这个，意思是后续的每一次axios请求都将携带Authorization信息1axios.defaults.headers.common['Authorization'] = getLocalStorage('Authorization'); 五、验证token1. 第一种方法上面说了后台添加中间件 express-jwt 来验证，网上的好多教程说的是通过一个单独的路由 /info，每次请求的时候先请求这个路由是否过期等，但是我觉得这种方法太浪费了，何必每次请求都要发送这个 /info这个验证请求呢 2. 第二种方法1234jwt.decode（token [，options]） //解密，注意了之前存储到localStorage里的token是带 Bearer 要把它去掉进行解密。//返回解码没有验证签名是否有效的payload。警告：这不会验证签名是否有效。它只是返回后端设置的payload// 特点：不用secretOrPrivateKey进行解密 前台的顶层路由（就是进别的路由都要经过的路由）进行判断，怎么判断呢？用 jsonwebtoken 这个包(上面用到过) 进行解密，然后取出设定的 expiresIn 过期时间，然后取到本地时间戳，与这个进行判断，看是否过期。 3. 第三种方法12345678910111213jwt.verify（token，secretOrPublicKey，[options，callback]）//验证token合法性// 去掉了Bearer let token = getLocalStorage('Authorization').replace(/Bearer\\s/, '');jwt.verify(token, \"ymb's club\", (err, decoded) =&gt; &#123; if (err) &#123; alert('过期了快去登录') this.props.history.push('/login') &#125;&#125;)//如果token没用了 直接返回err//用到了secretOrPrivateKey：用\"YMBo's club\"字符串解密，注意这个字段一定要和后台那个加密字段一致，否则它一致err 六、效果查看过期时间我设置的1分钟，为了方便调试 /login 返回token成功 返回token成功 后台express-jwt验证token成功 后台express-jwt验证token成功 路由跳转前验证token成功 路由跳转前验证token成功","categories":[],"tags":[]},{"title":"vue自定义父子组件组件v-model的通信","slug":"vue自定义父子组件组件v-model的通信","date":"2018-09-25T02:38:15.000Z","updated":"2018-12-19T10:58:34.913Z","comments":true,"path":"2018/09/25/vue自定义父子组件组件v-model的通信/","link":"","permalink":"http://yoursite.com/2018/09/25/vue自定义父子组件组件v-model的通信/","excerpt":"","text":"一、前言前些天写一个checkbox的vue组件的时候想用v-model来进行状态的判断，但是想到这了，却不知道v-model怎么在组件里面实现，这篇文章记录v-model的实现以及v-model的扩展。具体效果可以参考iview的 Checkbox组件和CheckboxGroup组件 二、分析 (功能描述)我想做两个组件 第一个叫 ButtonSelect 、 ButtonSelectGroup ButtonSelect : 其实这个组件就是一个checkbox复选框，只不过样式上进行的修改，我想在这上面绑定v-model，通过v-model来告诉父级组件当前的复选框状态(true/false)，ButtonSelect 的效果同iview的 Checkbox组件 CheckBox组件效果 ButtonSelectGroup : 当有多个 ButtonSelect 的时候，可以用 ButtonSelectGroup包裹ButtonSelect，然后通过 ButtonSelectGroup 上绑定 v-model ，来获得所有的选中项，格式是数组，效果同iview的 CheckboxGroup CheckboxGroup组件效果 三、关于v-modelv-model 双向绑定是一个很好用的功能，对于不同的组件v-model返回值也不同,但是这里只说说 checkbox复选框的v-model 单个复选框，绑定到布尔值 多个复选框，绑定到同一个数组官网描述 这里一定要仔细观察，当多个复选框的时候它的v-model的值是一样的，只有这样才能返回数组，而数组每一项的值就是checkbox的value值 1.自定义v-model（v-model传递）父组件===&gt;子组件：默认名为value的prop子组件===&gt;父组件：默认名为input的事件通过 value 和 input 来完成v-model的赋值和传递 但是有时候我们不想用value的input进行传递，name可以用model选项自定义：1234model: &#123; prop: 'checked', event: 'change'&#125;, 这样就变成了 prop为change 和 checked事件来代替value和input了 四、ButtonSelect的实现最顶级的组件ButtonSelectGroup、ButtonSelect的父组件，就叫他HelloWord组件12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;ButtonSelectGroup v-model=&quot;select&quot;&gt; &lt;ButtonSelect label=&apos;第一个&apos; &gt;&lt;/ButtonSelect&gt; &lt;ButtonSelect label=&apos;第二个&apos;&gt;&lt;/ButtonSelect&gt; &lt;ButtonSelect label=&apos;第三个&apos;&gt;&lt;/ButtonSelect&gt; &lt;/ButtonSelectGroup&gt; &#123;&#123;select&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ButtonSelect from &quot;./ButtonSelect.vue&quot;;import ButtonSelectGroup from &quot;./ButtonSelectGroup.vue&quot;;export default &#123; name: &apos;HelloWorld&apos;, components:&#123; &apos;ButtonSelect&apos;:ButtonSelect, &apos;ButtonSelectGroup&apos;:ButtonSelectGroup &#125;, data()&#123; return&#123; select:[] &#125; &#125;,&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;style&gt;@keyframes ani &#123; 0% &#123; background-color: #52c41a; -webkit-box-shadow: 0 0 5px #52c41a; box-shadow: 0 0 5px #52c41a; &#125; 50% &#123; background-color: #73d13d; -webkit-box-shadow: 0 0 10px #73d13d; box-shadow: 0 0 10px #73d13d; &#125; 100% &#123; background-color: #95de64; -webkit-box-shadow: 0 0 5px #95de64; box-shadow: 0 0 5px #95de64; &#125;&#125;.selectBut&#123; display: flex; flex-wrap: nowrap; margin: 5px; border-radius: 5px ; line-height: 30px; height: 30px; position: relative;&#125;.selectBox&#123; display: inline-block; overflow: hidden;&#125;.con&#123; padding:0 5px; box-shadow: 0 0 8px 0px #88d6f7; background: -webkit-linear-gradient(left,#5ec8ff,#4a9fd7); background: -o-linear-gradient(left,#63e77d,#3e8aa6); background: -moz-linear-gradient(left,#63e77d,#3e8aa6); background: linear-gradient(left,#63e77d,#3e8aa6);&#125;.check&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; cursor: pointer; opacity: 0; width: 100%; height: 100%; box-sizing: border-box; padding: 0; margin: 0;&#125;input.check:checked+.light&#123; /* background: #19be6b; */ animation: ani 3s infinite alternate;&#125;.num&#123; padding: 0 5px; border-radius:0 5px 5px 0; color: #fff; font-weight: bold; text-shadow: 0 -1px 1px #40a9ff; /* box-shadow: 0 0 8px 0px #88d6f7; */ background: -webkit-linear-gradient(left,#4a9fd7,#2d60a2); background: -moz-linear-gradient(left,#3e8aa6,#2c5d9d); background: -o-linear-gradient(left,#3e8aa6,#2c5d9d); background: linear-gradient(left,#3e8aa6,#2c5d9d);&#125;.lightbox&#123; position: relative; width: 20px; height: 100%;&#125;.light&#123; transition:all .5; background: #ccc; height: 100%; cursor: pointer; border-radius: 5px 0 0 5px;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;selectBox&quot;&gt; &lt;div class=&quot;selectBut&quot;&gt; &lt;div class=&quot;lightbox&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check&quot; :checked=&quot;currentValue&quot; @change=&quot;change&quot;/&gt; &lt;div class=&quot;light&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;con&quot;&gt; &lt;slot name=&quot;con&quot;&gt;ssss&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;num&quot;&gt; &lt;slot name=&quot;num&quot;&gt;aaa&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&apos;ButtonSelect&apos;, data()&#123; return&#123; //根据v-model初始化当前组件状态 currentValue:this.value &#125; &#125;, props:&#123; // v-model获取 value:&#123; type:[Array,Boolean], default:false &#125; &#125;, methods:&#123; change(event)&#123; var value=event.target.checked; // 赋值v-model this.$emit(&apos;input&apos;,value) &#125; &#125;&#125;&lt;/script&gt; 关键点： template的 inputscript:props的value和data里currentValue（获得初始状态）script: change里this.$emit(‘input’) 单个的复选框组件基本功能完成 五、ButtonSelectGroup组件实际应用中ButtonSelect会有很多个，我需要获取每一个的选中状态或者值（参考上面的CheckBoxGroup组件） 1. 分析 让多个checkbox返回数组的原理是什么？ 上面提到了，是给每一个checkbox相同的model，所以就要在父组件（ButtonSelectGroup）里给所有子组件（ButtonSelect）相同的v-model 当所有的子组件其中有一个改变的时候，应该给父组件返回变化后的数组，父组件（上面提到了，是给每一个checkbox相同的model，所以就要在父组件（ButtonSelectGroup）里给所有子组件（ButtonSelect）设置相同的v-model）再将该数组通过input事件返回给ButtonSelectGroup的调用者(ButtonSelectGroup的父组件)，完成v-model的传递 当ButtonSelectGroup的父组件给定一个初始v-model值的时候，需要把每一个ButtonSelect进行状态的变换 2. 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 寻找子组件function findComponentsDownward (context, componentName) &#123; return context.$children.reduce((components, child) =&gt; &#123; if (child.$options.name === componentName) components.push(child); const foundChilds = findComponentsDownward(child, componentName); return components.concat(foundChilds); &#125;, []);&#125;export default &#123; name:&apos;ButtonSelectGroup&apos;, props:&#123; value:&#123; type:Array, default()&#123; return [] &#125; &#125; &#125;, data()&#123; return&#123; childrens:[], &#125; &#125;, mounted()&#123; this.updateModel() &#125;, methods:&#123; updateModel()&#123; this.childrens = findComponentsDownward(this, &apos;ButtonSelect&apos;); if(this.childrens)&#123; const &#123; value &#125;=this; // 给子组件设置相同的model this.childrens.forEach(child=&gt;&#123; child.model=value; child.group = true; &#125;) &#125; &#125;, change(data)&#123; // 通知上级组件的v-model this.$emit(&apos;input&apos;,data); &#125; &#125;, watch: &#123; value () &#123; this.updateModel(); &#125; &#125;&#125;&lt;/script&gt; 注意注意注意 这里有一个非常非常非常重要的点，就是这个watch里面这个value监听触发updateModel方法，你可以尝试去掉这个watch是什么结果。我就在这里卡了好久。来解释一下原因：来一起想一下，子组件(ButtonSelect)的model是他爹(ButtonSelectGruop)给的，每次我点击了 ButtonSelect会通过this.parent.change(this.model) 来告诉父组件去更新使用的HelloWord里的 select，好了此时此刻我已经更新完了HelloWord里的 v-model(select),但是注意子组件（ButtonSelect）的v-model是通过 父组件 （ButtonSelectGroup）赋值过来了，并不能直接更改，所以ButtonSelectGruop如果不加 watch的value监听的话，子组件的v-model永远是[]，所以可以在ButtonSelect change的时候打印一下，每次数组一定是一个值，所以要用过watch监听，每一次HelloWord的v-model变动，都要重新给ButtonSelect赋值一次，这样才能达到预期目的 不加watch的样子： 不加watch 加watch的样子： 加watch 五、总结上面什么input事件、默认value什么的都还好理解，最最最重要的点就是上面说的watch来监听value，听我这么说可能云里雾里，需要自己动手实践一下，才能明白其中的意思","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"python格式化字符","slug":"python格式化字符","date":"2018-08-09T03:38:07.000Z","updated":"2018-12-19T10:58:34.911Z","comments":true,"path":"2018/08/09/python格式化字符/","link":"","permalink":"http://yoursite.com/2018/08/09/python格式化字符/","excerpt":"","text":"一、前言本文是我初学python对格式化字符操作中的一些相对疑难问题的记录和理解 二、python中格式化方法format1.简单用法对于format最简单的用法就是这样了123name='YMBo'age=18print '&#123;0&#125; is &#123;1&#125; years old'.format(name,age) 输出为 YMBo is 18 years old 对于这种字符串拼接也可以用这种方式：123name='YMBo'age=18print name+' and '+str(age) 注意！这种方式的字符串拼接类型都要为 str，所以age这一项要转为str，而format这中方式就不用 2.复杂用法123name='YMBo'print('lalallala :&#123;0:3&#125;'.format(name))# &#123;0:3&#125; 0：这里的 0 表示第几个参数，这里只有一个所以是 0 3：这个3表示输出宽度，如果输出宽度小于字符串宽度则最后输出宽度为字符串宽度 123name='YMBo'print('lalallala :&#123;0:^3&#125;'.format(name))# &#123;0:^3&#125; 这里多了个 ^表示右对齐 12print('lalallala :&#123;0:.3f&#125;'.format(1.0/3))# &#123;0:.3f&#125; 0表示第一个参数 ：后面没有数字表示宽度则自动分配 .3表示小数点后3位 f表示按照浮点数输出 12print(' :&#123;0:_^100.3f&#125;'.format(1.0/3))# &#123;0:.3f&#125; 这里的下滑线是填充文本 总结对比一下，python字符串格式化操作和JavaScript很相似的都有两种方式1.字符串和变量++++这种操作，但是python需要将不是str类型的变量转为str类型，而js不用2.python中’{}’.format()，js中`${}`这种操作","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"webpack配置代码分割","slug":"webpack配置代码分割","date":"2018-05-21T10:05:27.000Z","updated":"2018-12-19T10:58:34.914Z","comments":true,"path":"2018/05/21/webpack配置代码分割/","link":"","permalink":"http://yoursite.com/2018/05/21/webpack配置代码分割/","excerpt":"","text":"一、前言webpack 4.0 使用 optimization.splitChunks.cacheGroups 配置项来进行包的拆分，其实默认情况下，webpack是会自动帮我们分割的，但是有时候我们可能也需要自定义配置，下面来说下我对这个配置项的理解，如有错误，烦请指出 二、配置项说明 cacheGroups 用这个配置项来自定义生成的文件 test 限制范围，可以是正则，匹配文件夹或文件 name 生成的文件名 priority 优先级，当有chunks满足多个分组条件的时候，优先选择优先级高的 minSize 分出来的包最小尺寸必须大于此值，默认30000B minChunks 表示分离前被引用次数,默认为1 maxInitialRequests 最大初始化加载次数，一个入口文件可以并行加载的最大文件数量，默认1 maxAsyncRequests 最大按需加载次数，最大异步加载次数，默认1 enforce: true 优先处理，这一项好像和priority有些重叠了 reuseExistingChunk:true 表示可以使用已经存在的块，即如果满足条件的块已经存在就是用己有的的，不再创建一个新的块 chunks 值为”initial”, “async”（默认） 或 “all” initial 入口chunk，对于异步导入的文件不处理 async 异步chunk，只对异步导入的文件处理 all 全部chunk 12.1234567891011121314151617181920runtimeChunk: &#123; name: 'manifest' /* 管理被分出来的包，runtime 指的是 webpack 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单， 模块信息清单在每次有模块变更(hash 变更)时都会变更 */&#125;,cacheGroups:&#123;//设置缓存chunks priority: 0,//缓存组优先级 //当需要优先匹配缓存组的规则时，priority需要设置为正数，当需要优先匹配默认设置时，缓存组需设置为负数，0为两者分割线 default:&#123;//设置缓存组默认配置，可通过default:false禁用默认缓存组， //然后就可以自定义缓存组，将初始化加载时被重复引用的模块进行拆分 minChunks:2,//引用两次 priority:-20,//缓存组优先级为-20 reuseExistingChunk:true,//表示可以使用已经存在的块，即如果满足条件的块已经存在就是用己有的的，不再创建一个新的块 &#125;， [key]:&#123;//自定义缓存组，可以根据需求，自由创建 chunks:'initial', test: /vue/,//正则规则验证，如符合就提取chunk放入当前缓存组，值可以是function、boolean、string、RegExp，默认为空 enforce: true//优先处理 &#125;&#125; 三、疑难配置项 maxInitialRequests :这个配置项我一直很不理解，网上的很多资源都是千篇一律，有用的基本没有，后来我发现了这篇文章 关于webpack模块拆分规则 让我有对这个配置项有了点浅显的了解 现在说说我的理解，举个小例子：这是一个多页应用，index.js和shop.js是入口文件我的目录结构： 目录结构 ； 这是webpack分割代码1234567891011121314151617181920212223runtimeChunk: &#123; name: 'manifest'&#125;,splitChunks: &#123; cacheGroups: &#123; //项目公共组件 common: &#123; chunks: 'initial', name: 'common', minChunks: 2, maxInitialRequests: 3, //最大初始化加载次数，一个入口文件可以并行加载的最大文件数量，默认1 minSize: 0 //表示在分离前的最小模块大小，默认为0，最小为30000 &#125;, //第三方组件 vendor: &#123; test: /node_modules/, chunks: \"initial\", name: \"vendor\", priority: 10, enforce: true &#125; &#125;&#125; 现在先别急着看分包结果，先来分析一下：其中除了React、ReactDOM是第三方包以外剩下的都是自定义组件 index.js(入口文件)：React、ReactDom、index.jsx(index目录下)shop.js(入口文件)：React、ReactDom、index.jsx(shop目录下)index.jsx(shop目录下)：React、Header.jsx、A.jsx、B.jsx、shop.cssindex.jsx(index目录下)：React、A.jsx、index.cssA.jsx：React、Common.cssB.jsx：React、b.css、common.css那么画出的依赖图就是这个样子： 目录结构 这里来自 node_modules 的包肯定是被打包到 vender 里了，不用管这个，主要是看 common 这个包的信息 暂且忽略掉maxInitialRequests这个配置（当然代码里是不能忽略的因为有默认值，想象这一项不起作用就行了），如果按照使用次数超过2次，大小超过0的包，打包到一起，那么结果是这样的： Common（chunks）：A.jsx、Common.cssvender（chunks）：第三方shop.js（chunks）：Header.jsx、B.jsx、b.css、shop.cssindex.js（chunks）：index.css 那么此时的maxInitialRequests（初始加载次数）是：shop页入口：shop.js、vender、Common 一共三次 index页入口：index.js、vender(chunks)、Common 一共三次 如果此时我限制了 maxInitialRequests：2 为2的话，那么结果是这样的 vender（chunks）：第三方shop.js（chunks）：Header.jsx、B.jsx、b.css、shop.css、A.jsx、Common.cssindex.js（chunks）：index.css、A.jsx、Common.css shop页入口：shop.js、vender 一共两次 index页入口：index.js、vender一共两次看截图： maxInitialRequests：2的情况 maxInitialRequests：3或大于三的情况 可以看到以上的分析是正确的 四、总结不过话说会来，如果每次配置wepback的这一项都按这么分析，那得累死，可以这么分析，每次页面初始加载我想让它的并发请求不超过自己的预期就可以了","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack4.0中的mode和.babelrc的env.development配置项目","slug":"webpack4-0中的mode和-babelrc的env-development配置项目","date":"2018-04-12T06:29:57.000Z","updated":"2018-12-19T10:58:34.913Z","comments":true,"path":"2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","link":"","permalink":"http://yoursite.com/2018/04/12/webpack4-0中的mode和-babelrc的env-development配置项目/","excerpt":"","text":"一、前言之前写过怎么在webpack中使用react-hot-loader做热更新功能，不得不说是真的非常麻烦，今天发现了更好用的办法来记录一下 1.这篇文章讲的什么？1.更简单的配置 热更新的方法2.webpack4.0的mode配置项有啥用？3.babelrc中的env.development是干啥的？ 二、热更新注意，本部分着重讲解的是热更新，至于上面提到的2和3放在下个部分webpack.config.js的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const webpack=require('webpack')const opn=require('opn')const merge=require('webpack-merge')const path=require('path')const baseWebpackConfig=require('./webpack.base.config')const webpackFile=require('./webpack.file.config')const htmlWebpackPlugin=require('html-webpack-plugin')let config=merge(baseWebpackConfig,&#123; mode:'development', output:&#123; path:path.join(webpackFile.devDirectory), filename:'js[name].[hash].js', publicPath:'' &#125;, plugins:[ /*热更新*/ new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin(&#123; template:path.join(__dirname,'../template/index.html') &#125;) ], module:&#123; rules:[ &#123; test:/\\.(js|jsx)$/, use:'babel-loader', include:[ path.join(__dirname,'../client') ], exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, devServer:&#123; host:'0.0.0.0', port:'8888', hot:true, overlay:&#123; errors:true &#125;, contentBase:path.join(__dirname,webpackFile.devDirectory), historyApiFallback: true, proxy:[ &#123; context:['/api'], target:'localhost:8888', secure: false &#125; ], /*打开浏览器*/ after()&#123; opn('http://localhost:'+this.port) &#125; &#125;&#125;)module.exports=config; .babelrc 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; package.json文件的启动命令1\"dev\": \"webpack-dev-server --config build/webpack.dev.config.js\" 现在配置热替换仅需三个步骤 webpack中devServer.hot=true webpack中plugins添加new webpack.HotModuleReplacementPlugin() ‘.babelrc’文件中使用 react-hmre （npm i babel-presets-react-hmre）预设 配置完成是不是很简单？看看执行结果 hmr 三、webpack4.0的mode配置项有啥用？mode配置项会告诉webpack使用相应的内置优化 webpack运行时还会根据mode设置一个全局变量process.env.NODE_ENV,这里的process.env.NODE_ENV不是node中的环境变量,而是webpack.DefinePlugin中定义的全局变量,允许你根据不同的环境执行不同的代码. 参数： 选项 描述 development Provides process.env.NODE_ENV with value development. Enables NamedChunksPlugin and NamedModulesPlugin. production Provides process.env.NODE_ENV with value production. Enables FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin and UglifyJsPlugin. 从网上找到了更详细的优化说明列出了针对这两种情况做的对应优化development1234567891011121314151617181920//调试devtool:eval//缓存模块, 避免在未更改时重建它们。cache:true//缓存已解决的依赖项, 避免重新解析它们。module.unsafeCache:true//在 bundle 中引入「所包含模块信息」的相关注释output.pathinfo:true//在可能的情况下确定每个模块的导出,被用于其他优化或代码生成。optimization.providedExports:true//找到chunk中共享的模块,取出来生成单独的chunkoptimization.splitChunks:true//为 webpack 运行时代码创建单独的chunkoptimization.runtimeChunk:true//编译错误时不写入到输出optimization.noEmitOnErrors:true//给模块有意义的名称代替idsoptimization.namedModules:true//给模chunk有意义的名称代替idsoptimization.namedChunks:true production1234567891011121314//性能相关配置performance:&#123;hints:\"error\"....&#125;//某些chunk的子chunk已一种方式被确定和标记,这些子chunks在加载更大的块时不必加载optimization.flagIncludedChunks:true//给经常使用的ids更短的值optimization.occurrenceOrder:true//确定每个模块下被使用的导出optimization.usedExports:true//识别package.json or rules sideEffects 标志optimization.sideEffects:true//尝试查找模块图中可以安全连接到单个模块中的段。- -optimization.concatenateModules:true//使用uglify-js压缩代码optimization.minimize:true 例如: 12345if(process.env.NODE_ENV === 'development')&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 最终将编译成 12345if(true)&#123; //开发环境 do something&#125;else&#123; //生产环境 do something&#125; 生产环境下,uglify打包代码时会自动删除不可达代码,也就是说生产环境压缩后最终的代码为:1//生产环境 do something 四、babelrc中的env.development是干啥的？env选项可以针对特定环境进行设置。此env值会从process.env.BABEL_ENV中获取；如果该值不存在，会使用process.env.NODE_ENV；二者都不存在，使用默认值”development”。 启动命令设置process.env.BABEL_ENV1\"dev\": \"cross-env BABEL_ENV=development webpack-dev-server --config build/webpack.dev.config.js\" 123456789&#123; \"presets\":['react','env'], \"env\":&#123; /*开发环境下执行*/ \"development\":&#123; \"presets\":[\"react-hmre\"] &#125; &#125; &#125; 这样就会执行”development”下配置的内容","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react生命周期详解","slug":"react生命周期详解","date":"2018-03-27T09:11:54.000Z","updated":"2018-12-19T10:58:34.913Z","comments":true,"path":"2018/03/27/react生命周期详解/","link":"","permalink":"http://yoursite.com/2018/03/27/react生命周期详解/","excerpt":"","text":"一、react生命周期 componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentUnmount每个生命周期概念不是本文讲解重点，重点是生命周期在组件渲染时候容易造成的混淆 二、componentWillReceiveProps 和 componentWillUpdate ？？componentWillReceiveProps ： 组件接收到一个新的props会被调用，在初始化render时不会调用componentWillUpdate : 组件接收到系的props或state时被调用，初始化不会被调用 看起来好像一样啊，有什么区别呢？来看下面 1.来做测试先定义两个组件，App和Son，我们的目的就是看看上面提到的两个生命周期的不同，所以这一部分暂不讨论每个生命周期执行顺序，留在下一节讨论。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;App点我&lt;/button&gt; &lt;Son word=&#123;this.state.word&#125; /&gt; &lt;/div&gt; ) &#125;&#125;class Son extends Component&#123; constructor()&#123; super() this.state=&#123; word:'' &#125; &#125; componentWillMount()&#123; console.log('儿子生命周期：componentWillMount') this.setState(&#123; word:this.props.word &#125;) &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; this.setState(&#123; word:this.state.word ==='儿子' ? '孙子':'儿子' &#125;) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 逻辑很简单，父组件和子组件都可以通过各自的按钮改变子组件文字的内容 先点击 儿子按钮 按钮，也就是子组件Son里的按钮 执行结果 可以看到 componentWillReceiveProps 没有执行 然后点击 APP点我 按钮：点之前： 点之前 点之后： 点之后 可以看到子组件的文字并没有发生变化，执行了上图中的这些生命周期方法。 所以可以得到结论：componentWillReceiveProps触发条件是props更新，而componentWillUpdate触发条件是props或者states更新，上面说的时候也着重标记了 为了让父组件的按钮能更改子组件的内容，我需要在componentWillReceiveProps或componentWillUpdate里写上123this.setState(&#123; word:nextprops.word&#125;) 官网上说不能写在componentWillUpdate里，建议写在componentWillReceiveProps，我就不明白了，我非得写在componentWillUpdate里，看看执行结果 报错 看 死循环了，因为上面提到componentWillUpdate触发条件是 states 变化 和 props变化，写在了这里就不停的setState states的值，所以就不停的触发componentWillUpdate，因此像这种父组件更改子组件的内容应该写在 componentWillReceiveProps 里，来试试： ojbk 好，一切正常！ 总结： 名称 componentWillReceiveProps componentWillUpdate 触发条件 props变化 props或states变化 注意事项 setState的更新要写在componentWillReceiveProps里 三、生命周期执行顺序还是上面的例子 1.初始化时父子组件的声明周期执行顺序 结果 2.点击父组件的按钮时生命周期执行顺序 结果 3.点击子组件执行顺序 结果 4.还有一种情况，点击子组件触发父组件内容的更改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Son extends Component&#123; ponentWillMount()&#123; console.log('儿子生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('儿子生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('儿子生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('儿子生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('儿子生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('儿子生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('儿子生命周期：componentWillUnmount') &#125; handleClick()&#123; var word=this.props.word === '儿子' ? '孙子':'儿子' this.props.click(word) &#125; render()&#123; console.log('儿子：render') return( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;儿子按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component&#123; constructor()&#123; super() this.state=&#123; word:'儿子' &#125; &#125; componentWillMount()&#123; console.log('他爹生命周期：componentWillMount') &#125; componentDidMount()&#123; console.log('他爹生命周期：componentDidMount') &#125; componentWillReceiveProps(nextprops)&#123; console.log('他爹生命周期：componentWillReceiveProps') &#125; shouldComponentUpdate()&#123; console.log('他爹生命周期：shouldComponentUpdate') return true; &#125; componentWillUpdate(nextprops,nextstates)&#123; console.log('他爹生命周期：componentWillUpdate') &#125; componentDidUpdate()&#123; console.log('他爹生命周期：componentDidUpdate') &#125; componentWillUnmount()&#123; console.log('他爹生命周期：componentWillUnmount') &#125; handleClick(word)&#123; this.setState(&#123; word:word &#125;) &#125; render()&#123; console.log('他爹render') return( &lt;div&gt; &#123;this.state.word&#125; &lt;Son word=&#123;this.state.word&#125; click=&#123;this.handleClick.bind(this)&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 结果 上述的几种执行结果也很简单，看一看就会执行顺序就会变得清晰了","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"body-parser使用注意","slug":"body-parser使用注意","date":"2018-03-08T07:53:13.000Z","updated":"2018-12-19T10:58:34.907Z","comments":true,"path":"2018/03/08/body-parser使用注意/","link":"","permalink":"http://yoursite.com/2018/03/08/body-parser使用注意/","excerpt":"","text":"一、前言这几天在学习服务端渲染的时候用到了这个包 body-parser ,很方便的一个包，这个模块提供了四种解析器 JSON body parser Raw body parser Text body parser URL-encoded form body parser 每一项详细的配置都能在网上找到，这篇记下的是我在使用中遇到的问题 bodyParser.json(option)和bodyParser.urlencoded(option)的不同，在网上搜这个问题，得到的答案还是让我一头雾水，终于试了几次并结合资料弄清楚两者的使用场景 二、区别看官方的解释：bodyParser.json(options)：中间件只会解析 json ，允许请求任意Unicode编码,支持 gzip 和 deflate 编码。 bodyParser.urlencoded(option)：中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。(tip:一般这一项是接收表单提交form) 三、例子看到这里我明白了一个接受form请求，一个接受json请求，好，我写了下面的例子：12345678910111213141516171819202122232425262728293031323334//server端关键代码var jsonParser =bodyParser.json();app.post('/login',jsonParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;)//客户端请求&lt;form method=\"post\" action=\"/login\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputTitle\" class=\"col-sm-3 control-label\"&gt;电影名称&lt;/label&gt; &lt;input id=\"inputTitle\" type=\"text\" name=\"title\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputLanguage\" class=\"col-sm-3 control-label\"&gt;海报&lt;/label&gt; &lt;input id=\"inputLanguage\" type=\"text\" name=\"poster\" value=\"\" class=\"form-control\" /&gt; &lt;/div&gt;&lt;button type=\"submit\" class=\"btn btn-default\"&gt;确定&lt;/button&gt;&lt;/form&gt;setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 客户端有一个用于测试的表单和一个1s后发送post请求的ajax 先看一下表单请求的结果： 表单请求 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到bodyParser.json()并没有解析到ajax和form表单请求，现在来换bodyParser.urlencoded(option)的解析方式12345var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);app.post('/login',urlencodedParser,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;) 表单方式请求后服务端返回结果 ajax方式请求后服务端返回结果 可以看到这种解析方式成功将请求解析到了body里。到了这里，我又有疑问了，知道了bodyParser.urlencoded期望的数据形式，那bodyParser.json适用于什么情况呢？ 看下面例子，既然api说bodyParser.json适用于json的数据类型，所以我将ajax的content-Type设置为json 123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:&#123; url:'login', name:'123', password:123456 &#125;, success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 请求结果： 返回结果 请求失败，那么疑问来了，我设置了json格式的请求，为什么bodyParser.json解析不了 关键： jq的ajax 默认的ContentType的值为:application/x-www-form-urlencoded; charset=UTF-8此格式为表单提交格式，数据为 key1=value1&amp;key2=value2的格式 虽然ajax的data属性值格式为:{key1:value1,key2:value2},但最后会转为key1=value1&amp;key2=value2的格式提交到后台 如果想传json格式数据，content-type设置好后，ajax必须将date属性值转为json字符串，不能为json对象（js对象，会自动转为key=value形式）,这样传输的时候才是json格式 我们来试一下：123456789101112131415setTimeout(function()&#123; $.ajax(&#123; type:'post', url:'login', contentType:'application/json', data:JSON.stringify(&#123; url:'login', name:'123', password:123456 &#125;), success:function(data)&#123; console.log(data) &#125; &#125;)&#125;,1000) 返回结果 现在就可以请求成功啦","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"mobx基本用法","slug":"mobx基本用法","date":"2018-03-06T01:59:46.000Z","updated":"2018-12-19T10:58:34.911Z","comments":true,"path":"2018/03/06/mobx基本用法/","link":"","permalink":"http://yoursite.com/2018/03/06/mobx基本用法/","excerpt":"","text":"一、前言本文是我初学mobx时对mobx一些基本的认识，如果新发现会继续更新 二、redux和mobx相同点：都是用来管理JavaScript应用的状态，他们不一定要跟react结合使用，还可以与别的框架结合 不同点： redux学习成本相对于mobx成本要高很多，有reducer、action、dispatch等概念，规则多，比如更新数据必须要用 dispatch，更新的逻辑必须要用 action，刚学的时候可能有点懵。mobx比较自由，可以用obj.key 的方式更新 redux更新数据的时候，要将更新数据的整个对象替换为一个新的对象才可以触发更新(这点接触过redux的会有感受)，而mobx自始至终是一份引用，所以redux每次会触发很多的组件的重新渲染，为了优化会配合immutable。mobx则是更新哪个属性，仅仅这个属性所在的位置会重新渲染（不是组件的重新渲染，不触发componentWillMount等方法，会触发componentWillUpdata） 以上为自己理解，如有错误烦请指出 三、mobx基本概念 tip:以下提到的 @ 是ES7里的修饰器，可以到网上找资源学习 es7的修饰器 1. @observable 将属性转为可观察的，一旦发生变化，则变量所处的位置会立即发生变化 2. @computed这是一个有点不好理解的API，而且官网描述的也不是很清楚，下面是我的理解，如果有误，请指出讲这个API之前先看一下下面的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************mobx********************************/import &#123; observable ,computed,autorun,action &#125; from 'mobx'class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125;&#125;const appState = new AppState;setInterval(()=&gt;&#123; appState.add()&#125;,2000)export default appState;/************************************index.jsx********************************/import React,&#123; Component &#125; from 'react'import &#123;observer,inject&#125; from 'mobx-react'import PropTypes from 'prop-types'@inject('appState')@observerexport default class TopicList extends Component&#123; constructor()&#123; super() this.changeName=this.changeName.bind(this) &#125; componentWillUpdate()&#123; console.log('更新！') &#125; changeName(event)&#123; this.props.appState.changeName(event.target.value) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=\"text\" onChange=&#123;this.changeName&#125;/&gt; &lt;span&gt;&#123;this.props.appState.msg&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;&#125;TopicList.propTypes=&#123; appState:PropTypes.object&#125; 逻辑是有两个变量 count和max，在msg的getter里判断max&gt;count的情况,其中max为固定值，count每秒+1。 在第二节的redux和mobx异同之处提出了mobx数据变化的时候组件只会触发 componentWillUpdata （没什么来源，自己试的），下面来看看上面代码 (mobx里msg部分加了 @computed) 运行情况： 可以看到只有当 msg 值发生变化的时候，才会触发 componentWillUpdata ，也就是前5s msg的结果一直为 true时，组件里是没有接收到新的 {this.props.appState.msg} 的（因为接受新的props值会触发 componentWillUpdata） 下面再来看看 mobx里msg部分不加 @computed 运行情况1234get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;`&#125; 不加 @computed 可以看到每一次的count值变化都会触发组件的componentWillUpdata 看明白了上面的例子和运行时的不同，再看看下面的总结就会好理解了 总结：如果使用了@computed （@computed msg getter()），那么msg的值将会被缓存，如果count的变化没有触发msg值的变话，那么msg的getter()值就不会改变，index.jsx组件也不会收到通知(componentWillUpdata)。（第一种情况） 如果不使用@computed属性，直接msg getter()的话，那么一旦count改变，所有用到msg getter()的地方都将重新计算(第二种情况)。 @computed的意义在于它能够由MobX进行更智能的优化 3. autorun 定义的 @observable 变量如果发生变化，autorun会自动执行相应的方法,例如将上面的mobx修改，index.jsx不变 1234567891011121314151617181920212223242526 import &#123; observable ,computed,autorun,action &#125; from 'mobx' class AppState &#123; @observable count=0; @observable max = 5; @computed get msg()&#123; console.log('msg的getter里执行...') return `msg结果===&gt;$&#123;this.max&gt;this.count&#125;` &#125; @action add()&#123; this.count +=1; &#125; @action changeName(c)&#123; this.max=c &#125; &#125; const appState = new AppState;// 添加了 autorun autorun(()=&gt;&#123; console.log(`$&#123;appState.count&#125; 运行运行~`) &#125;) setInterval(()=&gt;&#123; appState.add() &#125;,1000) export default appState; 因为autorun里的函数依赖了 count ，所以每一次setInterval的时候，都会执行autorun里的函数 4. @action 如果要更新store里的内容，就要在相应的函数前加上 @action 例如上面的例子，标记为@action 。 作用：在mobx-react高级渲染性能优化小节中，我们知道，使用transaction可以将多个应用状态(Observable)的更新视为一次操作，并只触发一次监听者(Reactions)的动作(UI更新、网络请求等)，从而更大程度地提升应用的性能，避免多余的UI渲染和网络请求。action中封装了transaction，对函数使用action修饰符后，无论函数中对@observable变量（应用状态）有多少次修改，都只会在函数执行完成后，触发一次对应的监听者。如下代码，reset函数只会触发一次UI更新。 123456789101112class TodoItemModel &#123; id; @observable title; @observable completed; //使用action后，reset函数执行完成后，才会触发一次其监听者 @action reset() &#123; this.completed = false; this.title= ''; &#125;&#125; 5. @oberver observer 函数/装饰器可以用来将 React 组件转变成响应式组件 oberver是用来连接mobx与组件的一个API（告诉mobx本组件依赖于mobx的状态），由一个单独的包 mobx-react 提供，例子看上面的 index.jsx组件。使用了 observer 的react组件中用到的变量发生变化，组件才会更新 四、运行环境的配置@(修饰器)是ES7的一个提案，Babel 转码器已经支持 Decorator需要安装 babel-preset-stage-1 （stage-0也可以）和babel-plugin-transform-decorators，babel-plugin-transform-decorators一定要放在别的plugins前 .babelrc配置 6. useStaticRendering我们知道可以通过使用@observer，将react组件转换成一个监听者(Reactions)，这样在被监听的应用状态变量(Observable)有更新时，react组件就会重新渲染。而对于服务端的React组件，我们只需要它被渲染一次，而不需要组件监听模型的状态。事实上，如果服务端React组件像客户端组件一样监听模型的状态变化，就会造成严重的内存泄漏问题。官方提供了useStaticRendering方法，用于避免mobx服务端渲染的内存泄漏问题; 该方法只需要在server启动时设置一次。 useStaticRendering(true);","categories":[],"tags":[{"name":"mobx","slug":"mobx","permalink":"http://yoursite.com/tags/mobx/"}]},{"title":"javascript的数据属性和访问器属性","slug":"javascript的数据属性和访问器属性","date":"2018-02-28T03:25:55.000Z","updated":"2018-12-19T10:58:34.910Z","comments":true,"path":"2018/02/28/javascript的数据属性和访问器属性/","link":"","permalink":"http://yoursite.com/2018/02/28/javascript的数据属性和访问器属性/","excerpt":"","text":"一、数据属性1.基本认识1.1概念数据属性包含一个数据值的位置，在这个位置可以读取和写入值 数据属性有4个描述其行为的特性 [[Configurable]] : 表示能否通过 delte 删除属性从而重新定义属性，能肉修改属性的特性，或者能把属性修改为访问器属性。默认true [[Enumerable]] : 表示能否通过 for-in 循环返回属性。 默认 true [[Writable]] : 表示能否修改属性的值 。 默认 true [[Value]] : 包含这个属性的数据值。 默认 undefined tip：为了表示特性是内部值，该规范把他们放在了两对括号中 2.对数据属性的操作必须使用 ECMAScript 5 的 Object.defineProperty() 方法三个参数 属性所在的对象 属性的名字 描述符对象 栗子12345678910111213var person = &#123; name:'y'&#125;//禁止修改属性值Object.defineProperty(person,\"name\",&#123; writable:false&#125;)console.log(person.name) // y//尝试修改属性person.name='b';console.log(person.name) //y//可以看到禁止修改属性的值后，修改属性值无效 2.1注意！！！这四个数据属性中，configurable 是比较特殊的，一旦把属性定义为不可配置的，就不能再把它变回可配置了，此时再调用 Object.defineProperty 方法修改 除writable之外的特性 都会导致失败。1234567891011121314151617181920212223242526272829303132333435var b=&#123; age:0&#125;//定义为不可配置Object.defineProperty(b,'age',&#123; configurable:false&#125;)//尝试删除配置delete b.ageconsole.log(b.age)// 成功打印0//尝试修改enumerableObject.defineProperty(b,\"age\",&#123; enumerable:false&#125;)/* 报错：Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:3:8 *///尝试修改writableObject.defineProperty(b,\"age\",&#123; writable:false&#125;)/*修改成功，不会报错*///尝试修改valueObject.defineProperty(b,\"age\",&#123; value:1&#125;)/*报错：VM17512:1 Uncaught TypeError: Cannot redefine property: age at Function.defineProperty (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:8*/ tip:上面的操作只针对于 b对象的age 属性，所以此时我再添加一个属性也是成功的，比如123b.name='m';console.log(b)// 输出 &#123;age: 0, name: \"m\"&#125; tip2:ES5有三个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 二、访问器属性1.基本认识概念访问器属性不包含数据值。它包含一对getter和setter函数。当读取访问器属性时，会调用getter函数并返回有效值；当写入访问器属性时，会调用setter函数并传入新值，setter函数负责处理数据。 访问器属性的四个特性 [[Configurable]]：默认为true。表示能否通过delete删除属性从而重新定义属性，能否修改属性特性，或者能否把属性修改为访问器属性； [[Enumerable]]：默认为true。表示能否通过for-in循环返回属性； [[Get]]：读取属性时调用的函数，默认为undefined； [[Set]]：写入属性时调用的函数，默认为undefined； 2.对访问器属性的操作 tip :1.当使用了getter或setter方法，不允许使用 writable 和 value 这两个属性。2.get和set 函数不是必须的3.先看这种写法： 特别要注意这种写法，容易写错！ 可以看到 堆栈溢出 了，` 原因是因为如果在get里return this.year ，这样如果我们在外面 book .year时，就会运行get函数，而get函数里面执行到this.year时又会运行get函数，造成死循环。正常写法是利用一个中间值来设置某一个属性，看下面代码 正确写法 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。一般上面上面代码目的是 设置一个属性的值会导致其他属性发生变化，就不用把属性单拿出来计算了，很方便 三、总结1.到底怎么判断是数据属性还是访问器属性可以通过 Object.getOwnPropertyName()方法获取到所有实例中的属性，包括不可枚举的属性。然后，使用Object.getOwnPropertyDescriptor(）方法获取到每一个属性的描述符，如果描述符中有get/set方法，说明它是访问器方法，否则它就是数据属性。其实由于两种属性各自的4种特征都是都不一样的，如果一个对象的属性描述符里含有一个单独的特征就可以判断是什么类型的属性，比如1234var book=&#123;&#125;;Object.defineProperty(book,'age',&#123; value:5&#125;) 描述符里我单独定义了value属性，而value属性仅仅输入数据属性，所以可以判断出 age属于数据属性 2.定义多个属性Object.defineProperty()这种写法每次只能定义一个属性，那么可以通过 Object.defineProperties 来定义多个属性定义多个属性：请注意下面图片内代码是有问题的，这是《js高级程序设计》 里的例子 定义多个属性 这个方法定义多个属性没问题，但是也可以从上面的图看出来，定义的访问器属性year的set方法里面并没有生效，这俩属于数据属性，原因是因为 定义的_year属性和edition属性不能往里面写值了。 自己解决历程：我自己猜想原因可能是这样，因为_year和edition写不进去值了，所以设置 enumerable 为true。我尝试修改了一下，如下 给两个数据属性添加了writable(可读写 )特征 这样运行成功。为了验证猜想，做了如下例子： 所有特性 ； 可以看到只要是用 Object.defineProperties() 定义的对象的属性，那么定义过的每个属性描述符的4个默认属性（除了set和get外）都默认都是 false 总结：使用 Object.defineProperties() 方法来定义多个属性的时候，每个属性的描述符里的属性都是默认的false(除了set和get外)，set或者get没定义的话默认 undefined 四、实际应用介绍了这个东西后，在实际中我该在什么情况用呢？ 数据双向绑定 （Module&lt;==&gt;View）数据双向绑定就是通过 Object.defineProperty 实现的，我们来手写一个数据绑定 &lt;input class=\"inputText\" type=\"text\" /&gt; &lt;p class=\"text\"&gt;&lt;/p&gt; var inputText=document.querySelector('.inputText'); var text=document.querySelector('.text'); //module var obj={_txt:null}; Object.defineProperty(obj,'txt',{ get:function(){ return this._txt; }, set:function(value){ this._txt=value; text.innerHTML=value; inputText.value=value } }) //view inputText.addEventListener('input',function(e){ const text=e.target.value; obj.txt=text; },false) 此时在input输入值的时候p的内容和obj.txt内容会变，在浏览器console中更改obj.txt的值，input和p也会变","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"受控组件和非受控组件","slug":"受控组件和非受控组件","date":"2018-02-07T02:48:32.000Z","updated":"2018-12-19T10:58:34.914Z","comments":true,"path":"2018/02/07/受控组件和非受控组件/","link":"","permalink":"http://yoursite.com/2018/02/07/受控组件和非受控组件/","excerpt":"","text":"一、前言在HTML中，表单元素例如 input , textarea , select 通常是根据用户的输入来维护它们自己的状态。在React中，可变状态通常保存在 state 中，只能用 setState() 来进行更新操作 二、定义解释正如上面所说，表单元素的数据可以由自身DOM元素来管理，也可以由React组件来管理 1.controlled_Component ( 受控组件 )将表单状态保存在React组件中（state），呈现表单的React组件也会控制用户输入后所发生的情况。表单元素数据托管到React组件中的这种方式叫做 受控组件 React能控制 2.uncontrolled_Component ( 非受控组件 )与受控组件相反，表单数据由dom元素自身管理的组件叫 非受控组件 React不能控制 三、栗子1.controlled_Component ( 受控组件 )12345678910111213141516171819202122232425262728class App extends Component &#123; constructor()&#123; super() this.state=&#123; name:'姓名', text:'请输入' &#125; &#125; handleName(e)&#123; this.setState(&#123; name:e.target.value &#125;) &#125; handleText(e)&#123; this.setState(&#123; text:e.target.value &#125;) &#125; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' value=&#123;this.state.name&#125; onChange=&#123;this.handleName.bind(this)&#125;/&gt; &lt;textarea name=\"text\" value=&#123;this.state.text&#125; onChange=&#123;this.handleText.bind(this)&#125;&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都交给了React组件来管理。 注意 :这种情况下每个表单元素必须要有 onChange 事件，这样用户每次操作对应的元素，对应元素数据才能得到改变 2.uncontrolled_Component ( 非受控组件 )123456789101112/*uncontrolled Component*/class App extends Component &#123; render()&#123; return( &lt;form method='get' action=\"/\"&gt; &lt;input type=\"text\" name='name' defaultValue='姓名'/&gt; &lt;textarea name=\"text\" defaultValue='想法'&gt;&lt;/textarea&gt; &lt;input type=\"submit\"/&gt; &lt;/form&gt; ) &#125;&#125; 可以看到 input 和 textarea的value值全都是由自身DOM元素来管理的。 注意 :非受控组件这功中，通常你需要指定表单元素的初始值，但不控制后续的更新，这种情况需要指定 defaultValue 属性，而不是 value属性如果你不想让他有初始值，也可以不用写 defaultValue 三、两者优缺点？ name 优点 缺点 非受控组件 简练、操作数据的方式更简洁 表单验证 、选择性开启或者关闭按钮 等功能不能处理 受控组件 相比之下略显繁琐 表单验证 、选择性开启或者关闭按钮 等功能能轻松处理 所以通常情况下受控组件更能满足我们需求","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"sublime中使用EditorConfig","slug":"sublime中使用editconfig","date":"2018-01-19T02:22:50.000Z","updated":"2018-12-19T10:58:34.913Z","comments":true,"path":"2018/01/19/sublime中使用editconfig/","link":"","permalink":"http://yoursite.com/2018/01/19/sublime中使用editconfig/","excerpt":"","text":"一、作用EditorConfig是统一代码格式的解决方案，它可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格，比如多人合作的时候统一代码风格，避免一些潜在的问题，增加代码可读性 二、使用方法1.编辑器插件有些编辑器已经集成了这个插件，所以不用再安装，而有些编辑器没有集成这个插件，需要安装 下面这些编辑器不需要安装： 已经集成的编辑器 这些编辑器需要安装： 需要单独安装插件的编辑器 sublime里直接搜索 EditorConfig 安装即可 安装 2.配置文件说明在需要的地方配置 .editorconfig文件 注意1： 当打开一个文件时，EditorConfig插件会在打开文件的目录和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=true。什么意思呢？比如我的文件结构是这样的： 文件目录 在 b.js 里的代码，会先从同级目录 ——&gt; 父级目录 这个路径进行查找（冒泡 ），如果遇到了 .editorconfig 里 root=true 则停止，因为 b.js 同级目录的 .editorconfig 里 root=true 所以 b.js 用的就是b.js上面这个文件配置的规则 注意2：EditorConfig配置文件从上往下读取，并且路径最近的文件最后被读取。匹配的配置属性按照属性应用在代码上，所以最接近代码文件的属性优先级最高。什么意思呢？ .editconfig 意思就是 我的 js文件会读取 注释2 (第十行)下面的配置，而python文件会读取上面 (注释1)的配置 3.文件格式详情EditorConfig文件使用INI格式，斜杠(/)作为路径分隔符，#或者;作为注释。注释应该单独占一行。 4.支持的属性注意：不是每种插件都支持所有的属性，具体可见Wiki。 indent_style：tab为hard-tabs，space为soft-tabs。indent_size：设置整数表示规定每级缩进的列数和soft-tabs的宽度（译注：空格数）。如果设定为tab，则会使用tab_width的值（如果已指定）。tab_width：设置整数用于指定替代tab的列数。默认值就是indent_size的值，一般无需指定。end_of_line：定义换行符，支持lf、cr和crlf。charset：编码格式，支持latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用uft-8-bom。trim_trailing_whitespace：设为true表示会除去换行行首的任意空白字符，false反之。insert_final_newline：设为true表明使文件以一个空白行结尾，false反之。root：表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件。 三、我遇到的问题看我的配置文件： .editconfig 我设置了缩进方式为 tab,每级缩进 8 列，但是我设置好后，打开a.js文件后每级的缩进并没有变化，为此我还找了好久~╮(╯▽╰)╭，最后我发现，只要把a.js关闭，再打开就生效了~ 四、总结EditorConfig 可以说很好用了，很适合多人合作情景，但这个只是编辑器级别的格式统一，我会在后面说到代码级别的检测—ESLint，它可以通过我们配置很详细的配置文件，来规范我们的代码风格。","categories":[],"tags":[{"name":"EditorConfig","slug":"EditorConfig","permalink":"http://yoursite.com/tags/EditorConfig/"}]},{"title":"http-proxy-middleware配合gulp使用时的一些坑","slug":"http-proxy-middleware配合gulp使用时的一些坑","date":"2018-01-09T01:23:58.000Z","updated":"2018-12-19T10:58:34.910Z","comments":true,"path":"2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","link":"","permalink":"http://yoursite.com/2018/01/09/http-proxy-middleware配合gulp使用时的一些坑/","excerpt":"","text":"一、介绍在我们用gulp、webpack等方式开发项目的时候，由于会启动个本地服务器，所以如果访问后台提供的接口就是跨域了，这种情况该怎么办呢？这就涉及到了 代理服务 的配置，react项目的webpack的代理服务配置我之前已经写过了，传送门~~。因为使用 http-proxy-middleware 也遇到了多多少少的问题，网上关于遇到的问题解决办法很少或是没有提及（难道问题太弱智？），所以写下这篇文章记录一下（干货满满呦），如果错误烦请指出~~~ 二、环境先说明我的环境：gulp + 静态html 。gulp主要是处理 less 文件和启动服务器方便程序调试 三、目的本地的服务器为：lcoalhost:8080，想要请求的地址为：https://c.y.qq.com/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0 （请求地址是我从QQ音乐找的，正因为这样我又遇到了另外一个 ajax的坑，最后一节有说明，所以这个地址也具有一定的教学意义） 四、配置1.gulpfile.js1234567891011121314151617181920212223var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware'), path = require('path'),gulp.task('connect', function() &#123; connect.server(&#123; /*根路径*/ root: './dist', /*开启浏览器自动刷新*/ livereload: true, /*端口号*/ port: 8080, /*使用代理服务*/ middleware: function(connect, opt) &#123; return [ proxy('/api/', &#123; target: 'https://c.y.qq.com/', changeOrigin:true, &#125;) ] &#125; &#125;);&#125;); 说明 proxy配置项： 其中return 返回是一个数组，所以通过配置多个proxy返回值可以实现多重代理 changeOrigin 这个意思是，如果我们代理的目标地址是一个虚拟托管站点，比如 http://www.baidu.com 这种域名的形式的target项，则需要配置此项。如果target项为ip值，比如http://10.10.16.5/ 则不用配置此项 2.index.html12345678910$.ajax(&#123; type: 'GET', url: \"/api/soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 3.结果可以看到，请求失败 /(ㄒoㄒ)/~~ 4.解决办法就是在这个问题上我卡了一下午，为了能游刃有余的使用这个东西，有些基本的参数还是要非常明白的123pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;, 很多的技术文章的配置都有写这个东西，但是很少有介绍这个参数的意思。 下面我们来看看不配置此项真正请求的地址： 不配置这个参数请求代理的地址：https://c.y.qq.com/ api /soso/fcgi-bin/client_search_cp?ct=24&amp;qqmusic_ver=1298&amp;new_json=1&amp;remoteplace=txt.yqq.center&amp;searchid=36602231022813110&amp;t=0&amp;aggr=1&amp;cr=1&amp;catZhida=1&amp;lossless=0&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=%E7%AB%A5%E5%B9%B4&amp;g_tk=1134636089&amp;jsonpCallback=MusicJsonCallback12090870182687685&amp;loginUin=619697451&amp;hostUin=0&amp;format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0看我标记粉色的地方，再回过头对比我们要请求的地址，是不是多个了 /api/ ? 所以 pathRewrite 这个配置项的意思是，当有 /api/ 字段请求的时候，指定 重写 /api/ 这个字符串，这里为空。 比如：目标地址：http://www.baidu.com/aaa/bbb proxy配置：12345proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, &#125;) 本地服务器：http://localhost:8888 ajax：12345678910$.ajax(&#123; type: 'GET', url: \"/api/aaa/bbb\", success: function(result)&#123; console.log(result); &#125;, error:function(err)&#123; console.log(err+'失败') &#125;&#125;); 但是实际上请求的是 http://www.baidu.com/api/aaa/bbb 这个地址 ！！！！！。 所以第一种解决办法是配置重写路径1234567proxy('/api/', &#123; target: 'http://www.baidu.com/', changeOrigin:true, pathRewrite: &#123; '^/api/' : '', // rewrite path &#125;,&#125;) 第二种解决办法就是利用已有路径 1234proxy('/aaa/', &#123; target: 'http://www.baidu.com/', changeOrigin:true,&#125;) 关于 http-proxy-middleware 我遇到的问题，已经说完了。下面来说 ajax的一个坑 五、ajax用jq的 ajax请求一个地址，如果返回的数据格式与ajax里预期格式的配置不一样，那么就会在 error 函数里面返回后台提供的数据 ，具体例子就不写了，很简单，可以试一试","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}]},{"title":"webpack热更新(HMR)","slug":"webpack热更新-HMR","date":"2018-01-02T07:40:44.000Z","updated":"2018-12-19T10:58:34.914Z","comments":true,"path":"2018/01/02/webpack热更新-HMR/","link":"","permalink":"http://yoursite.com/2018/01/02/webpack热更新-HMR/","excerpt":"","text":"一、HMR介绍在我们开发react应用的时候，在配置了webpack-dev-server的前提下每一次的组件内容修改都需要手动的刷新浏览器，为了解决这个问题，所以有了热更新这个概念，网上的文章弄得我一头雾水，在我配置成功后，自己来记录一下热更新的配置 时隔三个月今天发现了配置更简单的热替换的方法，点我查看 二、配置1.从零开始–项目初始化首先创建一个基本的react的项目，然后命令行运行 npm init 生成 package.json 文件。 新建 build,client 文件夹，分别用来存放 webpack 配置（webpack.config.js文件）和 react 组件。当前目录结构： 目录结构 2.基本的webpack配置为了自动产出html文件，安装 html-webpack-plugin 为了解析 react 组件和对es6的解析，安装 babel-loader babel-core babel-preset-es2015 babel-preset-es2015-loose babel-preset-react 模块，并在根目录新建文件 .babelrc 文件 babel 的配置文件 .babelrc 此时 package.json 文件的包 package.json 添加 webpack-devserver 配置，此时 webpack-config.js 配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');module.exports=&#123; entry: &#123; app:path.join(__dirname,'../client/app.js') &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin() ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; 此时启动webpack-dev-server后，运行成功 package.json 友情提示：： 如果在执行命令的过程中报错 ‘cannot find …’ 这类的错误，首先检查是否少装了包，如果没有少装，则删除 node_module文件夹，重新安装下。 如果运行 webpack-dev-server 启动服务器的时候，网页的 js 文件显示404，首先检查是否本地已经有了一个编译好的 dist 文件夹，因为webpack-dev-server会优先读取本地文件，配置的时候我们添加了 /pubilc/ 所以是读取不道德，这时，删除本地 dist文件夹即可。（这个相当相当的坑） 在入口文件中，我这样写 document.body 是不可取的，正确的做法是 获取Id的形式。 知识点！( 敲黑板 )：path.join 和 path.resolve 区别 path.join：拼接地址（会正确使用当前系统的路径分隔符，Unix系统是/，Windows系统是\\）比如：path.join（‘m’,’/b’） 或者 path.join（‘m’,’b’） 返回m/b这个路径path.resolve：将参数转换为绝对路径比如 path.resolve(‘m’) ;如果当前命令窗口是在c盘打开的，那么返回C:\\m(总是返回一个绝对路径)对比：两种方法都可以获得当前目录的绝对路径（通过__dirname），因为path.join可以适应unix和windows，所以join可能好一些 三、重头戏-配置HMR这里说是简单，但我觉得对于初次使用还是比较繁琐，整理一下，分为下面几个步骤(与顺序无关) 安装 react-hot-loader 配置 babelrc 文件 配置 入口文件app.js 配置 webpack.config.js 2.配置 .babelrc 文件 .babelrc 3. 配置 入口文件app.js 4. 配置 webpack.config.js改动部分标记为 //add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');const webpack=require('webpack'); //addmodule.exports=&#123; entry: &#123; app:[ 'react-hot-loader/patch', //add path.join(__dirname,'../client/app.js') ] &#125;, output:&#123; filename:'[name].[hash].js', path:path.join(__dirname,'../dist'), publicPath:'/public/' &#125;, module:&#123; rules:[ &#123; test:/\\.(jsx|js)$/, loader:'babel-loader', exclude:path.join(__dirname,'../node_modules') &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(), new webpack.HotModuleReplacementPlugin() //add ], devServer:&#123; /*代表本机 也可以通过ip或者localhost这种方式，但是用后面的两种方式的话，局域网内是访问不到本机的，所以用了0.0.0.0*/ host:'0.0.0.0', port:'8888', contentBase:path.join(__dirname,'../dist'), /*热加载*/ //add hot:true, //add /*显示错误信息*/ overlay:&#123; errors:true &#125;, /*因为上面的publicPath:'/public/'，所以访问的所有路径都要加上public*/ publicPath:'/public/', historyApiFallback:&#123; /*如果页面404则返回下面配置的页面*/ index:'/public/index.html' &#125; &#125;&#125; react-hot-loader参考 好了，该做的做完了，打开浏览器测试，发现更改App.jsx文件后浏览器竟然特么没有变化,这就很气人，我也按照你官网上写的做了，现在出不来？好吧，看下面的解决办法 四、解决上面的问题app.js这个入口文件中，更改为： 更改为 如果有了更改，那么 重新用 require 的方式获取一下这个组件，然后进行渲染 成功啦！ 是不是有了疑问，为啥用 require 的方式引入呢？因为这种形式的文件引入import的方式引入不了 五、总结本来一个挺好的功能，分别写在了 webpack官网和 react-hot-loader 官网，这还不算啥，最后还运行不了，多坑，好了就记录到这里了,如果有问题或者补充欢迎回复","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"HMR","slug":"HMR","permalink":"http://yoursite.com/tags/HMR/"}]},{"title":"react服务端渲染","slug":"react服务端渲染","date":"2017-12-26T09:02:19.000Z","updated":"2018-12-19T10:58:34.912Z","comments":true,"path":"2017/12/26/react服务端渲染/","link":"","permalink":"http://yoursite.com/2017/12/26/react服务端渲染/","excerpt":"","text":"看了react服务端渲染，有点蒙圈，先挖坑准备","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"select禁止更改值","slug":"select禁止更改值","date":"2017-11-30T02:31:59.000Z","updated":"2018-12-19T10:58:34.913Z","comments":true,"path":"2017/11/30/select禁止更改值/","link":"","permalink":"http://yoursite.com/2017/11/30/select禁止更改值/","excerpt":"","text":"一、效果介绍select框选中了一个值后禁止更改select 二、方法1.css利用disabled=&quot;true&quot;来禁止选中缺点：这种方法虽然简单，但是它禁止了select框获得焦点，不能看到select的内容优点：简单 2.js123456&lt;select name=\"selectname\" id=\"selectid\" onfocus=\"this.defaultIndex=this.selectedIndex;\" onchange=\"this.selectedIndex=this.defaultIndex;\"&gt; &lt;option value=\"1\"&gt;dd&lt;/option&gt; &lt;option value=\"2\"&gt;mm&lt;/option&gt; &lt;option value=\"3\" selected=\"selected\"&gt;cc&lt;/option&gt; &lt;option value=\"4\"&gt;ff&lt;/option&gt;&lt;/select&gt; 1.获取焦点时，将当前的值 selectedIndex 赋值给一个自定义的属性 defaultIndex2.change时，将当前的值设置为 defaultIndex 优点：select框依然可以选择，被下拉","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"滑动窗口算法解决指定字符串最长子串长度问题","slug":"滑动窗口算法解决指定字符串最长子串长度问题","date":"2017-11-16T07:52:51.000Z","updated":"2018-12-19T10:58:34.914Z","comments":true,"path":"2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","link":"","permalink":"http://yoursite.com/2017/11/16/滑动窗口算法解决指定字符串最长子串长度问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"gitment评论插件的配置","slug":"Hexo博客下gitment评论功能","date":"2017-11-13T08:11:31.000Z","updated":"2018-12-19T10:58:34.907Z","comments":true,"path":"2017/11/13/Hexo博客下gitment评论功能/","link":"","permalink":"http://yoursite.com/2017/11/13/Hexo博客下gitment评论功能/","excerpt":"","text":"今天我在第N次搭建博客的时候想加一个评论功能，我用的主题是indigo，在根目录_config.yml文件里经过测试发现最简洁好用的就是gitment，所以这里记录我gitment配置过程： 第一步先注册一个 oAuth Application注册成功会得到一个client id和 client secret两个参数，它们将被用于后面的用户登录 oAuth Application _config.yml 其中githubID需要https://api.github.com/users/github账户名 访问这个链接来获取 第二步如果你想要此功能的页面存在这一部分： gitment页面配置 这是一个ejs页面，里面是模板，通过使用主题的_config.yml文件配置那么你可以跳过这一步，否则需要在使用评论功能的页面添加这写代码：1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', // 可以是你的GitHub用户名，也可以是github id repo: '存储评论的 github repo', oauth: &#123; client_id: '你的 client id', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')&lt;/script&gt; 第三步到这里已经默认你添加了上面的代码，现在注意了，我用的主题本身就带上面的代码的，只不过需要在 主题的 _comfig.yml文件中配置对应项，我在配置文件中配置好后，启动本地服务器，发现回复模块报错，控制台中发现他会请求一个链接，链接上带有刚刚配置好的参数，这里参数全部为空，我以为我配置文件有问题，折腾了好久，仍然不行，后来发现我要添加这个功能的页面里的模板并没有获取到我在_config.yml配置，最后通过修改要添加回复功能页面的模板文件才成功： 修改为 直接赋值，而不是使用模板，不知道为啥用模板获取不到值，现在已经配置成功如果配置失败，那么一定是上面的参数写错了，或者像我这种情况模板页面获取不到值，只需要直接赋值即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"for循环的灵活运用","slug":"for循环的灵活运用","date":"2017-11-13T08:11:30.000Z","updated":"2018-12-19T10:58:34.909Z","comments":true,"path":"2017/11/13/for循环的灵活运用/","link":"","permalink":"http://yoursite.com/2017/11/13/for循环的灵活运用/","excerpt":"","text":"一、介绍for循环是平时在写代码过程中最常用的代码了，一般写的时候都是中规中矩，比如这样：1234for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125;//打印出四次i的值 个人觉得，要想用好一个东西就要明白它的工作原理，那么for循环的工作原理是什么呢？ 二、工作原理其实对于for循环的工作原理之前也是有多次了解的，可是长时间不去回忆一个知识点，知识点就会变得模糊，这里再次记录一下它的工作流程123for(var i=0;i&lt;4;i++)&#123; console.log(i)&#125; 1.声明一个变量i=02.判断i是否小于43.如果满足判断条件，执行console.log(i)（函数体）4.i++5.循环步骤1-4 图 三、延伸上面的写法都是中规中矩的，for循环有三个对应的参数，以；分隔，那么我可不可以省略其中某个参数呢？ 省略之前要注意，；是一定要加的1.全都省略123for(;;)&#123; console.log(1)&#125; 结果：这样写相当于无限循环了，根本停不下来 2.省略第一参数12345var i=0;for(;i&lt;2;)&#123; console.log(i)&#125;// 在外面声明了一个 i ，如果不声明这个东西，那判断条件该判断啥？所以这就相当于没有省略第一个参数，当然正常情况下我还没见到省略第一个参数的情况，一般情况第一个参数都是有的 结果：这样也会无限循环，因为i的值一直为0，所以它会无限的循环下去延伸：既然第三个参数省略了，我们可以再函数体里面定义它的累加规则啊，比如这样1234567for(var i=0;i&lt;20;)&#123; // 6的倍数 i=i+6; if(i%6===0&amp;&amp;i&lt;20)&#123; console.log(i) &#125;&#125; 好处：循环的次数大大降低，性能提升了，在这里正常情况下需要循环20次进行判断，现在的写法仅需要循环4次（第四次没有打印但是执行了函数体） 仔细观察后发现，其实这种方式就是仅仅省略了第三个参数 3.看看省略第三个参数还能干嘛问题：给定一个很大的数组，数组里面有许多证书，用JavaScript实现一个函数，要求：将数组中之和为10的每一对数配对并找出，返回这些数配对后的数组。例如：[11,3,8,9,7,-1,1,2,4…]得到：[[11,-1],[3,7],[8,2],[9,1]…] 思路：其实一般的写法是两个for循环进行潜逃的那种，这里就不展示了，这里写的是优化后的写法123456789101112131415161718192021let list = [1,2,3,-5,9,45,6];function map(list)&#123; let ret=[]; list=list.sort((a,b)=&gt;a-b); /*省略的第三个参数*/ for(let i=0,j=list.length-1;i&lt;j;)&#123; let a=list[i],b=list[j]; if(a+b===10)&#123; ret.push([a,b]); i++; j--; &#125;else if(a+b&lt;10)&#123; i++; &#125;else&#123; j--; &#125; &#125; return ret;&#125;console.log(JSON.stringify(map(list)))//结果：[[1,9]] 思路：这里影响性能的主要是太多次的for循环，数据量小还好，如果特别多怎么办？所以要减少for循环次数，先将数组从小到大排序，然后进行从两边到中间的计算，符合条件就 push一次 四、总结简简单单的一个for循环可以有不同的写法，所以说写代码简单，写出有质量的代码难","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"斐波那契数列的实现","slug":"斐波那契数列的实现","date":"2017-10-25T09:10:02.000Z","updated":"2018-12-19T10:58:34.914Z","comments":true,"path":"2017/10/25/斐波那契数列的实现/","link":"","permalink":"http://yoursite.com/2017/10/25/斐波那契数列的实现/","excerpt":"","text":"一、扫盲斐波那契数列也叫黄金分割数列，也叫兔子数列原理：假定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子，如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？ 月份 兔子情况 总数 第0个月 a（小兔子） 1 第1个月 a（具备繁殖能力） 1 第2个月 b（生啦生啦）+ a（他父母） 2 第3个月 b（2月份出生的具备繁殖能力，正跃跃欲试） + b2（他父母又生二胎了） +a（他父母） 3 第4个月 c（2月份的兔子b喜当爹）+b（二月份出生的兔子） + b2（二胎具备繁殖能力，准备生娃） +a（他父母）+d(a生三胎) 5 … … … 1、1 、2、3、5、8、13、21、34、55、89……所以规律就是 fn(n)=fn(n-1)+fn(n-2) 二、代码实现1.第一种这种是最常见的实现：迭代12345678910111213/**i 月份*/function fn(i)&#123; var a=[]; /*0个月什么都不存在*/ a[0]=0; a[1]=1; for(var o=2;o&lt;=i;o++)&#123; a[o]=a[o-1]+a[o-2]; &#125; return a[i]&#125; 2.第二种递归1234567/** i 月份*/function fn(i)&#123; if(i&lt;2)&#123;return i===0?0:1;&#125; return fn(i-1)+fn(i-2)&#125; 是不是感觉很简洁 三、缺陷针对这个例子来说，这里的递归会进行太多次的调用（比迭代多），所以简洁的背后牺牲的是性能","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"css中的attr()","slug":"css中的attr","date":"2017-10-11T03:43:15.000Z","updated":"2018-12-19T10:58:34.909Z","comments":true,"path":"2017/10/11/css中的attr/","link":"","permalink":"http://yoursite.com/2017/10/11/css中的attr/","excerpt":"","text":"1.介绍attr() 用来获取一个html元素的属性值，可以用于伪元素，可以用于任何css属性 2.用法这个使用起来非常方便且简单1content:attr(属性值); attr()可以传三个值，分别是属性值、类型限制、默认值（必须符合类型限制），不过我试了半天也没调试成功，而且一般写一个参数就行，三个参数的情况基本用不到，所以就跳过了 3.例子12345678910111213141516171819&lt;hear&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 400px; height: 400px; border:1px solid #ccc; &#125; .box:after&#123; content:attr(data-foo); background-color: #ff461d; color: #fff; border-radius: .32rem; padding: .053333rem .133333rem; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\" data-foo=\"hello\"&gt;&lt;/div&gt;&lt;/body&gt; 此时，在div中将会出现一个红色背景的hello 4.实例那么这个东西在什么情况下能用到呢？ 购物车","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"attr()","slug":"attr","permalink":"http://yoursite.com/tags/attr/"}]},{"title":"react中的this.props.children","slug":"React.Children","date":"2017-09-28T09:34:55.000Z","updated":"2018-12-19T10:58:34.907Z","comments":true,"path":"2017/09/28/React.Children/","link":"","permalink":"http://yoursite.com/2017/09/28/React.Children/","excerpt":"","text":"一、介绍React.Children 是顶层API之一，为处理 this.props.children 提供了几个方法this.props.children 表示组件所有子节点 二、所有方法1.React.Children.map12345678//必须有返回值React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;)//没有返回值React.Children.map(this.props.children,function(child)&#123; /*这里进行处理*/&#125;) 这里的 child 表示组件的每一个子元素，也可以用箭头函数来写，这样方便this的传递 2.this.props.children这个是获取当前组件的所有子节点注意 ：1.如果没有子节点，返回 undefined2.如果一个子节点，返回 object3.如果多个子节点，返回 array但是用 React.Children.map 来遍历的话不会有问题 3.React.Children.count返回组件的所有子元素个数 4.React.Children.only12console.log(React.Children.only(this.props.children[0])); //输出对象this.props.children[0] 单独 this.props.children[0] 输出不出来 5.child.key在用 React.Children.map 的时候可能想获取传过来的属性值，例如123456789101112&lt;Tabs_li data=&#123;data&#125;&gt; &lt;div key=&#123;0&#125;&gt;1&lt;/div&gt; &lt;div key=&#123;1&#125;&gt;2&lt;/div&gt; &lt;div key=&#123;2&#125;&gt;3&lt;/div&gt;&lt;/Tabs_li&gt;/*Tabs组件*/&#123;React.Children.map(this.props.children,(child)=&gt;&#123; console.log(child.key) // 分别打印 0 ， 1 ，2 return ...&#125;)&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react中跨域请求数据","slug":"react中跨域请求数据","date":"2017-09-27T06:03:37.000Z","updated":"2018-12-19T10:58:34.912Z","comments":true,"path":"2017/09/27/react中跨域请求数据/","link":"","permalink":"http://yoursite.com/2017/09/27/react中跨域请求数据/","excerpt":"","text":"一、介绍在我写 react ele 项目的时候，里面的所有数据都要从ele获取，所以我之前的想法是先用死的数据模拟，然后用 node 写几个接口请求ele数据并返回给我的react。知道今天早上，我在纳闷 react开发过程中是用 webpack 起服务器的，那跟后台就是跨域了啊，这样ajax是没有办法请求的，所以吃完一个鸡蛋后查找了一番，果然让我找到了，看下面 传送门 – gulp里服务端代理配置 二、配置webpack中 proxy 是设置代理的1234567proxy: &#123; \"/api\": &#123; target: \"http://localhost:3000\", secure: false, changeOrigin : true &#125;&#125;, 现在比如说我 /api/users 这么请求，现在将代理请求http://localhost:3000/api/users 注意 ：这里的 secure 参数表示能请求 https 的服务器changeOrigin 表示是否支持跨域请求，默认 false 实例好了 现在我来试验一下12345\"/base\": &#123; target: \"http://c.y.qq.com/\", secure: false, changeOrigin : true&#125; 这个是我从qq音乐找了一个借口，在react中通过 fetch 请求12var result = fetch('/base/fcgi-bin/fcg_wxdownload_config.fcg', &#123; credentials: 'include', headers: &#123; 'Accept': 'application/json, text/plain, */*' &#125; &#125;)result.then(res =&gt;&#123;return res.text();&#125;).then(text =&gt; &#123; console.log(text) &#125;) 看看返回结果 控制台输出 是不是很方便~","categories":[],"tags":[{"name":"webpack proxy","slug":"webpack-proxy","permalink":"http://yoursite.com/tags/webpack-proxy/"},{"name":"react跨域请求","slug":"react跨域请求","permalink":"http://yoursite.com/tags/react跨域请求/"}]},{"title":"认识pushstate、popstate,无刷新改变URL","slug":"认识pushstate、popstate-无刷新改变URL","date":"2017-09-22T06:39:04.000Z","updated":"2018-12-19T10:58:34.915Z","comments":true,"path":"2017/09/22/认识pushstate、popstate-无刷新改变URL/","link":"","permalink":"http://yoursite.com/2017/09/22/认识pushstate、popstate-无刷新改变URL/","excerpt":"","text":"一、回顾 window.historyhistory对象包含用户（在浏览器窗口中）访问过的url12345678910//回退history.back();//前进history.forward();//跳转history.go();//历史记录条数（当前网页的，不是浏览器的）history.length//状态history.state 二、认识新特性HTML5扩展了history,使历史记录更加灵活，可以在历史记录中存储指定记录点、替换当前历史记录点，监听历史记录点 2.1.存储历史记录点123456window.history.pushState('新添加的','','?page=3');// 第一个参数：设置state// 第二个参数：页面标题，但是所有浏览器都忽略了，传空字符串就行// 第三个删除：想要添加的链接//`注意，这个api会改变当前的网址，会添加一条历史记录，不是push到后面，这样会添加一条历史` 执行后，页面的URL为当前url？page=3 执行前 执行后 此时的history.length也会+1，新增了历史记录点 2.2.替换历史记录点12345window.history.replaceState('新添加的','','?page=3');//`注意，这个api会改变当前的网址(不跳转)，不会添加一条历史记录，注意与上面pushState区别`&gt; 补充：location.replace()也是替换当前网址，但是页面会跳转，而且不会添加历史记录 区别：1.history.length不会变2.替换了当前页的历史记录点 2.3.监听历史记录点1window.onpopstate=function()&#123;&#125; 浏览器前进后退都会触发这个事件比如可以这样：123window.onpopstate=function(event)&#123; console.log(event.state)&#125; 后退操作时，就会打印出后退到的历史记录点的state信息。 四、用途在我写react饿了么的项目时，点击首页的定位信息，会从右滑动出一个新的页面，此时再通过浏览器的前进后退按钮也可以实现页面的滑动 浏览器控制动画 具体制作过程看我的github：ele项目 五、补充在用 document.referrer 做返回按钮的时候，是只有 a标签 才能添加一条来源的。比如我通过点击页面的一个 链接 调到了对应的页面，那么此时 document.referrer 是有值的，通过 history.pushState 添加的历史记录跳转的页面,不会添加一条 document.referrer 来源","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"position的sticky属性","slug":"position的sticky属性","date":"2017-09-13T02:25:03.000Z","updated":"2018-12-19T10:58:34.911Z","comments":true,"path":"2017/09/13/position的sticky属性/","link":"","permalink":"http://yoursite.com/2017/09/13/position的sticky属性/","excerpt":"","text":"表头跟随 图中展示的效果使我们在日常开发中常见的效果。以前我都是用js判断是否滚动一定距离然后给这个元素设置position:fixed这种方式来做的，今天就来记录一下用css怎么做 一、介绍css 中的 position 属性的值常用的主要有下面几种：1.absolute2.relative3.fixed现在用到的值为 sticky：设置了sticky的元素，不脱离文档流，在屏幕范围时（viewport），该元素位置不受到定位影响（top、left等值无效），当该元素的视图将要离开偏移范围时，定位会变成 fixed 的效果，并且根据设置的top 、left值进行定位 二、用法上面的gif图里，我将搜索框的元素设置为123postion:sticky;top:0;left:0 所以当移出屏幕时就会触发fixed定位 三、兼容性刚刚把它用在实际项目中去了，结果安卓自带的浏览器不支持，所以附加上解决办法：12345678910111213141516171819202122232425262728//判断是否支持if (CSS.supports(\"position\", \"sticky\") || CSS.supports(\"position\", \"-webkit-sticky\")) &#123; // 支持 sticky,顶部吸附 this.setState(&#123; support:true &#125;)&#125;else&#123; document.addEventListener('scroll',this._scrollTop)&#125;//不支持的主要处理_scrollTop()&#123; let offsetY=this.searchDOM.offsetTop; let css=null; if(window.scrollY&gt;offsetY)&#123; css=&#123; position:'fixed', top:0, zIndex:999 &#125; &#125;else&#123; css=&#123; position:'static', &#125; &#125; this.setState(&#123; css &#125;)&#125; 四、总结 该元素不脱离文档流，仍保留元素原本在文档流中的位置 当元素在容器中被滚动超过指定偏移值时，元素在容器内固定在指定位置。比如你设置了 top:50px 那么sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动 元素固定的相对偏移是相对于它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于 viewport 来计算元素的偏移量","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"create-react-app配置webpack","slug":"create-react-app配置webpack","date":"2017-09-06T08:42:15.000Z","updated":"2018-12-19T10:58:34.908Z","comments":true,"path":"2017/09/06/create-react-app配置webpack/","link":"","permalink":"http://yoursite.com/2017/09/06/create-react-app配置webpack/","excerpt":"","text":"在学习react过程中，每次都要配置webpack，非常的麻烦，我是要写react的，不是配置这东西哒！！好在有了’create-react-app’，通过npm安装后，创建项目变得非常简单但是它里面没有做less等你实际项目需要的loader或者plugins，所以这里记录的是怎么定制create-react-app创建的项目的webpack 一、先配置less1.创建一个项目我创建的叫test test测试项目 创建完毕后，进入创建的项目，运行npm start启动此项目 启动 2.找到webpack.config.dev.js和webpack.config.prod.js运行npm run eject安装less-loader和less进入config文件夹，这里会有两个文件webpack.config.dev.js和webpack.config.prod.js应该一个是开发环境一个生产环境的配置文件，两个文件都要修改打开webpack.config.dev.js找到module rules部分，也就是配置loader的部分，找到配置css文件的test（/\\.(css)$/）修改为test:/\\.(css|less)$/,添加一个loader：{ loader: require.resolve(&#39;less-loader&#39;) },放在最下面1234567891011121314151617181920212223242526&#123; test: /\\.css$/, use: [require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () = &gt;[require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: ['&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') &#125;, ],&#125;, 3.测试现在我们做一下测试可以随便在css文件中加入less语法我在App.css中设置了整体的背景颜色：1234567@base: pink;.App-header &#123; background-color: @base; height: 150px; padding: 20px; color: white;&#125; 因为我们修改了webpack的配置项，所以需要重新启动服务器： 添加成功 可以看到，配置已经成功 二、配置px2rem1.解释px2rem是做移动端页面开发的时候，自动将px单位转换为rem，非常的方便这里要用支持webpack的对应loader，我用的是postcss-px2rem配置这个功能相对来说有些复杂 2.安装npm install postcss-px2rem postcss-loader --save执行这个命令安装 3.配置还是webpack.config.dev.js，引入1const px2rem = require('postcss-px2rem') 添加在的autoprefixer下面添加，好像loaders里只能有一个postcss，多个的话不会报错，对应的功能会不管用12345678910111213141516171819202122&#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), //这个位置 px2rem(&#123;remUnit: 75&#125;) ], &#125;,&#125;, 这里面的数值就是1rem对应的px 4.测试现在启动服务器，因为原有的都是以px为单位，所以现在页面上应该全部转换为了rem 添加成功 不要忘了配置webpack.config.prod.js这个文件，最后只需要在你的页面上对html的font-size做变换就可以了，这里略过 5.总结webpack的文档和有些npm的文档写的走点心好么，搞得本来挺简单的东西查了好久！","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"px2rem","slug":"px2rem","permalink":"http://yoursite.com/tags/px2rem/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"箭头函数的this指向","slug":"箭头函数的this指向","date":"2017-08-25T07:14:31.000Z","updated":"2018-12-19T10:58:34.915Z","comments":true,"path":"2017/08/25/箭头函数的this指向/","link":"","permalink":"http://yoursite.com/2017/08/25/箭头函数的this指向/","excerpt":"","text":"前言 es6的箭头函数非常简洁，而且还可以解决很多问题1.解决以前通过var that=this方式传值的问题1234567document.body.addEventListener('click',function()&#123; setTimeout(function()&#123; console.log(this) /*window*/ /*对body节点操作代码...*/ &#125;)&#125;) 比如点击body，过一段时间对body这个元素进行对应的js操作，如上代码，很明显是不对的，因为setTimeout里的this是全局window所以是不能通过它操作body元素， 一般这种情况以前都是通过在外层通过一个变量将this传递进来，但是有了箭头函数就不用这么做了 es6:1234567document.body.addEventListener('click',function()&#123; setTimeout(()=&gt;&#123; console.log(this) /*body(当前节点)*/ /*对body节点操作代码...*/ &#125;)&#125;) 这类的问题还有很多，但是为什么箭头函数能轻易地解决这些问题呢？所以要清楚能这么写的原因就要清楚箭头函数中this的指向 一、写箭头函数的小提示1.当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。1234/*错误*/()=&gt;&#123;&#125;/*正确*/()=&gt;(&#123;&#125;) 因为JavaScript引擎会将{x}理解成一个代码块，空对象和块在这里都是{}这样表示，所以如果返回的是一个对象，需要加一个小括号 箭头函数的this箭头函数没有自己的this!!!!!!!!!,它内部的this值集成自外围作用域123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 t1、t2、t3都输出1因为箭头函数没有自己的this所以this.id会顺着作用域链查找一直找到foo()函数 箭头函数的的特点它没有arguments变量12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 如果有了新发现，会回来补充","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"react中的context","slug":"react中的context","date":"2017-08-21T03:29:02.000Z","updated":"2018-12-19T10:58:34.912Z","comments":true,"path":"2017/08/21/react中的context/","link":"","permalink":"http://yoursite.com/2017/08/21/react中的context/","excerpt":"","text":"一、为什么用context？现在我们有一颗组件树： 组件树 假如这个组件树代表的应用是用户可以自定义主题的，每个子组件都会根据主题的不同来调整自己的样式，所以‘主题色’这个东西就应该是组件之间共享的一个状态，所以应该放到Index组件中。但是在此之前能想到的办法只能是this.props.主题色 主题色的传递 这种形式，这种形式实在是麻烦，如果组件嵌套过深，就不得不一层层传递到最底层，所以就出现了简单的办法——通过context传递context这种方法是全局都能共享的状态，我们需要的时候就去取这个状态，不需要手动传递 context共享状态 二、实践，看看代码怎么写先创建一个整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Index extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;Title /&gt; &lt;/div&gt; ) &#125;&#125;class Main extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;This is main&lt;/h2&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;class Title extends Component &#123; render () &#123; return ( &lt;h1&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h2&gt;React.js 小书内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Index /&gt;, document.getElementById('root')) 修改Index组件修改Index组件，让他往自己的context中放一个themeColor：1234567891011121314151617181920212223class Index extends Component &#123; static childContextTypes = &#123; themeColor: PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor: 'red' &#125; &#125; getChildContext () &#123; return &#123; themeColor: this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125; 代码说明1.state初始化一个themeColor状态，方便以后的修改2.getChildContext方法设置context，返回一个的对象就是context，所有子组件动能访问到，且用this.state.themeColor来设置context里面的themeColor3.注意，还需要加上一段参数的验证 childContextTypes,需要使用prop-types这个包，验证的是getChildContext返回的对象以上这些都是必须的,这里要提及一下为啥要验证context，这么多步骤多麻烦，据说context是一个危险的属性(context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料),所以按照react.js团队的想法就是，把危险的事情搞复杂一些，提高使用门栏人们就不去用了 子组件的设置class Title extends Component { static contextTypes = { themeColor: PropTypes.string } render () { return ( &lt;h1 style={{ color: this.context.themeColor }}&gt;React.js 小书标题&lt;/h1&gt; ) } } 1.利用contextTypes进行验证，必写的，不写就无法获取context的状态，2.使用的话是通过this.context.themeColor来获取值的 修改context在Index里面，我们已经初始化一个state状态了，叫：this.state.themeColor,所以使用setState就可以了 四、我的例子: 点击变色按钮前 点击变色按钮后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript时间处理小技巧","slug":"js时间","date":"2017-08-18T07:41:37.000Z","updated":"2018-12-19T10:58:34.910Z","comments":true,"path":"2017/08/18/js时间/","link":"","permalink":"http://yoursite.com/2017/08/18/js时间/","excerpt":"","text":"获取当前时间1new Date() 获取当前时间的毫秒数12345678new Date().getTime()/*返回1970年1月1日至今的毫秒数*//*下面是作用相同，写法不同*/Date.now()/*这个也返回值相同*/+new Date() +”操作符123456789/*将元素转换成number类型*/+'123'/*返回123*/+'www'/*返回NaN*//*同理*/+Date.now() toLocaleDateString() 和 toLocaleTimeString() 区别123456789new Date().toLocaleDateString()/*2017/8/18 获取的年月日*/new Date().toLocaleTimeString()/*下午3:56:16 获取的时分秒*//*注意必须要用时间对象调用才行 比如 Date.now().toLocaleDateString()会报错，因为Date.now()返回的是毫秒数*/ 时间格式处理技巧如果想格式处理 当前时间与之前某个特定时间的时差 可以用这样的方式123456789/*duration为差值*/duration&gt;60 ?`$&#123;Math.round(duration/60)&#125;分钟前` : `$&#123;Math.round(Math.max(duration , 1))&#125;秒前`/*1.利用了ES6的模板字符串，结构更清晰2.利用三目运算符(三元运算符)进行判断，避免各种if3.Math.max 如果差值小于1s，则按1s计算，避免又一次的if判断*/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]}