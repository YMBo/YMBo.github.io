---
title: 通信方式
date: 2019-11-21 14:37:47
tags: http
---

### 一、WebSocket
#### 全双工通信
通信双方都可以发送和接受信息
#### 2. WebSocket协议
一旦建立WebScoket协议的通信连接，通信可以发送JSON、XML、HTML或图片任意格式的数据

#### 3. 功能（优点）
##### 1. 推送功能
服务端可以主动向客户端推送数据啦
##### 2. 减少通信量
建立的WebSocket连接，一直保持连接状态，和HTTP相比减少了每次连接的开销，而且WebSocket的首部信息很小，所以通信量也少了

#### 3. 连接过程
<p style='font-size:13px;color:#565656'>
为了实现WebSocket通信，在HTTP连接建立之后，需要**完成一次握手的步骤**
为了实现WebSocket,需要用到HTTP的** Upgrade的首部字段 **，告诉服务器通信协议发生改变，以达到握手的目的
![请求头](/images/通信方式/1.png)
Sec-WebSocket-Key 字段记录握手过程必不可少的键值
Sec-WebSocket-Protocol 字段记录使用的子协议

![流程](/images/通信方式/3.png)
</p>

**响应：**
![响应头](/images/通信方式/2.png)

#### 4. 实现
##### 1. 前台
``` html
<body>
    <button id="a">发信息</button>
</body>
<script type="text/javascript">
    let ws = new WebSocket('ws://localhost:3333')

    // 触发连接
    ws.onopen = function() {
        console.log('连接')
    }
    ws.onclose = function() {
        console.log('断开连接')
    }
    ws.onmessage = function(e) {
        console.log('收到信息', e.data)
    }
    document.getElementById("a").onclick = function() { // 监测 id=“sendb”的 按钮 触发 onclick 就会发送数据 send //
        ws.send('发信息了');
    }
</script>

```

##### 2. 后台
``` javascript
const ws = require('nodejs-websocket')

let server = ws.createServer(conn => {
    console.log('连接', conn)
    conn.on('text', str => {
        console.log(str)
    })
    conn.on('close', (code, reason) => {
        console.log('连接断开')
    })
    conn.on('error', err => {

    })
}).listen(3333)
```
##### 3. 结果
![信息头](/images/通信方式/4.png)
点击发信息
![结果](/images/通信方式/5.png)


### 一、SSE （server-sent event）
仅仅服务端往客户端推动，基于http协议
``` javascript
var source = new EventSource(url);
```
EventSource实例的readyState属性，表明连接的当前状态。该属性只读，可以取以下值。
>0：相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。
1：相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。
2：相当于常量EventSource.CLOSED，表示连接已断，且不会重连。

#### 1. 数据格式（发送端）
##### ⓵ 响应头
响应头必须有
1.  **Content-Type: text/event-stream** MIME Type 规定为 text/event-stream
2. **Cache-Control: no-cache** 不允许缓存（可不写）
3. **Connection: keep-alive**  指定持久连接，默认都是持久连接（可不写）

##### ⓶ data 数据
数据用data表示，用 `\n\n`结尾
比如： data: 这里是数据 \n\n 
多行用 `\n` 分隔，`\n\n` 结尾
比如：
data: asdf \n
data: ghjk \n
data: asdf \n\n
这是一条数据

##### ⓷ event 事件类型
前端默认用 `message` 接收事件，但是也可以用服务端自定的事件名称

event: have \n
data: 定义了一个have事件 \n\n

触发客户端 `have` 事件

##### ⓸ retry 最大间隔时间
浏览器默认服务器端三秒内没有发送任何信息，则开始重连。服务器端可以用retry头信息，指定这个时间
retry: 10000\n

##### ⓹ id
id: msg1\n
data: message\n\n

我没咋用到过 

浏览器会一直跟踪最近的事件ID，如果发生了重连，浏览器会把最近接收到的事件ID放入 HTTP Header “Last-Event-ID” 中，作为一种简单的同步机制。

##### ⓺ 客户端主动关闭
``` javascript
source.close();
```

##### ⓻ 服务端关闭
我用的node做测试的，就是接受一个前端触发的`close`事件，来关闭
``` javascript
req.connection.addListener("close", function() {
        clearInterval(interval);
}, false);
```
#### 2. demo
##### ⓵ 客户端
``` javascript
let source = new EventSource('/url');
source.onmessage = function(e) {
    console.log(e, e.data);
};
setTimeout(() => {
    source.close()
}, 5000);
```
##### ⓶ 服务端（node）
``` javascript
app.use("/url", function(req, res) {
    res.writeHead(200, {
        "Content-Type": "text/event-stream",
    });
    setInterval(() => {
        res.write("id: num1\n\n");
        res.write("data:" + (new Date()) + "\n\n");
    }, 1000);

    req.connection.addListener("close", function() {
        clearInterval(interval);
    }, false);
})
```

每一秒触发一次，5秒断开连接

##### ⓷ gif
![结果](/images/通信方式/6.gif)













