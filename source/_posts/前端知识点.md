---
title: 前端知识点
date: 2019-09-17 14:42:40 
tags: [javascript,css,http,react,vue] 
---
## 一、JavaScript
### 一、['1', '2', '3'].map(parseInt) ？ 
> [1,NaN,NaN] 

 **parseInt(string, radix)，字符串转十进制整数**


`string`：<span style='font-size:13px'>必需。要被解析的字符串。</span>
`radix` : <span style='font-size:13px'>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</span>

<span style='font-size:13px;color:#0b807d'>
解析的时候，parseInt会认为 `string` 参数是 `radix` 进制的，比如：
`parseInt(3,4)` ,这里会认为“3”是 4进制的，所以当遇到这种情况:
`parseInt(3,2)`, 会认为这里的“3”是二进制的，那么3的二进制是3吗？不是啊，是 "11"啊 ，所以会返回NaN
</span>

### 二、防抖和节流
`下面我都用的 函数属性timer作为记录定时器的变量，其实也可以在函数内声明一个变量`
#### 1. 防抖实现
<span style='font-size:13px;color:#0b807d'>
    触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间,
    比如窗口缩放事件 window.resize
</span>
``` javascript
function debounce(fn,time){
    return function(){
        clearTimeout(fn.timer)
        fn.timer=setTimeout(()=>{
            fn.apply(this, arguments)
        },time)
    }
}
```
<span style='font-size:13px;color:#0b807d'>
问：`为啥用apply?`
答：改变函数this指向
问：为啥要改变fn的this指向？如果不apply这个this又指向谁？要是不改有啥影响？
卒~

`解析：`首先要明白一件事情，**this**的指向问题，
**this的指向只是与如何调用这个方法有关**，看几个例子
``` javascript
a={
    m:function(){
        console.log(this)
    }
}
----------------------------------------------
1. 
a.m()       // a{} 对象

----------------------------------------------
2. 
var b=a.m;
    m()         //  指向全局对象，这里是window
----------------------------------------------
3. 
a.s=function(){
    setTimeout(function(){
        console.log(this)
    })
}
// 注意这里setTimeout我用的是 普通函数，this指向全局对象，这里指向window

4. 
a.s=function(){
    setTimeout(()=>{
        console.log(this)
    })
}
//  因为用了箭头函数，这里的this指向上一层this，即a对象

3、4 注意对比
----------------------------------------------
5. 
在函数里面执行a.m
function c(){
    a.m()
}
// a对象

6.
function m(){
    console.log(this)
}
a.c=function(){
    m()
}
a.c()         // window

5、6 
注意对比，这俩都是函数里面的函数执行。
因为里面函数里面的函数并不是作为一个方法所调用，
所以指向的是window，注意与 5 做对比
----------------------------------------------
```
<span style='font-size:13px;color:#0b807d'>
看完上面例子，你就知道了setTimeout里如果用箭头函数，那么this是当前作用于，但是 `fn()` 这样执行的时候，里面的this指向全局，所以要给这个fn绑定当前执行环境的this，以避免一些因为作用域问题引起bug
</span>

#### 2. 节流实现 
<span style='font-size:13px;color:#0b807d'>
高频事件触发，但在n秒内只会执行一次
</span>
``` javascript
function debounce(fn,time){
    return function(){
        if(fn.timer)return
        fn.timer=setTimeout(()=>{
            fn.apply(this, arguments)
            clearTimeout(fn.timer)
        },time)
    }
}
```
</span>

### 三、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
[阮一峰es6](http://es6.ruanyifeng.com/#docs/set-map)

### 四、深度优先遍历和广度优先遍历
``` html
<div class="parent">
    <div class="child-1">
        <div class="child-1-1">
            <div class="child-1-1-1"></div>
        </div>
        <div class="child-1-2"></div>
    </div>
    <div class="child-2">
        <div class="child-2-1"></div>
        <div class="child-2-2"></div>
    </div>
    <div class="child-3">
        <div class="child-3-1"></div>
        <div class="child-3-2"></div>
    </div>
</div>
```
#### 1. 深度优先遍历
``` javascript
function deepTraversal(node){
    let result=[]
    result.push(node)
    if(node.children){
        for(let i =0,length=node.children.length;i<length;i++){
           result=result.concat(deepTraversal(node.children[i])) 
        }
    }
    return result
}
```
![深度优先遍历](/images/前端知识点/1.png)

#### 2. 广度优先遍历
``` javascript
function widthTraversal(node){
    let result=[]
    let stack=[]
    let cd=undefined
    stack.push(node)
    while(cd=stack.shift()){
        result.push(cd)
        if(cd.children){
            for(let i =0,length=cd.children.length;i<length;i++){
                stack.push(cd.children[i])
            }
        }
    }
    return result
}
```
![广度优先遍历](/images/前端知识点/2.png)

### 五、深拷贝函数
``` javascript
function deepCopy(obj){
    if(typeof obj!=='object')return obj
    let newobj=undefined
    if(Array.isArray(obj)){
        newobj=[...obj]
    }else{
        newobj={...obj}
    }
    for(let i in obj){
        newobj[i]=deepCopy(obj[i])
    }
    return newobj
}
```

### 六、事件循环
js中的`栈`和`堆`分别存储值类型和引用类型
`执行栈`和上面的栈意义不同，
<span style='font-size:13px;color:#0b807d'>
当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。
</span>
** 事件循环 **
<span style='font-size:13px;color:#0b807d'>
js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起（`浏览器去执行`），继续执行执行栈中的其他任务。当一个异步事件返回结果后（`注意是异步有了返回结果后，将回调函数添加到事件队列`），js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，` 而是等待当前执行栈中的所有任务都执行完毕`(`这也是为什么setTimeout 时间不会非常精确的原因`)， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为`“事件循环（Event Loop）”`的原因。</span>

![事件循环](/images/前端知识点/3.jpg)
`callback queue`：事件队列
`webAPIs` ：异步操作（浏览器执行）
`stack`:执行栈

### 七、宏任务和微任务
<span style='font-size:13px;color:#0b807d'>异步事件也分宏任务和微任务，他们执行顺序的优先级不同
`宏任务`:setTimeout、setInterval、I/O、UI 渲染
`微任务`:Promise、MutaionObserver
**同一次事件循环中微任务比宏任务优先级高**
</span>

**执行顺序**
<span style='font-size:13px;color:#0b807d'>执行队列空闲=>检查微任务队列=>检查宏任务队列</span>
``` javascript
setTimeout(function () {
    console.log(1);
});

new Promise(function(resolve,reject){
    console.log(2)
    resolve(3)
}).then(function(val){
    console.log(val);
})
// 2,3,1
```
**执行过程**
<span style='font-size:13px;color:#0b807d'>
script进入主线程开始执行同步代码，将异步操作交给浏览器执行，所以先将setTimeout挂起，然后打印 2 ，遇到了promise则挂起，此时任务队列空闲（这时异步操作都已经执行完加入了事件队列），那么去检查事件队列，先检查微任务队列，好，发现了 promise的then回调，执行 ，打印3，微任务队列空了，检查宏任务队列 打印1 ，此时执行栈为空 ,退出
</span>

**比较特殊的例子**
``` javascript
async function async1(){
    console.log('1');
    await async2();
    console.log('2')
}
async function async2(){
    console.log('3')
}

console.log('4');
async1();
console.log('5')

// 4，1，3，5，2
```
<span style='font-size:13px;color:#0b807d'>
async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行
也就是 await async2()后面（下面）的部分是放在了promise（微任务），所以才有这样的结果
</span>
**练习题，写出执行结果**
`考点：就是事件循环、宏任务、微任务的执行顺序，上面说的弄明白了，就很容易了`
``` javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```


### 八、for循环每隔1秒输出对应数值
<span style='font-size:13px;color:#0b807d'>因为以前面试遇到过，所以就记录下来</span>
1. async、await
``` javascript
async function a() {
    for (var i = 0; i < 10; i++) {
        await new Promise((resolve, reject) => {
            console.log(i);
            setTimeout(() => {
                resolve(i)
            }, 1000)
        })
    }
}
```
2. 闭包，这种方式的缺陷就是第一次其实是有间隔时间的，而上面是马上输出的
``` javascript
function b() {
    for (var i = 0; i < 10; i++) {
        (function(i) {
            setTimeout(() => {
                console.log(i)
            }, 1000 * i)
        })(i)
    }
}
```
3. let/const,原理是每次循环let或const形成了自己的局部作用域
``` javascript
function b() {
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            console.log(i)
        }, 1000 * i)
    }
}
```

### 九、编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
> arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

1. **方法一**
``` javascript
[...new Set(arr.flat(Infinity))].sort((a,b)=>a-b)
```

2. **方法二**
``` javascript
function flatSortRepeat(arr) {
    let result = []
    for (let i in arr) {
        if (Array.isArray(arr[i])) {
            let child = flatSort(arr[i])
            for (let m in child) {
                if (result.indexOf(child[m]) < 0) {
                    result.push(child[m])
                }
            }
        } else {
            if (result.indexOf(arr[i]) < 0) {
                result.push(arr[i])
            }
        }
    }
    // 注意sort不生成副本，是在原有数组基础上改的
    return result.sort((a, b) => a - b)
}
```

### 十、new的时候发生了啥 || 实现一个new
``` javascript
/*
@param constructor被new的类（构造函数）
*/
function new2(constructor){
	//创建一个实例对象o，并将该对象原型（__proto__）指向func（构造函数）的原型对象
	var o = Object.create(constructor.prototype);
	//将o作为构造函数的this执行构造函数
	var k= constructor.call(o);
	// 如果构造函数返回值是引用类型则将实例对象o代替
	return typeof k==='object' ? k : o;	
}
```